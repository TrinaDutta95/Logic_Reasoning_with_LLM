import amrlib
import json
import re
from amrlib_master import amrlib
import openai
from amr_logic_converter import AmrLogicConverter
from utils import *


# Function to split concatenated sentences into individual sentences
def split_sentences(input_list):
    result = []
    for text in input_list:
        # Split the text by newline characters
        sentences = re.split(r'\n', text)
        result.extend(sentences)
    return result


# Function to extract individual graphs from multi-sentence AMR input
def extract_individual_graphs(amr_list):
    individual_graphs = []
    for amr in amr_list:
        # Remove sentence annotations
        amr = '\n'.join([line for line in amr.split('\n') if not line.startswith('# ::snt')])
        individual_graphs.append(amr)
    return individual_graphs


def amr_conversion(premise, conclusion):
    # converting NL to AMR
    print(premise[0], conclusion)
    stog = amrlib.load_stog_model()
    # premise = split_sentences(premise)
    premise_graphs = stog.parse_sents(premise[0])
    # conclusion = split_sentences(conclusion)
    conclusion_graph = stog.parse_sents(conclusion)
    return premise_graphs, conclusion_graph


def amr_to_fol(amr):
    converter = AmrLogicConverter()
    logic = converter.convert(amr)
    return logic


def get_completion(prompt, model="gpt-4", temperature=0):
    """
    Generate a completion for the given prompt using the specified model.

    Parameters:
    prompt (str): The prompt to send to the model.
    model (str): The model to use for generating the completion. Default is "gpt-4".
    temperature (float): The degree of randomness of the model's output. Default is 0.

    Returns:
    str: The completion generated by the model.
    """
    try:
        response = openai.ChatCompletion.create(
            model=model,
            messages=[{"role": "user", "content": prompt}],
            temperature=temperature,
        )
        return response.choices[0].message["content"]
    except openai.error.OpenAIError as e:
        print(f"An error occurred: {e}")
        return None


def fol_conversion(premise_graphs_list, conclusion_graphs_list, api_key):
    """
    Convert the given AMR to First Order Logic (FOL) using the OpenAI API.

    Parameters:
    premise_graphs_list (list): List of premises in AMR format.
    conclusion_graphs_list (list): List of conclusions in AMR format.
    api_key (str): OpenAI API key.

    Returns:
    dict: A dictionary with "premise-fol" and "conclusion-fol" keys containing the converted FOL expressions.
    """
    openai.api_key = api_key

    prompt_1 = f"""
    I will provide you with premises and conclusions in 
    /AMR, and you will convert them into First Order Logic (FOL) expressions.
    Examples:
    Example1:
    "premises":"(p / occur-01\n:ARG1 (m / monkeypox-virus)\n:ARG2 (b / being)\n:ARG3 (g / get-01\n:ARG0 b\n:ARG1 m))\n(a / animal\n:mod (c / certain)\n:domain (m / monkeypox-virus))\n(h / human\n:ARG0-of (m / mammal))\n(m / mammal\n:ARG0-of (a / animal))\n(s / symptom\n:ARG1 (m / monkeypox-virus)\n:ARG2 (f / fever)\n:ARG3 (h / headache)\n:ARG4 (m / muscle-pain)\n:ARG5 (t / tiredness))\n(p / people\n:ARG0-of (t / tired)\n:ARG1 (f / flu))"
    "premises-FOL":["exist x. (OccurIn(monkeypoxVirus, x) & Get(x, monkeypoxVirus))","exist x. (Animal(x) & OccurIn(monkeypoxVirus, x))","all x (Human(x) -> Mammal(x))","all x (Mammal(x) -> Animal(x))","exist x. (SymptomOf(x, monkeypoxVirus) & (Fever(x) | Headache(x) | MusclePain(x) | Tired(x)))","all x. (Human(x) & Get(x, flu) -> Feel(x, tired))"]
    "conclusion":"(a / animal)"
    "conclusion-FOL":["exist x. (Animal(x))"]
    
    Example2:
    "premises":"(h / human\n:mod (a / all))\n(m / mortal\n:domain h)\n(s / socrates\n:instance-of h)"
    "premises-FOL":["all x. (Human(x) -> Mortal(x))", "Human(Socrates)"]
    "conclusion":"(m / mortal\n:instance-of s)"
    "conclusion-FOL":["Mortal(Socrates)"]
    
    Example3:
    "premises":"(r / rain-01\n:ARG0 (w / wet\n:ARG1 (g / ground)))\n(r / rain-01\n:time (n / now))"
    "premises-FOL":["all x. (Rain(x) -> Wet(Ground))", "Rain(now)"]
    "conclusion":"(w / wet\n:ARG1 (g / ground))"
    "conclusion-FOL":["Wet(Ground)"]
    
    Example4:
    "premise":"(r / when\n:op1 (p / person)\n:op2 (l / listen\n:ARG0 p\n:ARG1 (m / music))\n:op3 (f / feel\n:ARG0 p\n:ARG1 (e / emotion)))\n(l / listen\n:ARG0 (p / person :name "Jack")\n:ARG1 (s / song\n:name (n / name :op "Moonlight Sonata")\n:composer (c / composer\n :name (n2 / name :op "Ludwig Beethoven"))))
    "premise-FOL":["all x,y. (Person(x) & Music(y) & ListensTo(x,y) -> FeelsEmotion(x))", "ListensTo(Jack, MoonlightSonata)", "Composer(MoonlightSonata, LudwigBeethoven)"]
    "conclusion":"(f / feel\n:ARG0 (p / person :name "Jack")\n:ARG1 (e / emotion))"
    "conclusion-FOL":["FeelsEmotion(Jack)"]
    
    
    Ensure that:
    - Each FOL expression follows the correct syntax: Logical AND: `&`, Logical OR: `|`, Logical NOT: `-`, Implication: `->`.
    - Symbols are consistently used as either predicates or functions.
    - Quantifiers are correctly placed 
    - No quotations are required for any proper noun.
    - The FOL expressions are valid and well-formed for use in theorem provers like Prover9.
    - Make sure the FOL expressions are consistent, syntactically correct, and have balanced parentheses.
    - Make sure the output is not like a chat response.


    Your output should be a dictionary with the keys "premise-fol" for {premise_graphs_list} with all FOL expressions
    /in a single list and 
    "conclusion-fol" for {conclusion_graphs_list} with all FOL expressions in a single list.
    """
    response_q = get_completion(prompt_1)
    return response_q


def processing_fol(file_path):
    # reading json file to get list of examples
    api_key = "add api key here"
    with open(file_path, 'r') as f:
        json_list = json.load(f)
        for example in json_list:
            premise = example["premises"]
            premise = [premise]
            print("premise:", premise)
            conclusion = example["conclusion"]
            conclusion = [conclusion]
            print("conclusion:", conclusion)
            actual_label = example["label"]
            print("actual_label:", actual_label)
            p_graph, c_graph = amr_conversion(premise, conclusion)
            print("p_graph:", p_graph)
            print("c_graph:", c_graph)

            fol_dict = fol_conversion(p_graph, c_graph, api_key)
            # Parse the string into a Python dictionary to ensure it is valid JSON
            try:
                fol_json = json.dumps(fol_dict)
                print(fol_json)# Serialize dictionary to JSON
                fol_data = json.loads(fol_json)
                print("JSON parsed successfully!")
                yield fol_data, actual_label
            except json.JSONDecodeError as e:
                print("Failed to parse JSON:", e)


if __name__ == '__main__':
    for fol_data, actual_label in processing_fol("data/test.json"):
        print(fol_data, type(fol_data))



