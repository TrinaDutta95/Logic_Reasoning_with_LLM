[
    {
        "premises": "All people who regularly drink coffee are dependent on caffeine.\nPeople regularly drink coffee, or they don't want to be addicted to caffeine, or both.\nNo one who doesn't want to be addicted to caffeine is unaware that caffeine is a drug.\nRina is either a student who is unaware that caffeine is a drug, or she is not a student and is she aware that caffeine is a drug.\nRina  is either a student who is dependent on caffeine, or she is not a student and not dependent on caffeine.",
        "premises-FOL": [
            "all x. (DrinkRegularly(x, Coffee) -> IsDependentOn(x, Caffeine))\nall x. (DrinkRegularly(x, Coffee)  | (-WantToBeAddictedTo(x, Caffeine)))\nall x. (-WantToBeAddictedTo(x, Caffeine) -> -AwareThatDrug(x, Caffeine))\n-(Student(Rina) \u2295  -AwareThatDrug(Rina, Caffeine))\n-(((IsDependentOn(Rina, Caffeine) & -Student(Rina)) | (-IsDependentOn(Rina, Caffeine) & Student(Rina))))"
        ],
        "conclusion": "Rina doesn't want to be addicted to caffeine or is unaware that caffeine is a drug.",
        "conclusion-FOL": "-WantToBeAddictedTo(Rina, Caffeine) | (-AwareThatDrug(Rina, Caffeine))",
        "label": "ERROR"
    },
    {
        "premises": "All people who regularly drink coffee are dependent on caffeine.\nPeople regularly drink coffee, or they don't want to be addicted to caffeine, or both.\nNo one who doesn't want to be addicted to caffeine is unaware that caffeine is a drug.\nRina is either a student who is unaware that caffeine is a drug, or she is not a student and is she aware that caffeine is a drug.\nRina  is either a student who is dependent on caffeine, or she is not a student and not dependent on caffeine.",
        "premises-FOL": [
            "all x. (DrinkRegularly(x, Coffee) -> IsDependentOn(x, Caffeine))\nall x. (DrinkRegularly(x, Coffee)  | (-WantToBeAddictedTo(x, Caffeine)))\nall x. (-WantToBeAddictedTo(x, Caffeine) -> -AwareThatDrug(x, Caffeine))\n-(Student(Rina) \u2295  -AwareThatDrug(Rina, Caffeine))\n-(((IsDependentOn(Rina, Caffeine) & -Student(Rina)) | (-IsDependentOn(Rina, Caffeine) & Student(Rina))))"
        ],
        "conclusion": "Rina eith doesn't want to be addicted to caffeine or is unaware that caffeine is a drug.",
        "conclusion-FOL": "-WantToBeAddictedTo(Rina, Caffeine) \u2295 -AwareThatDrug(Rina, Caffeine)",
        "label": "ERROR"
    },
    {
        "premises": "All people who regularly drink coffee are dependent on caffeine.\nPeople regularly drink coffee, or they don't want to be addicted to caffeine, or both.\nNo one who doesn't want to be addicted to caffeine is unaware that caffeine is a drug.\nRina is either a student who is unaware that caffeine is a drug, or she is not a student and is she aware that caffeine is a drug.\nRina  is either a student who is dependent on caffeine, or she is not a student and not dependent on caffeine.",
        "premises-FOL": [
            "all x. (DrinkRegularly(x, Coffee) -> IsDependentOn(x, Caffeine))\nall x. (DrinkRegularly(x, Coffee)  | (-WantToBeAddictedTo(x, Caffeine)))\nall x. (-WantToBeAddictedTo(x, Caffeine) -> -AwareThatDrug(x, Caffeine))\n-(Student(Rina) \u2295  -AwareThatDrug(Rina, Caffeine))\n-(((IsDependentOn(Rina, Caffeine) & -Student(Rina)) | (-IsDependentOn(Rina, Caffeine) & Student(Rina))))"
        ],
        "conclusion": "Rina either regularly drinks coffee or is unaware that caffeine is a drug.",
        "conclusion-FOL": "DrinkRegularly(Rina, Coffee)  \u2295 IsUnawareThatCaffeineIsADrug(Rina)",
        "label": "ERROR"
    },
    {
        "premises": "All people who regularly drink coffee are dependent on caffeine.\nPeople regularly drink coffee, or they don't want to be addicted to caffeine, or both.\nNo one who doesn't want to be addicted to caffeine is unaware that caffeine is a drug.\nRina is either a student who is unaware that caffeine is a drug, or she is not a student and is she aware that caffeine is a drug.\nRina  is either a student who is dependent on caffeine, or she is not a student and not dependent on caffeine.",
        "premises-FOL": [
            "all x. (DrinkRegularly(x, Coffee) -> IsDependentOn(x, Caffeine))\nall x. (DrinkRegularly(x, Coffee)  | (-WantToBeAddictedTo(x, Caffeine)))\nall x. (-WantToBeAddictedTo(x, Caffeine) -> -AwareThatDrug(x, Caffeine))\n-(Student(Rina) \u2295  -AwareThatDrug(Rina, Caffeine))\n-(((IsDependentOn(Rina, Caffeine) & -Student(Rina)) | (-IsDependentOn(Rina, Caffeine) & Student(Rina))))"
        ],
        "conclusion": "If Rina either doesn't want to be addicted to caffeine and is unaware that caffeine is a drug, or neither doesn't want to be addicted to caffeine nor is unaware that caffeine is a drug, then Rina doesn't want to be addicted to caffeine and regularly drinks coffee.",
        "conclusion-FOL": "(DoNotWantToBeAddictedToCaffeine(Rina) \u2295 -AwareThatDrug(Rina, Caffeine)) -> -(-WantToBeAddictedTo(Rina, Caffeine) & DrinkRegularly(Rina, Coffee))",
        "label": "ERROR"
    },
    {
        "premises": "Miroslav Venhoda was a Czech choral conductor who specialized in the performance of Renaissance and Baroque music.\nAny choral conductor is a musician.\nSome musicians love music.\nMiroslav Venhoda published a book in 1946 called Method of Studying Gregorian Chant.",
        "premises-FOL": [
            "Czech(Miroslav) & ChoralConductor(Miroslav) & SpecializeInPerformanceOf(Miroslav, RenaissanceMusic) & SpecializeInPerformanceOf(Miroslav, BaroqueMusic)\nall x. (ChoralConductor(x) -> Musician(x))\nexists x. exists y. ((Musician(x) -> Love(x, Music)) & (-(x=y) & Musician(y) -> Love(y, Music)))\nPublishedBook(Miroslav, MethodOfStudyingGregorianChant, YrOneNineFourSix)"
        ],
        "conclusion": "Miroslav Venhoda loved music.",
        "conclusion-FOL": "Love(Miroslav, Music)",
        "label": "ERROR"
    },
    {
        "premises": "Miroslav Venhoda was a Czech choral conductor who specialized in the performance of Renaissance and Baroque music.\nAny choral conductor is a musician.\nSome musicians love music.\nMiroslav Venhoda published a book in 1946 called Method of Studying Gregorian Chant.",
        "premises-FOL": [
            "Czech(Miroslav) & ChoralConductor(Miroslav) & SpecializeInPerformanceOf(Miroslav, RenaissanceMusic) & SpecializeInPerformanceOf(Miroslav, BaroqueMusic)\nall x. (ChoralConductor(x) -> Musician(x))\nexists x. exists y. ((Musician(x) -> Love(x, Music)) & (-(x=y) & Musician(y) -> Love(y, Music)))\nPublishedBook(Miroslav, MethodOfStudyingGregorianChant, YrOneNineFourSix)"
        ],
        "conclusion": "A Czech published a book in 1946.",
        "conclusion-FOL": "exists x. exists y. (Czech(x) & PublishedBook(x, y, YearOneNineFourSix))",
        "label": "ERROR"
    },
    {
        "premises": "Miroslav Venhoda was a Czech choral conductor who specialized in the performance of Renaissance and Baroque music.\nAny choral conductor is a musician.\nSome musicians love music.\nMiroslav Venhoda published a book in 1946 called Method of Studying Gregorian Chant.",
        "premises-FOL": [
            "Czech(Miroslav) & ChoralConductor(Miroslav) & SpecializeInPerformanceOf(Miroslav, RenaissanceMusic) & SpecializeInPerformanceOf(Miroslav, BaroqueMusic)\nall x. (ChoralConductor(x) -> Musician(x))\nexists x. exists y. ((Musician(x) -> Love(x, Music)) & (-(x=y) & Musician(y) -> Love(y, Music)))\nPublishedBook(Miroslav, MethodOfStudyingGregorianChant, YrOneNineFourSix)"
        ],
        "conclusion": "No choral conductor specialized in the performance of Renaissance.",
        "conclusion-FOL": "all x. (ChoralConductor(x) -> -SpecializeInPerformanceOf(x, RenaissanceMusic))",
        "label": "ERROR"
    },
    {
        "premises": "All eels are fish. \nNo fish are plants. \nEverything displayed in the collection is either a plant or an animal.\nAll multicellular animals are not bacteria.\nAll animals displayed in the collection are multicellular.\nA sea eel is displayed in the collection.\nThe sea eel is an eel or an animal or not a plant.",
        "premises-FOL": [
            "all x. (Eel(x) -> Fish(x))\nall x. (Fish(x) -> -Plant(x))\nall x. (DisplayedIn(x, Collection) -> ((Plant(x) & -Animal(x)) | (-Plant(x) & Animal(x))))\nall x. (Multicellular(x) -> -Bacteria(x))\nall x. (DisplayedIn(x, Collection) & Animal(x) -> Multicellular(x))\nDisplayedIn(SeaEel, Collection)\nEel(SeaEel) | Animal(SeaEel) | -Plant(SeaEel)"
        ],
        "conclusion": "The sea eel is an eel.",
        "conclusion-FOL": "Eel(SeaEel)",
        "label": "ERROR"
    },
    {
        "premises": "All eels are fish. \nNo fish are plants. \nEverything displayed in the collection is either a plant or an animal.\nAll multicellular animals are not bacteria.\nAll animals displayed in the collection are multicellular.\nA sea eel is displayed in the collection.\nThe sea eel is an eel or an animal or not a plant.",
        "premises-FOL": [
            "all x. (Eel(x) -> Fish(x))\nall x. (Fish(x) -> -Plant(x))\nall x. (DisplayedIn(x, Collection) -> ((Plant(x) & -Animal(x)) | (-Plant(x) & Animal(x))))\nall x. (Multicellular(x) -> -Bacteria(x))\nall x. (DisplayedIn(x, Collection) & Animal(x) -> Multicellular(x))\nDisplayedIn(SeaEel, Collection)\nEel(SeaEel) | Animal(SeaEel) | -Plant(SeaEel)"
        ],
        "conclusion": "The sea eel is bacteria.",
        "conclusion-FOL": "Bacteria(SeaEel)",
        "label": "ERROR"
    },
    {
        "premises": "All eels are fish. \nNo fish are plants. \nEverything displayed in the collection is either a plant or an animal.\nAll multicellular animals are not bacteria.\nAll animals displayed in the collection are multicellular.\nA sea eel is displayed in the collection.\nThe sea eel is an eel or an animal or not a plant.",
        "premises-FOL": [
            "all x. (Eel(x) -> Fish(x))\nall x. (Fish(x) -> -Plant(x))\nall x. (DisplayedIn(x, Collection) -> ((Plant(x) & -Animal(x)) | (-Plant(x) & Animal(x))))\nall x. (Multicellular(x) -> -Bacteria(x))\nall x. (DisplayedIn(x, Collection) & Animal(x) -> Multicellular(x))\nDisplayedIn(SeaEel, Collection)\nEel(SeaEel) | Animal(SeaEel) | -Plant(SeaEel)"
        ],
        "conclusion": "The sea eel is multicellular or is bacteria.",
        "conclusion-FOL": "Multicellular(SeaEel) | Bacteria(SeaEel)",
        "label": "ERROR"
    },
    {
        "premises": "The Blake McFall Company Building is a building added to the National Register of Historic Places in 1990.\nThe Emmet Building is a five-story building in Portland, Oregon.\nThe Emmet Building was built in 1915.\nThe Emmet Building is another name for the Blake McFall Company Building.\nJohn works at the Emmet Building.",
        "premises-FOL": [
            "Building(BlakeMcFallCompanyBuilding) & AddedToIn(BlakeMcFallCompanyBuilding, TheNationalRegisterOfHistoricPlaces, YearOneNineNineZero)\nBuilding(EmmetBuilding) & Five-Story(EmmetBuilding) & LocatedIn(EmmetBuilding, Portland) & LocatedIn(Portland, Oregon))\nBuiltIn(EmmetBuilding, YearOneNineOneFive)\nEmmetBuiling=BlakeMcFallCompanyBuilding\nWorkAt(John, EmmetBuilding)"
        ],
        "conclusion": "A five-story building is built in 1915.",
        "conclusion-FOL": "exists x. (Building(x) & Five-Story(x) & ConstructedIn(x, YearOneNineOneFive))",
        "label": "ERROR"
    },
    {
        "premises": "The Blake McFall Company Building is a building added to the National Register of Historic Places in 1990.\nThe Emmet Building is a five-story building in Portland, Oregon.\nThe Emmet Building was built in 1915.\nThe Emmet Building is another name for the Blake McFall Company Building.\nJohn works at the Emmet Building.",
        "premises-FOL": [
            "Building(BlakeMcFallCompanyBuilding) & AddedToIn(BlakeMcFallCompanyBuilding, TheNationalRegisterOfHistoricPlaces, YearOneNineNineZero)\nBuilding(EmmetBuilding) & Five-Story(EmmetBuilding) & LocatedIn(EmmetBuilding, Portland) & LocatedIn(Portland, Oregon))\nBuiltIn(EmmetBuilding, YearOneNineOneFive)\nEmmetBuiling=BlakeMcFallCompanyBuilding\nWorkAt(John, EmmetBuilding)"
        ],
        "conclusion": "The Blake McFall Company Building is located in Portland, Oregon.",
        "conclusion-FOL": "LocatedIn(BlakeMcFallCompanyBuilding, Portland)",
        "label": "ERROR"
    },
    {
        "premises": "The Blake McFall Company Building is a building added to the National Register of Historic Places in 1990.\nThe Emmet Building is a five-story building in Portland, Oregon.\nThe Emmet Building was built in 1915.\nThe Emmet Building is another name for the Blake McFall Company Building.\nJohn works at the Emmet Building.",
        "premises-FOL": [
            "Building(BlakeMcFallCompanyBuilding) & AddedToIn(BlakeMcFallCompanyBuilding, TheNationalRegisterOfHistoricPlaces, YearOneNineNineZero)\nBuilding(EmmetBuilding) & Five-Story(EmmetBuilding) & LocatedIn(EmmetBuilding, Portland) & LocatedIn(Portland, Oregon))\nBuiltIn(EmmetBuilding, YearOneNineOneFive)\nEmmetBuiling=BlakeMcFallCompanyBuilding\nWorkAt(John, EmmetBuilding)"
        ],
        "conclusion": "John started his current job in 1990.",
        "conclusion-FOL": "StartCurrentJobIn(John, YearOneNineNineZero)",
        "label": "ERROR"
    },
    {
        "premises": "William Dickinson was a British politician who sat in the House of Commons\nWilliam Dickinson attended Westminster school for high school and then the University of Edinburgh.\nThe University of Edinburgh is a university located in the United Kingdom.\nWilliam Dickinson supported the Portland Whigs.\nPeople who supported the Portland Whigs did not get a seat in the Parliament.",
        "premises-FOL": [
            "British(WilliamDickinson) & Politician(WilliamDickinson) & SatIn(WilliamDickinson, HouseOfCommons)\nAttended(WilliamDickinson, WestminsterSchool) & Highschool(WestminsterSchool) & Attended(WilliamDickinson, UniversityOfEdinburgh)\nUniversity(UniversityOfEdinburgh) & LocatedIn(UniversityOfEdinburgh, UnitedKingdom)\nSupported(WilliamDickinson, PortlandWhigs)\nall x. (Supported(x, PortlandWhigs) -> -SatIn(x, Parliament))"
        ],
        "conclusion": "William Dickinson did not get a seat in Parliament.",
        "conclusion-FOL": "SatIn(WilliamDickinson, Parliament)",
        "label": "ERROR"
    },
    {
        "premises": "William Dickinson was a British politician who sat in the House of Commons\nWilliam Dickinson attended Westminster school for high school and then the University of Edinburgh.\nThe University of Edinburgh is a university located in the United Kingdom.\nWilliam Dickinson supported the Portland Whigs.\nPeople who supported the Portland Whigs did not get a seat in the Parliament.",
        "premises-FOL": [
            "British(WilliamDickinson) & Politician(WilliamDickinson) & SatIn(WilliamDickinson, HouseOfCommons)\nAttended(WilliamDickinson, WestminsterSchool) & Highschool(WestminsterSchool) & Attended(WilliamDickinson, UniversityOfEdinburgh)\nUniversity(UniversityOfEdinburgh) & LocatedIn(UniversityOfEdinburgh, UnitedKingdom)\nSupported(WilliamDickinson, PortlandWhigs)\nall x. (Supported(x, PortlandWhigs) -> -SatIn(x, Parliament))"
        ],
        "conclusion": "William Dickinson went to schools located in the United Kingdom for both high school and university.",
        "conclusion-FOL": "exists x. exists y. (Attended(WilliamDickinson, x) & Highschool(x) & LocatedIn(x, UnitedKingdom) & Attended(WilliamDickinson, y) & University(y) & LocatedIn(y, UnitedKingdom))",
        "label": "ERROR"
    },
    {
        "premises": "William Dickinson was a British politician who sat in the House of Commons\nWilliam Dickinson attended Westminster school for high school and then the University of Edinburgh.\nThe University of Edinburgh is a university located in the United Kingdom.\nWilliam Dickinson supported the Portland Whigs.\nPeople who supported the Portland Whigs did not get a seat in the Parliament.",
        "premises-FOL": [
            "British(WilliamDickinson) & Politician(WilliamDickinson) & SatIn(WilliamDickinson, HouseOfCommons)\nAttended(WilliamDickinson, WestminsterSchool) & Highschool(WestminsterSchool) & Attended(WilliamDickinson, UniversityOfEdinburgh)\nUniversity(UniversityOfEdinburgh) & LocatedIn(UniversityOfEdinburgh, UnitedKingdom)\nSupported(WilliamDickinson, PortlandWhigs)\nall x. (Supported(x, PortlandWhigs) -> -SatIn(x, Parliament))"
        ],
        "conclusion": "William Dickinson attended university in the United Kingdom.",
        "conclusion-FOL": "exists x. (Attended(WilliamDickinson, x) & University(x) & LocatedIn(x, UnitedKingdom))",
        "label": "ERROR"
    },
    {
        "premises": "William Dickinson was a British politician who sat in the House of Commons\nWilliam Dickinson attended Westminster school for high school and then the University of Edinburgh.\nThe University of Edinburgh is a university located in the United Kingdom.\nWilliam Dickinson supported the Portland Whigs.\nPeople who supported the Portland Whigs did not get a seat in the Parliament.",
        "premises-FOL": [
            "British(WilliamDickinson) & Politician(WilliamDickinson) & SatIn(WilliamDickinson, HouseOfCommons)\nAttended(WilliamDickinson, WestminsterSchool) & Highschool(WestminsterSchool) & Attended(WilliamDickinson, UniversityOfEdinburgh)\nUniversity(UniversityOfEdinburgh) & LocatedIn(UniversityOfEdinburgh, UnitedKingdom)\nSupported(WilliamDickinson, PortlandWhigs)\nall x. (Supported(x, PortlandWhigs) -> -SatIn(x, Parliament))"
        ],
        "conclusion": "William Dickinson sat in the House of Commons.",
        "conclusion-FOL": "SatIn(WilliamDickinson, HouseOfCommons)",
        "label": "ERROR"
    },
    {
        "premises": "LanguageA is a universal language\nIf a universal language exists, then for every two people if they both know the same universal language they can communicate.\nKatya cannot communicate with Danil.\nKatya knows LanguageA. ",
        "premises-FOL": [
            "UniversalLanguage(LanguageA)\nall x. all y. (exists z. (-(x=y) & Know(x, z) & Know(y, z) & UniversalLanguage(z)) -> CanCommunicateWith(x, y) & CanCommunicateWith(y, x))\n-CanCommunicateWith(Katya, Danil)\nKnow(Katya, LanguageA)"
        ],
        "conclusion": "Danil knows LanguageA.",
        "conclusion-FOL": "Know(Danil, LanguageA)",
        "label": "ERROR"
    },
    {
        "premises": "All customers in James' family who subscribe to AMC A-List are eligible to watch three movies every week without any additional fees. \nSome of the customers in James' family go to the cinema every week.\nCustomers in James' family subscribe to AMC A-List or HBO service. \nCustomers in James' family who prefer TV series will not watch TV series in cinemas.\nAll customers in James' family who subscribe to HBO services prefer TV series to movies. \nLily is in James' family; she watches TV series in cinemas. ",
        "premises-FOL": [
            "all x. ((Customer(x) & In(x, JameSFamily) & SubscribedTo(x, aMCAList)) ->  EligibleForThreeFreeMoviesEveryWeekWithoutAdditionalFees(x))\nexists x. exists y. (Customer(x) & In(x, JameSFamily) & GoToEveryWeek(x, Cinema) & (-(x=y)) & Customer(y) & In(y, JameSFamily) & GoToEveryWeek(y, Cinema))\nall x. (Customer(x) & In(x, JameSFamily) & (SubscribedTo(x, aMCAList) | SubscribedTo(x, hBO)))\nall x. ((Customer(x) & In(x, JameSFamily) & Prefer(x, tVSeries)) -> (-WatchIn(x, tV, Cinema)))\nall x. ((Customer(x) & In(x, JameSFamily) &  SubscribedTo(x, hBO)) -> Prefer(x, tVSeries))\nCustomer(Lily) & In(Lily, JameSFamily & WatchIn(Lily, tV, Cinema)"
        ],
        "conclusion": "Lily goes to cinemas every week.",
        "conclusion-FOL": "GoToEveryWeek(Lily, Cinema)",
        "label": "ERROR"
    },
    {
        "premises": "All customers in James' family who subscribe to AMC A-List are eligible to watch three movies every week without any additional fees. \nSome of the customers in James' family go to the cinema every week.\nCustomers in James' family subscribe to AMC A-List or HBO service. \nCustomers in James' family who prefer TV series will not watch TV series in cinemas.\nAll customers in James' family who subscribe to HBO services prefer TV series to movies. \nLily is in James' family; she watches TV series in cinemas. ",
        "premises-FOL": [
            "all x. ((Customer(x) & In(x, JameSFamily) & SubscribedTo(x, aMCAList)) ->  EligibleForThreeFreeMoviesEveryWeekWithoutAdditionalFees(x))\nexists x. exists y. (Customer(x) & In(x, JameSFamily) & GoToEveryWeek(x, Cinema) & (-(x=y)) & Customer(y) & In(y, JameSFamily) & GoToEveryWeek(y, Cinema))\nall x. (Customer(x) & In(x, JameSFamily) & (SubscribedTo(x, aMCAList) | SubscribedTo(x, hBO)))\nall x. ((Customer(x) & In(x, JameSFamily) & Prefer(x, tVSeries)) -> (-WatchIn(x, tV, Cinema)))\nall x. ((Customer(x) & In(x, JameSFamily) &  SubscribedTo(x, hBO)) -> Prefer(x, tVSeries))\nCustomer(Lily) & In(Lily, JameSFamily & WatchIn(Lily, tV, Cinema)"
        ],
        "conclusion": "Lily does not go to cinemas every week.",
        "conclusion-FOL": "-GoToEveryWeek(Lily, Cinema)",
        "label": "ERROR"
    },
    {
        "premises": "All customers in James' family who subscribe to AMC A-List are eligible to watch three movies every week without any additional fees. \nSome of the customers in James' family go to the cinema every week.\nCustomers in James' family subscribe to AMC A-List or HBO service. \nCustomers in James' family who prefer TV series will not watch TV series in cinemas.\nAll customers in James' family who subscribe to HBO services prefer TV series to movies. \nLily is in James' family; she watches TV series in cinemas. ",
        "premises-FOL": [
            "all x. ((Customer(x) & In(x, JameSFamily) & SubscribedTo(x, aMCAList)) ->  EligibleForThreeFreeMoviesEveryWeekWithoutAdditionalFees(x))\nexists x. exists y. (Customer(x) & In(x, JameSFamily) & GoToEveryWeek(x, Cinema) & (-(x=y)) & Customer(y) & In(y, JameSFamily) & GoToEveryWeek(y, Cinema))\nall x. (Customer(x) & In(x, JameSFamily) & (SubscribedTo(x, aMCAList) | SubscribedTo(x, hBO)))\nall x. ((Customer(x) & In(x, JameSFamily) & Prefer(x, tVSeries)) -> (-WatchIn(x, tV, Cinema)))\nall x. ((Customer(x) & In(x, JameSFamily) &  SubscribedTo(x, hBO)) -> Prefer(x, tVSeries))\nCustomer(Lily) & In(Lily, JameSFamily & WatchIn(Lily, tV, Cinema)"
        ],
        "conclusion": "Lily goes to cinemas every week or watches 3 movies every week without any additional fees.",
        "conclusion-FOL": "GoToEveryWeek(Lily, Cinema) | EligibleForThreeFreeMoviesWithoutAdditionalFees(Lily)",
        "label": "ERROR"
    },
    {
        "premises": "All customers in James' family who subscribe to AMC A-List are eligible to watch three movies every week without any additional fees. \nSome of the customers in James' family go to the cinema every week.\nCustomers in James' family subscribe to AMC A-List or HBO service. \nCustomers in James' family who prefer TV series will not watch TV series in cinemas.\nAll customers in James' family who subscribe to HBO services prefer TV series to movies. \nLily is in James' family; she watches TV series in cinemas. ",
        "premises-FOL": [
            "all x. ((Customer(x) & In(x, JameSFamily) & SubscribedTo(x, aMCAList)) ->  EligibleForThreeFreeMoviesEveryWeekWithoutAdditionalFees(x))\nexists x. exists y. (Customer(x) & In(x, JameSFamily) & GoToEveryWeek(x, Cinema) & (-(x=y)) & Customer(y) & In(y, JameSFamily) & GoToEveryWeek(y, Cinema))\nall x. (Customer(x) & In(x, JameSFamily) & (SubscribedTo(x, aMCAList) | SubscribedTo(x, hBO)))\nall x. ((Customer(x) & In(x, JameSFamily) & Prefer(x, tVSeries)) -> (-WatchIn(x, tV, Cinema)))\nall x. ((Customer(x) & In(x, JameSFamily) &  SubscribedTo(x, hBO)) -> Prefer(x, tVSeries))\nCustomer(Lily) & In(Lily, JameSFamily & WatchIn(Lily, tV, Cinema)"
        ],
        "conclusion": "If Lily does not both go to cinemas every week and subscribe to HBO service, then Lily is either available to watch 3 movies every week without any additional fees or she prefers TV more.",
        "conclusion-FOL": "(GoToEveryWeek(Lily, Cinema) & SubscribedTo(Lily, hBO)) -> (((EligibleForThreeFreeMoviesEveryWeek(Lily) & -Prefer(Lily, tVSeries)) | (-EligibleForThreeFreeMoviesEveryWeek(Lily) & Prefer(Lily, tVSeries))))",
        "label": "ERROR"
    },
    {
        "premises": "All customers in James' family who subscribe to AMC A-List are eligible to watch three movies every week without any additional fees. \nSome of the customers in James' family go to the cinema every week.\nCustomers in James' family subscribe to AMC A-List or HBO service. \nCustomers in James' family who prefer TV series will not watch TV series in cinemas.\nAll customers in James' family who subscribe to HBO services prefer TV series to movies. \nLily is in James' family; she watches TV series in cinemas. ",
        "premises-FOL": [
            "all x. ((Customer(x) & In(x, JameSFamily) & SubscribedTo(x, aMCAList)) ->  EligibleForThreeFreeMoviesEveryWeekWithoutAdditionalFees(x))\nexists x. exists y. (Customer(x) & In(x, JameSFamily) & GoToEveryWeek(x, Cinema) & (-(x=y)) & Customer(y) & In(y, JameSFamily) & GoToEveryWeek(y, Cinema))\nall x. (Customer(x) & In(x, JameSFamily) & (SubscribedTo(x, aMCAList) | SubscribedTo(x, hBO)))\nall x. ((Customer(x) & In(x, JameSFamily) & Prefer(x, tVSeries)) -> (-WatchIn(x, tV, Cinema)))\nall x. ((Customer(x) & In(x, JameSFamily) &  SubscribedTo(x, hBO)) -> Prefer(x, tVSeries))\nCustomer(Lily) & In(Lily, JameSFamily & WatchIn(Lily, tV, Cinema)"
        ],
        "conclusion": "If Lily is available to watch 3 movies every week without any additional fees and she watches TV series in cinemas, then she goes to cinemas every week and prefers TV series more.",
        "conclusion-FOL": "(EligibleForThreeFreeMoviesEveryWeekWithoutAdditionalFees(Lily) & WatchIn(Lily, tV, Cinema)) -> (GoToEveryWeek(Lily, Cinema) & Prefer(Lily, tVSeries))",
        "label": "ERROR"
    },
    {
        "premises": "A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.\nIf there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.\nReal Madrid and Barcelona are both La Liga soccer teams.\nReal Madrid received more points than Barcelona.\nNeither Real Madrid nor Barcelona received more points from the games between them.",
        "premises-FOL": [
            "all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))\nall x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))\nLaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)\nMorePoints(RealMadrid, Barcelona)\n-MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)"
        ],
        "conclusion": "Real Madrid ranks higher than Barcelona.",
        "conclusion-FOL": "RankHigherThan(RealMadrid, Barcelona)",
        "label": "ERROR"
    },
    {
        "premises": "A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.\nIf there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.\nReal Madrid and Barcelona are both La Liga soccer teams.\nReal Madrid received more points than Barcelona.\nNeither Real Madrid nor Barcelona received more points from the games between them.",
        "premises-FOL": [
            "all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))\nall x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))\nLaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)\nMorePoints(RealMadrid, Barcelona)\n-MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)"
        ],
        "conclusion": "Barcelona ranks higher than Real Madrid.",
        "conclusion-FOL": "RankHigherThan(Barcelona, RealMadrid)",
        "label": "ERROR"
    },
    {
        "premises": "Lawton Park is a neighborhood in Seattle. \nAll citizens of Lawton Park use the zip code 98199. \nTom is a citizen of Lawton Park.\nDaniel uses the zip code 98199. ",
        "premises-FOL": [
            "NeighbourhoodIn(LawtonPark, Seattle)\nall x. (Residentof(x, LawtonPark) -> UseZipCode(x, NumNineEightOneNineNine))\nResidentOf(Tom, LawtonPark)\nUseZipCode(Daniel, NumNineEightOneNineNine)"
        ],
        "conclusion": "Tom uses the zip code 98199.",
        "conclusion-FOL": "UseZipCode(Tom, NumNineEightOneNineNine)",
        "label": "ERROR"
    },
    {
        "premises": "Lawton Park is a neighborhood in Seattle. \nAll citizens of Lawton Park use the zip code 98199. \nTom is a citizen of Lawton Park.\nDaniel uses the zip code 98199. ",
        "premises-FOL": [
            "NeighbourhoodIn(LawtonPark, Seattle)\nall x. (Residentof(x, LawtonPark) -> UseZipCode(x, NumNineEightOneNineNine))\nResidentOf(Tom, LawtonPark)\nUseZipCode(Daniel, NumNineEightOneNineNine)"
        ],
        "conclusion": "Tom doesn't use the zip code 98199.",
        "conclusion-FOL": "-UseZipCode(Tom, NumNineEightOneNineNine)",
        "label": "ERROR"
    },
    {
        "premises": "Lawton Park is a neighborhood in Seattle. \nAll citizens of Lawton Park use the zip code 98199. \nTom is a citizen of Lawton Park.\nDaniel uses the zip code 98199. ",
        "premises-FOL": [
            "NeighbourhoodIn(LawtonPark, Seattle)\nall x. (Residentof(x, LawtonPark) -> UseZipCode(x, NumNineEightOneNineNine))\nResidentOf(Tom, LawtonPark)\nUseZipCode(Daniel, NumNineEightOneNineNine)"
        ],
        "conclusion": "Tom is a citizen of Washington.",
        "conclusion-FOL": "ResidentOf(Tom, Washington)",
        "label": "ERROR"
    },
    {
        "premises": "Lawton Park is a neighborhood in Seattle. \nAll citizens of Lawton Park use the zip code 98199. \nTom is a citizen of Lawton Park.\nDaniel uses the zip code 98199. ",
        "premises-FOL": [
            "NeighbourhoodIn(LawtonPark, Seattle)\nall x. (Residentof(x, LawtonPark) -> UseZipCode(x, NumNineEightOneNineNine))\nResidentOf(Tom, LawtonPark)\nUseZipCode(Daniel, NumNineEightOneNineNine)"
        ],
        "conclusion": "Daniel is a citizen of Lawton Park.",
        "conclusion-FOL": "ResidentOf(Daniel, LawtonPark)",
        "label": "ERROR"
    },
    {
        "premises": "If a legislator is found guilty of stealing government funds, they will be suspended from office.\nTiffany T. Alston was a legislator in Maryland's House of Delegates from 2011 to 2013.\nTiffany T. Alston was found guilty of stealing government funds in 2012.",
        "premises-FOL": [
            "all x. ((Legislator(x) & StealsFunds(x)) -> Suspended(x))\nLegislator(TiffanyTAlston)\nStealsFunds(TiffanyTAlston) & StealsFundsInYr(TiffanyTAlston, YrTwoZeroOneTwo)"
        ],
        "conclusion": "Tiffany T. Alston was suspended from the Maryland House of Delegates.",
        "conclusion-FOL": "Suspended(TiffanyTAlston)",
        "label": "ERROR"
    },
    {
        "premises": "If a legislator is found guilty of stealing government funds, they will be suspended from office.\nTiffany T. Alston was a legislator in Maryland's House of Delegates from 2011 to 2013.\nTiffany T. Alston was found guilty of stealing government funds in 2012.",
        "premises-FOL": [
            "all x. ((Legislator(x) & StealsFunds(x)) -> Suspended(x))\nLegislator(TiffanyTAlston)\nStealsFunds(TiffanyTAlston) & StealsFundsInYr(TiffanyTAlston, YrTwoZeroOneTwo)"
        ],
        "conclusion": "Tiffany T. Alston was not suspended from the Maryland House of Delegates.",
        "conclusion-FOL": "-Suspended(TiffanyTAlston)",
        "label": "ERROR"
    },
    {
        "premises": "If a legislator is found guilty of stealing government funds, they will be suspended from office.\nTiffany T. Alston was a legislator in Maryland's House of Delegates from 2011 to 2013.\nTiffany T. Alston was found guilty of stealing government funds in 2012.",
        "premises-FOL": [
            "all x. ((Legislator(x) & StealsFunds(x)) -> Suspended(x))\nLegislator(TiffanyTAlston)\nStealsFunds(TiffanyTAlston) & StealsFundsInYr(TiffanyTAlston, YrTwoZeroOneTwo)"
        ],
        "conclusion": "Tiffany T. Alston went to prison for stealing government funds.",
        "conclusion-FOL": "Prison(TiffanyTAlston)",
        "label": "ERROR"
    },
    {
        "premises": "Some fish stings people.\nStonefish is a fish.\nStonefish stings when stepped on. \nIf a stonefish stings someone and they are not treated, it can cause death to them.\nTo treat stonefish stings, apply heat to the affected area or use an antivenom.",
        "premises-FOL": [
            "exists x. exists y. (Fish(x) -> Sting(x,y))\nFish(Stonefish)\nall x. (SteppedOnBy(Stonefish, x) -> Sting(Stonefish, x))\nall x. (Sting(Stonefish, x) & -Treated(x) -> CauseDeathTo(Stonefish, x))\nall x. (Sting(Stonefish, x) & (ApplyHeatTo(x) | UseAntivenomOn(x)) -> Treated(x))"
        ],
        "conclusion": "If a stonefish stings you and you don\u2019t use an antivenom, it can cause death to you.",
        "conclusion-FOL": "all x. (Sting(Stonefish, x) & -UseAntivenomOn(x) -> CauseDeathTo(Stonefish, x))",
        "label": "ERROR"
    },
    {
        "premises": "Some fish stings people.\nStonefish is a fish.\nStonefish stings when stepped on. \nIf a stonefish stings someone and they are not treated, it can cause death to them.\nTo treat stonefish stings, apply heat to the affected area or use an antivenom.",
        "premises-FOL": [
            "exists x. exists y. (Fish(x) -> Sting(x,y))\nFish(Stonefish)\nall x. (SteppedOnBy(Stonefish, x) -> Sting(Stonefish, x))\nall x. (Sting(Stonefish, x) & -Treated(x) -> CauseDeathTo(Stonefish, x))\nall x. (Sting(Stonefish, x) & (ApplyHeatTo(x) | UseAntivenomOn(x)) -> Treated(x))"
        ],
        "conclusion": "Stings of some fish can cause death if not treated.",
        "conclusion-FOL": "exists x. exists y. (Fish(x) & Sting(x, y) & -Treated(y) -> CauseDeathTo(x, y))",
        "label": "ERROR"
    },
    {
        "premises": "Some fish stings people.\nStonefish is a fish.\nStonefish stings when stepped on. \nIf a stonefish stings someone and they are not treated, it can cause death to them.\nTo treat stonefish stings, apply heat to the affected area or use an antivenom.",
        "premises-FOL": [
            "exists x. exists y. (Fish(x) -> Sting(x,y))\nFish(Stonefish)\nall x. (SteppedOnBy(Stonefish, x) -> Sting(Stonefish, x))\nall x. (Sting(Stonefish, x) & -Treated(x) -> CauseDeathTo(Stonefish, x))\nall x. (Sting(Stonefish, x) & (ApplyHeatTo(x) | UseAntivenomOn(x)) -> Treated(x))"
        ],
        "conclusion": "If you step on a stonefish and apply heat to the affected area, it can cause death to you.",
        "conclusion-FOL": "all x. (SteppedOnBy(Stonefish, x) & ApplyHeatTo(x)  -> CauseDeathTo(Stonefish, x))",
        "label": "ERROR"
    },
    {
        "premises": "Some monitors made by LG have a type-c port.\nMonitors that have a type-c port were not made before 2010.\nAll monitors in the library are made before 2010. \nThe L-2021 monitor is either used in the library or has a type-c port.\nThe L-2021 monitor is either both produced before 2010 and made by LG, or neither is true.",
        "premises-FOL": [
            "exists x. (Monitor(x) & ProducedBy(x, lG) & Have(x, TypeCPort) & (-(x=y)) & Monitor(y) & ProducedBy(y, lG) & Have(y, TypeCPort))\nall x. (Have(x, TypeCPort) -> -ProducedBefore(x, YrTwoZeroOneZero))\nall x. ((Monitor(x) & In(x, Library)) -> ProducedBefore(x, YrTwoZeroOneZero))\nMonitor(l-TwoZeroTwoOne) & (((In(l-TwoZeroTwoOne, Library) & -Have(l-TwoZeroTwoOne, TypeCPort)) | (-In(l-TwoZeroTwoOne, Library) & Have(l-TwoZeroTwoOne, TypeCPort))))\n-(((ProducedBefore(l-TwoZeroTwoOne, YrTwoZeroOneZero) & -ProducedBy(l-TwoZeroTwoOne, lG)) | (-ProducedBefore(l-TwoZeroTwoOne, YrTwoZeroOneZero) & ProducedBy(l-TwoZeroTwoOne, lG))))"
        ],
        "conclusion": "The monitor L-2021 is in the library.",
        "conclusion-FOL": "In(l-TwoZeroTwoOne, Library)",
        "label": "ERROR"
    },
    {
        "premises": "Some monitors made by LG have a type-c port.\nMonitors that have a type-c port were not made before 2010.\nAll monitors in the library are made before 2010. \nThe L-2021 monitor is either used in the library or has a type-c port.\nThe L-2021 monitor is either both produced before 2010 and made by LG, or neither is true.",
        "premises-FOL": [
            "exists x. (Monitor(x) & ProducedBy(x, lG) & Have(x, TypeCPort) & (-(x=y)) & Monitor(y) & ProducedBy(y, lG) & Have(y, TypeCPort))\nall x. (Have(x, TypeCPort) -> -ProducedBefore(x, YrTwoZeroOneZero))\nall x. ((Monitor(x) & In(x, Library)) -> ProducedBefore(x, YrTwoZeroOneZero))\nMonitor(l-TwoZeroTwoOne) & (((In(l-TwoZeroTwoOne, Library) & -Have(l-TwoZeroTwoOne, TypeCPort)) | (-In(l-TwoZeroTwoOne, Library) & Have(l-TwoZeroTwoOne, TypeCPort))))\n-(((ProducedBefore(l-TwoZeroTwoOne, YrTwoZeroOneZero) & -ProducedBy(l-TwoZeroTwoOne, lG)) | (-ProducedBefore(l-TwoZeroTwoOne, YrTwoZeroOneZero) & ProducedBy(l-TwoZeroTwoOne, lG))))"
        ],
        "conclusion": "The monitor L-2021 is either in the library or produced by LG.",
        "conclusion-FOL": "((In(l-TwoZeroTwoOne, Library) & -ProducedBy(l-TwoZeroTwoOne, lG)) | (-In(l-TwoZeroTwoOne, Library) & ProducedBy(l-TwoZeroTwoOne, lG)))",
        "label": "ERROR"
    },
    {
        "premises": "Some monitors made by LG have a type-c port.\nMonitors that have a type-c port were not made before 2010.\nAll monitors in the library are made before 2010. \nThe L-2021 monitor is either used in the library or has a type-c port.\nThe L-2021 monitor is either both produced before 2010 and made by LG, or neither is true.",
        "premises-FOL": [
            "exists x. (Monitor(x) & ProducedBy(x, lG) & Have(x, TypeCPort) & (-(x=y)) & Monitor(y) & ProducedBy(y, lG) & Have(y, TypeCPort))\nall x. (Have(x, TypeCPort) -> -ProducedBefore(x, YrTwoZeroOneZero))\nall x. ((Monitor(x) & In(x, Library)) -> ProducedBefore(x, YrTwoZeroOneZero))\nMonitor(l-TwoZeroTwoOne) & (((In(l-TwoZeroTwoOne, Library) & -Have(l-TwoZeroTwoOne, TypeCPort)) | (-In(l-TwoZeroTwoOne, Library) & Have(l-TwoZeroTwoOne, TypeCPort))))\n-(((ProducedBefore(l-TwoZeroTwoOne, YrTwoZeroOneZero) & -ProducedBy(l-TwoZeroTwoOne, lG)) | (-ProducedBefore(l-TwoZeroTwoOne, YrTwoZeroOneZero) & ProducedBy(l-TwoZeroTwoOne, lG))))"
        ],
        "conclusion": "The L-2021 monitor either has a type-c port or is produced by LG.",
        "conclusion-FOL": "((Have(l-TwoZeroTwoOne, TypeCPort) & -ProducedBy(l-TwoZeroTwoOne, lG)) | (-Have(l-TwoZeroTwoOne, TypeCPort) & ProducedBy(l-TwoZeroTwoOne, lG)))",
        "label": "ERROR"
    },
    {
        "premises": "Some monitors made by LG have a type-c port.\nMonitors that have a type-c port were not made before 2010.\nAll monitors in the library are made before 2010. \nThe L-2021 monitor is either used in the library or has a type-c port.\nThe L-2021 monitor is either both produced before 2010 and made by LG, or neither is true.",
        "premises-FOL": [
            "exists x. (Monitor(x) & ProducedBy(x, lG) & Have(x, TypeCPort) & (-(x=y)) & Monitor(y) & ProducedBy(y, lG) & Have(y, TypeCPort))\nall x. (Have(x, TypeCPort) -> -ProducedBefore(x, YrTwoZeroOneZero))\nall x. ((Monitor(x) & In(x, Library)) -> ProducedBefore(x, YrTwoZeroOneZero))\nMonitor(l-TwoZeroTwoOne) & (((In(l-TwoZeroTwoOne, Library) & -Have(l-TwoZeroTwoOne, TypeCPort)) | (-In(l-TwoZeroTwoOne, Library) & Have(l-TwoZeroTwoOne, TypeCPort))))\n-(((ProducedBefore(l-TwoZeroTwoOne, YrTwoZeroOneZero) & -ProducedBy(l-TwoZeroTwoOne, lG)) | (-ProducedBefore(l-TwoZeroTwoOne, YrTwoZeroOneZero) & ProducedBy(l-TwoZeroTwoOne, lG))))"
        ],
        "conclusion": "If the L-2021 monitor is either in the library and produced by LG, or neither in the library nor produced by LG,  then L-2021 neither has a type-c port nor is produced by LG.",
        "conclusion-FOL": "-(((In(l-TwoZeroTwoOne, Library) & -ProducedBy(l-TwoZeroTwoOne, lG)) | (-In(l-TwoZeroTwoOne, Library) & ProducedBy(l-TwoZeroTwoOne, lG)))) -> (-Have(x, TypeCPort) & -ProducedBy(x, lG))",
        "label": "ERROR"
    },
    {
        "premises": "Some monitors made by LG have a type-c port.\nMonitors that have a type-c port were not made before 2010.\nAll monitors in the library are made before 2010. \nThe L-2021 monitor is either used in the library or has a type-c port.\nThe L-2021 monitor is either both produced before 2010 and made by LG, or neither is true.",
        "premises-FOL": [
            "exists x. (Monitor(x) & ProducedBy(x, lG) & Have(x, TypeCPort) & (-(x=y)) & Monitor(y) & ProducedBy(y, lG) & Have(y, TypeCPort))\nall x. (Have(x, TypeCPort) -> -ProducedBefore(x, YrTwoZeroOneZero))\nall x. ((Monitor(x) & In(x, Library)) -> ProducedBefore(x, YrTwoZeroOneZero))\nMonitor(l-TwoZeroTwoOne) & (((In(l-TwoZeroTwoOne, Library) & -Have(l-TwoZeroTwoOne, TypeCPort)) | (-In(l-TwoZeroTwoOne, Library) & Have(l-TwoZeroTwoOne, TypeCPort))))\n-(((ProducedBefore(l-TwoZeroTwoOne, YrTwoZeroOneZero) & -ProducedBy(l-TwoZeroTwoOne, lG)) | (-ProducedBefore(l-TwoZeroTwoOne, YrTwoZeroOneZero) & ProducedBy(l-TwoZeroTwoOne, lG))))"
        ],
        "conclusion": "If the monitor L-2021 is either produced by LG and produced before 2010 or neither produced by LG nor produced before 2010,  then L-2021 is either in the library or produced by LG.",
        "conclusion-FOL": "-(((ProducedBefore(l-TwoZeroTwoOne, YearTwoZeroOneZero) & -ProducedBy(l-TwoZeroTwoOne, lG)) | (-ProducedBefore(l-TwoZeroTwoOne, YearTwoZeroOneZero) & ProducedBy(l-TwoZeroTwoOne, lG)))) -> (((In(l-TwoZeroTwoOne, Library) & -ProducedBy(l-TwoZeroTwoOne, lG)) | (-In(l-TwoZeroTwoOne, Library) & ProducedBy(l-TwoZeroTwoOne, lG))))",
        "label": "ERROR"
    },
    {
        "premises": "Everything is either outside the solar system or in the solar system. \nNothing outside the solar system has the Sun as its star.\nEverything in the solar system is gravitationally bound by the Sun.\nNo planets gravitationally bound by the Sun are rogue planets. \nAll orphan planets are rogue planets.\nIf PSO J318.5\u221222 is not both a rogue planet and a planet gravitationally bound by the Sun, then it is a rogue planet.",
        "premises-FOL": [
            "all x. (((Outside(x, SolarSystem) & -In(x, SolarSystem)) | (-Outside(x, SolarSystem) & In(x, SolarSystem))))\nall x. (Outside(x, SolarSystem) -> -SunAs(x, Star))\nall x. (In(x, SolarSystem) -> BoundBy(x, Sun, Gravitationally))\nall x. (Planet(x) & BoundBy(x, Sun, Gravitationally) -> -(Planet(x) & Rogue(x)))\nall x. (Planet(x) & Orphan(x) -> Planet(x) & Rogue(x))\n-(Planet(pSOJThreeOneEightDotFive-TwoTwo) & Rogue(pSOJThreeOneEightDotFive-TwoTwo) & BoundBy(pSOJThreeOneEightDotFive-TwoTwo, Sun, Gravitationally)) -> (Planet(pSOJThreeOneEightDotFive-TwoTwo) & Rogue(pSOJThreeOneEightDotFive-TwoTwo))"
        ],
        "conclusion": "PSO J318.5\u221222 is an orphan planet.",
        "conclusion-FOL": "Planet(pSOJThreeOneEightDotFive-TwoTwo) & Orphan(pSOJThreeOneEightDotFive-TwoTwo)",
        "label": "ERROR"
    },
    {
        "premises": "Everything is either outside the solar system or in the solar system. \nNothing outside the solar system has the Sun as its star.\nEverything in the solar system is gravitationally bound by the Sun.\nNo planets gravitationally bound by the Sun are rogue planets. \nAll orphan planets are rogue planets.\nIf PSO J318.5\u221222 is not both a rogue planet and a planet gravitationally bound by the Sun, then it is a rogue planet.",
        "premises-FOL": [
            "all x. (((Outside(x, SolarSystem) & -In(x, SolarSystem)) | (-Outside(x, SolarSystem) & In(x, SolarSystem))))\nall x. (Outside(x, SolarSystem) -> -SunAs(x, Star))\nall x. (In(x, SolarSystem) -> BoundBy(x, Sun, Gravitationally))\nall x. (Planet(x) & BoundBy(x, Sun, Gravitationally) -> -(Planet(x) & Rogue(x)))\nall x. (Planet(x) & Orphan(x) -> Planet(x) & Rogue(x))\n-(Planet(pSOJThreeOneEightDotFive-TwoTwo) & Rogue(pSOJThreeOneEightDotFive-TwoTwo) & BoundBy(pSOJThreeOneEightDotFive-TwoTwo, Sun, Gravitationally)) -> (Planet(pSOJThreeOneEightDotFive-TwoTwo) & Rogue(pSOJThreeOneEightDotFive-TwoTwo))"
        ],
        "conclusion": "PSO J318.5\u221222 is an orphan planet or it does not have the Sun as its star, or both.",
        "conclusion-FOL": "(Planet(pSOJThreeOneEightDotFive-TwoTwo) & Orphan(pSOJThreeOneEightDotFive-TwoTwo)) | -SunAs(pSOJThreeOneEightDotFive-TwoTwo, Star)",
        "label": "ERROR"
    },
    {
        "premises": "Everything is either outside the solar system or in the solar system. \nNothing outside the solar system has the Sun as its star.\nEverything in the solar system is gravitationally bound by the Sun.\nNo planets gravitationally bound by the Sun are rogue planets. \nAll orphan planets are rogue planets.\nIf PSO J318.5\u221222 is not both a rogue planet and a planet gravitationally bound by the Sun, then it is a rogue planet.",
        "premises-FOL": [
            "all x. (((Outside(x, SolarSystem) & -In(x, SolarSystem)) | (-Outside(x, SolarSystem) & In(x, SolarSystem))))\nall x. (Outside(x, SolarSystem) -> -SunAs(x, Star))\nall x. (In(x, SolarSystem) -> BoundBy(x, Sun, Gravitationally))\nall x. (Planet(x) & BoundBy(x, Sun, Gravitationally) -> -(Planet(x) & Rogue(x)))\nall x. (Planet(x) & Orphan(x) -> Planet(x) & Rogue(x))\n-(Planet(pSOJThreeOneEightDotFive-TwoTwo) & Rogue(pSOJThreeOneEightDotFive-TwoTwo) & BoundBy(pSOJThreeOneEightDotFive-TwoTwo, Sun, Gravitationally)) -> (Planet(pSOJThreeOneEightDotFive-TwoTwo) & Rogue(pSOJThreeOneEightDotFive-TwoTwo))"
        ],
        "conclusion": "If PSO J318.5\u221222 is an orphan planet or it does not have the Sun as the star, or both, then PSO J318.5\u221222 neither is an orphan planet nor does it have the Sun as the star.",
        "conclusion-FOL": "(Planet(pSOJThreeOneEightDotFive-TwoTwo) & Orphan(pSOJThreeOneEightDotFive-TwoTwo)) | -SunAs(pSOJThreeOneEightDotFive-TwoTwo, Star) -> (-(Planet(pSOJThreeOneEightDotFive-TwoTwo) & Orphan(pSOJThreeOneEightDotFive-TwoTwo)) & -SunAs(pSOJThreeOneEightDotFive-TwoTwo, Star))",
        "label": "ERROR"
    },
    {
        "premises": "Sam is doing a project.\nA project is written either in C++ or Python.\nIf Sam does a project written in Python, he will not use a Mac.\nSam is using a Mac.\nIf Sam uses a Mac, he will play a song.\nIf a song is not titled \"Perfect,\" Sam will never play it.",
        "premises-FOL": [
            "exists x. (Project(x) & Do(Sam, x))\nall x. (Project(x) -> (((WrittenIn(x, Cplusplus) & -WrittenIn(x, Python)) | (-WrittenIn(x, Cplusplus) & WrittenIn(x, Python)))))\nall x. (Project(x) & WrittenIn(x, Python) & Do(Sam, x) -> -Use(Sam, Mac))\nUse(Sam, Mac)\nexists x. (Use(Sam, Mac) & Song(x) -> Play(Sam, x))\nall x. (Song(x) & Play(Sam, x) -> Titled(x, Perfect))"
        ],
        "conclusion": "The project Sam is doing is written in C++.",
        "conclusion-FOL": "all x. (Project(x) & Do(Sam, x) & WrittenIn(x, Cplusplus))",
        "label": "ERROR"
    },
    {
        "premises": "Sam is doing a project.\nA project is written either in C++ or Python.\nIf Sam does a project written in Python, he will not use a Mac.\nSam is using a Mac.\nIf Sam uses a Mac, he will play a song.\nIf a song is not titled \"Perfect,\" Sam will never play it.",
        "premises-FOL": [
            "exists x. (Project(x) & Do(Sam, x))\nall x. (Project(x) -> (((WrittenIn(x, Cplusplus) & -WrittenIn(x, Python)) | (-WrittenIn(x, Cplusplus) & WrittenIn(x, Python)))))\nall x. (Project(x) & WrittenIn(x, Python) & Do(Sam, x) -> -Use(Sam, Mac))\nUse(Sam, Mac)\nexists x. (Use(Sam, Mac) & Song(x) -> Play(Sam, x))\nall x. (Song(x) & Play(Sam, x) -> Titled(x, Perfect))"
        ],
        "conclusion": "The song Sam is playing is titled \"Perfect\".",
        "conclusion-FOL": "all x. (Song(x) & Play(Sam, x) & Titled(x, Perfect))",
        "label": "ERROR"
    },
    {
        "premises": "Sam is doing a project.\nA project is written either in C++ or Python.\nIf Sam does a project written in Python, he will not use a Mac.\nSam is using a Mac.\nIf Sam uses a Mac, he will play a song.\nIf a song is not titled \"Perfect,\" Sam will never play it.",
        "premises-FOL": [
            "exists x. (Project(x) & Do(Sam, x))\nall x. (Project(x) -> (((WrittenIn(x, Cplusplus) & -WrittenIn(x, Python)) | (-WrittenIn(x, Cplusplus) & WrittenIn(x, Python)))))\nall x. (Project(x) & WrittenIn(x, Python) & Do(Sam, x) -> -Use(Sam, Mac))\nUse(Sam, Mac)\nexists x. (Use(Sam, Mac) & Song(x) -> Play(Sam, x))\nall x. (Song(x) & Play(Sam, x) -> Titled(x, Perfect))"
        ],
        "conclusion": "If a song is titled \"Perfect\", Sam will play it.",
        "conclusion-FOL": "all x. (Titled(x, Perfect) -> Play(Sam, x))",
        "label": "ERROR"
    },
    {
        "premises": "All rabbits have fur\nSome pets are rabbits.",
        "premises-FOL": [
            "all x. (Rabbit(x) -> Have(x, Fur))\nexists x. (Pet(x) & Rabbit(x))"
        ],
        "conclusion": "Some pets do not have fur.",
        "conclusion-FOL": "exists x. exists y. (Pet(x) & Pet(y) & -Have(x, Fur) & -Have(y, Fur))",
        "label": "ERROR"
    },
    {
        "premises": "All social media applications containing chat features are software. \nAll social media applications that allow users to send messages to each other have chat features. \nAll social media applications have chat features or video features. \nAll social media applications that have video features allow users to upload videos. \nAll software that is social media applications are computer programs. \nAll social media applications that have high engagement metrics are addictive. \nIf a social media application is addictive, then it is not ideal for preteens. \nTikTok is a social media application, and it is not ideal for preteens. ",
        "premises-FOL": [
            "all x. (SocialMedia(x) & Application(x) & Contain(x, ChatFeature) -> Software(x))\nall x. (SocialMedia(x) & Application(x) & AllowToSendTo(x, User, Message) -> Contain(x, ChatFeature))\nall x. (SocialMedia(x) & Application(x) -> Contain(x, ChatFeature) | Contain(x, VideoFeature))\nall x. (SocialMedia(x) & Application(x) & Contain(x, VideoFeature) -> Allow(x, User, UploadVideo))\nall x. (SocialMedia(x) & Application(x) & Software(x) -> ComputerProgram(x))\nall x. (SocialMedia(x) & Application(x) &Have(x, HighEngagementMetric) -> Addictive(x))\nall x. (SocialMedia(x) & Application(x) & Addictive(x) -> -IdealFor(x, Preteen))\nSocialMedia(TikTok) & Application(TikTok) & -IdealFor(TikTok, Preteen)"
        ],
        "conclusion": "TikTok is a computer program.",
        "conclusion-FOL": "ComputerProgram(TikTok)",
        "label": "ERROR"
    },
    {
        "premises": "All social media applications containing chat features are software. \nAll social media applications that allow users to send messages to each other have chat features. \nAll social media applications have chat features or video features. \nAll social media applications that have video features allow users to upload videos. \nAll software that is social media applications are computer programs. \nAll social media applications that have high engagement metrics are addictive. \nIf a social media application is addictive, then it is not ideal for preteens. \nTikTok is a social media application, and it is not ideal for preteens. ",
        "premises-FOL": [
            "all x. (SocialMedia(x) & Application(x) & Contain(x, ChatFeature) -> Software(x))\nall x. (SocialMedia(x) & Application(x) & AllowToSendTo(x, User, Message) -> Contain(x, ChatFeature))\nall x. (SocialMedia(x) & Application(x) -> Contain(x, ChatFeature) | Contain(x, VideoFeature))\nall x. (SocialMedia(x) & Application(x) & Contain(x, VideoFeature) -> Allow(x, User, UploadVideo))\nall x. (SocialMedia(x) & Application(x) & Software(x) -> ComputerProgram(x))\nall x. (SocialMedia(x) & Application(x) &Have(x, HighEngagementMetric) -> Addictive(x))\nall x. (SocialMedia(x) & Application(x) & Addictive(x) -> -IdealFor(x, Preteen))\nSocialMedia(TikTok) & Application(TikTok) & -IdealFor(TikTok, Preteen)"
        ],
        "conclusion": "TikTok is either ideal for preteens or a computer program.",
        "conclusion-FOL": "((IdealFor(TikTok, Preteen) & -ComputerProgram(TikTok)) | (-IdealFor(TikTok, Preteen) & ComputerProgram(TikTok)))",
        "label": "ERROR"
    },
    {
        "premises": "All social media applications containing chat features are software. \nAll social media applications that allow users to send messages to each other have chat features. \nAll social media applications have chat features or video features. \nAll social media applications that have video features allow users to upload videos. \nAll software that is social media applications are computer programs. \nAll social media applications that have high engagement metrics are addictive. \nIf a social media application is addictive, then it is not ideal for preteens. \nTikTok is a social media application, and it is not ideal for preteens. ",
        "premises-FOL": [
            "all x. (SocialMedia(x) & Application(x) & Contain(x, ChatFeature) -> Software(x))\nall x. (SocialMedia(x) & Application(x) & AllowToSendTo(x, User, Message) -> Contain(x, ChatFeature))\nall x. (SocialMedia(x) & Application(x) -> Contain(x, ChatFeature) | Contain(x, VideoFeature))\nall x. (SocialMedia(x) & Application(x) & Contain(x, VideoFeature) -> Allow(x, User, UploadVideo))\nall x. (SocialMedia(x) & Application(x) & Software(x) -> ComputerProgram(x))\nall x. (SocialMedia(x) & Application(x) &Have(x, HighEngagementMetric) -> Addictive(x))\nall x. (SocialMedia(x) & Application(x) & Addictive(x) -> -IdealFor(x, Preteen))\nSocialMedia(TikTok) & Application(TikTok) & -IdealFor(TikTok, Preteen)"
        ],
        "conclusion": "TikTok is does not have chat features or it is not a computer program.",
        "conclusion-FOL": "-Contain(TikTok, ChatFeature) | -ComputerProgram(TikTok))",
        "label": "ERROR"
    },
    {
        "premises": "All social media applications containing chat features are software. \nAll social media applications that allow users to send messages to each other have chat features. \nAll social media applications have chat features or video features. \nAll social media applications that have video features allow users to upload videos. \nAll software that is social media applications are computer programs. \nAll social media applications that have high engagement metrics are addictive. \nIf a social media application is addictive, then it is not ideal for preteens. \nTikTok is a social media application, and it is not ideal for preteens. ",
        "premises-FOL": [
            "all x. (SocialMedia(x) & Application(x) & Contain(x, ChatFeature) -> Software(x))\nall x. (SocialMedia(x) & Application(x) & AllowToSendTo(x, User, Message) -> Contain(x, ChatFeature))\nall x. (SocialMedia(x) & Application(x) -> Contain(x, ChatFeature) | Contain(x, VideoFeature))\nall x. (SocialMedia(x) & Application(x) & Contain(x, VideoFeature) -> Allow(x, User, UploadVideo))\nall x. (SocialMedia(x) & Application(x) & Software(x) -> ComputerProgram(x))\nall x. (SocialMedia(x) & Application(x) &Have(x, HighEngagementMetric) -> Addictive(x))\nall x. (SocialMedia(x) & Application(x) & Addictive(x) -> -IdealFor(x, Preteen))\nSocialMedia(TikTok) & Application(TikTok) & -IdealFor(TikTok, Preteen)"
        ],
        "conclusion": "TikTok either has chat features or is a computer program.",
        "conclusion-FOL": "((Contain(TikTok, ChatFeature) & -ComputerProgram(TikTok)) | (-Contain(TikTok, ChatFeature) & ComputerProgram(TikTok))))",
        "label": "ERROR"
    },
    {
        "premises": "Ordinary is an unincorporated community.\nLocated within Elliot County, Ordinary is on Kentucky Route 32.\nOrdinary is located northwest of Sandy Hook.",
        "premises-FOL": [
            "UnincorporatedCommunity(Ordinary)\nLocatedIn(Ordinary, ElliotCounty) & On(Ordinary, KentuckyRouteThreeTwo)\nLocatedNorthwestOf(Ordinary, SandyHook)"
        ],
        "conclusion": "There are no unincorporated communities along Kentucky Route 32.",
        "conclusion-FOL": "all x. (On(x, KentuckyRouteThreeTwo) -> -UnincorporatedCommunity(x))",
        "label": "ERROR"
    },
    {
        "premises": "Ordinary is an unincorporated community.\nLocated within Elliot County, Ordinary is on Kentucky Route 32.\nOrdinary is located northwest of Sandy Hook.",
        "premises-FOL": [
            "UnincorporatedCommunity(Ordinary)\nLocatedIn(Ordinary, ElliotCounty) & On(Ordinary, KentuckyRouteThreeTwo)\nLocatedNorthwestOf(Ordinary, SandyHook)"
        ],
        "conclusion": "There is an unincorporated community located in Elliot County.",
        "conclusion-FOL": "exists x. (UnincorporatedCommunity(x) & LocatedIn(x, ElliotCounty))",
        "label": "ERROR"
    },
    {
        "premises": "All young adults at the event like independence.\nAll college students at the event are young adults.\nAll Yale students at the event are college students.\nEveryone at the event is a Yale student or a Harvard student.\nAll Harvard students at the event are diligent.\nSusan is at the event, and if Susan is a Harvard student, then she is a young adult.\nIf Susan is a Yale student, then she does not like independence.",
        "premises-FOL": [
            "all x. (At(x, Event) & YoungAdult(x) -> Like(x, Independence))\nall x. (At(x, Event) & CollegeStudent(x) -> YoungAdult(x))\nall x. (At(x, Event) & YaleStudent(x) -> CollegeStudent(x))\nall x. (At(x, Event) -> (((YaleStudent(x) & -HarvardStudent(x)) | (-YaleStudent(x) & HarvardStudent(x)))))\nall x. (At(x, Event) & HarvardStudent(x) -> Diligent(x))\nAt(Susan, Event) & (HarvardStudent(Susan) -> YoungAdult(Susan))\nYaleStudent(Susan) -> -Like(Susan, Independence)"
        ],
        "conclusion": "Susan is a college student.",
        "conclusion-FOL": "CollegeStudent(Susan)",
        "label": "ERROR"
    },
    {
        "premises": "All young adults at the event like independence.\nAll college students at the event are young adults.\nAll Yale students at the event are college students.\nEveryone at the event is a Yale student or a Harvard student.\nAll Harvard students at the event are diligent.\nSusan is at the event, and if Susan is a Harvard student, then she is a young adult.\nIf Susan is a Yale student, then she does not like independence.",
        "premises-FOL": [
            "all x. (At(x, Event) & YoungAdult(x) -> Like(x, Independence))\nall x. (At(x, Event) & CollegeStudent(x) -> YoungAdult(x))\nall x. (At(x, Event) & YaleStudent(x) -> CollegeStudent(x))\nall x. (At(x, Event) -> (((YaleStudent(x) & -HarvardStudent(x)) | (-YaleStudent(x) & HarvardStudent(x)))))\nall x. (At(x, Event) & HarvardStudent(x) -> Diligent(x))\nAt(Susan, Event) & (HarvardStudent(Susan) -> YoungAdult(Susan))\nYaleStudent(Susan) -> -Like(Susan, Independence)"
        ],
        "conclusion": "Susan likes independence and is diligent.",
        "conclusion-FOL": "Like(Susan, Independence) & Diligent(Susan)",
        "label": "ERROR"
    },
    {
        "premises": "All young adults at the event like independence.\nAll college students at the event are young adults.\nAll Yale students at the event are college students.\nEveryone at the event is a Yale student or a Harvard student.\nAll Harvard students at the event are diligent.\nSusan is at the event, and if Susan is a Harvard student, then she is a young adult.\nIf Susan is a Yale student, then she does not like independence.",
        "premises-FOL": [
            "all x. (At(x, Event) & YoungAdult(x) -> Like(x, Independence))\nall x. (At(x, Event) & CollegeStudent(x) -> YoungAdult(x))\nall x. (At(x, Event) & YaleStudent(x) -> CollegeStudent(x))\nall x. (At(x, Event) -> (((YaleStudent(x) & -HarvardStudent(x)) | (-YaleStudent(x) & HarvardStudent(x)))))\nall x. (At(x, Event) & HarvardStudent(x) -> Diligent(x))\nAt(Susan, Event) & (HarvardStudent(Susan) -> YoungAdult(Susan))\nYaleStudent(Susan) -> -Like(Susan, Independence)"
        ],
        "conclusion": "Susan is not both diligent and likes independence.",
        "conclusion-FOL": "-(Like(Susan, Independence) & Diligent(Susan))",
        "label": "ERROR"
    },
    {
        "premises": "Vic DiCara plays guitar and bass.\nThe only style of music Vic DiCara plays is punk music.\nVic DiCara played in the band Inside Out.",
        "premises-FOL": [
            "Play(VicDicara, Guitar) & Play(VicDicara, Bass)\nall x. (Music(VicDicara, x) -> -(x=Punk)))\nBand(VicDicara, InsideOut)"
        ],
        "conclusion": "Inside Out was a punk band.",
        "conclusion-FOL": "Music(InsideOut, Punk)",
        "label": "ERROR"
    },
    {
        "premises": "Vic DiCara plays guitar and bass.\nThe only style of music Vic DiCara plays is punk music.\nVic DiCara played in the band Inside Out.",
        "premises-FOL": [
            "Play(VicDicara, Guitar) & Play(VicDicara, Bass)\nall x. (Music(VicDicara, x) -> -(x=Punk)))\nBand(VicDicara, InsideOut)"
        ],
        "conclusion": "A musician from Inside Out plays bass.",
        "conclusion-FOL": "exists x. (Band(x, InsideOut) & Play(x, Bass))",
        "label": "ERROR"
    },
    {
        "premises": "All professional athletes spend most of their time on sports.\nAll Olympic gold medal winners are professional athletes.\nNo full-time scientists spend the majority of their time on sports.\nAll Nobel physics laureates are full-time scientists.\nAmy spends the most time on sports, or Amy is an Olympic gold medal winner.\nIf Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.",
        "premises-FOL": [
            "all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))\nall x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))\nall x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))\nall x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))\nSpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)\n-NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)"
        ],
        "conclusion": "Amy is a professional athlete.",
        "conclusion-FOL": "ProfessionalAthlete(Amy)",
        "label": "ERROR"
    },
    {
        "premises": "All professional athletes spend most of their time on sports.\nAll Olympic gold medal winners are professional athletes.\nNo full-time scientists spend the majority of their time on sports.\nAll Nobel physics laureates are full-time scientists.\nAmy spends the most time on sports, or Amy is an Olympic gold medal winner.\nIf Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.",
        "premises-FOL": [
            "all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))\nall x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))\nall x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))\nall x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))\nSpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)\n-NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)"
        ],
        "conclusion": "Amy is neither a full-time scientist nor an Olympic gold medal winner.",
        "conclusion-FOL": "-(FullTimeScientist(Amy) | OlympicGoldMedalWinner(Amy))",
        "label": "ERROR"
    },
    {
        "premises": "All professional athletes spend most of their time on sports.\nAll Olympic gold medal winners are professional athletes.\nNo full-time scientists spend the majority of their time on sports.\nAll Nobel physics laureates are full-time scientists.\nAmy spends the most time on sports, or Amy is an Olympic gold medal winner.\nIf Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.",
        "premises-FOL": [
            "all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))\nall x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))\nall x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))\nall x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))\nSpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)\n-NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)"
        ],
        "conclusion": "If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.",
        "conclusion-FOL": "-OlympicGoldMedalWinner(Amy) -> NobelPhysicsLaureate(Amy)",
        "label": "ERROR"
    },
    {
        "premises": "All red fruits that grow in Ben's yard contain some Vitamin C.\nAll apples that grow in Ben's yard are red fruits.\nAll fruits that grow in Ben's yard and contain some Vitamin C are healthy. \nNo fruits that grow in Ben's yard and are healthy are on a warning list.\nThe cherries grow in Ben's yard.\nIf cherries are not apples and are not healthy, then they are red fruits.",
        "premises-FOL": [
            "all x. ((GrownIn(x, BenSYard) & RedFruit(x)) -> Contain(x, VitaminC))\nall x. (GrownIn(x, BenSYard) & Is(x, Apple) -> RedFruit(x))\nall x. ((GrownIn(x, BenSYard) & Contain(x, VitaminC)) -> Healthy(x))\nall x. ((GrownIn(x, BenSYard) & Healthy(x)) -> -On(x, WarningList))\nGrownIn(Cherry, BenSYard)\n-(Healthy(Cherry) & Is(Cherry, Apple)) -> RedFruit(Cherry)\n"
        ],
        "conclusion": "The cherries are apples.",
        "conclusion-FOL": "Is(Cherry, Apple)",
        "label": "ERROR"
    },
    {
        "premises": "All red fruits that grow in Ben's yard contain some Vitamin C.\nAll apples that grow in Ben's yard are red fruits.\nAll fruits that grow in Ben's yard and contain some Vitamin C are healthy. \nNo fruits that grow in Ben's yard and are healthy are on a warning list.\nThe cherries grow in Ben's yard.\nIf cherries are not apples and are not healthy, then they are red fruits.",
        "premises-FOL": [
            "all x. ((GrownIn(x, BenSYard) & RedFruit(x)) -> Contain(x, VitaminC))\nall x. (GrownIn(x, BenSYard) & Is(x, Apple) -> RedFruit(x))\nall x. ((GrownIn(x, BenSYard) & Contain(x, VitaminC)) -> Healthy(x))\nall x. ((GrownIn(x, BenSYard) & Healthy(x)) -> -On(x, WarningList))\nGrownIn(Cherry, BenSYard)\n-(Healthy(Cherry) & Is(Cherry, Apple)) -> RedFruit(Cherry)\n"
        ],
        "conclusion": "The cherries either contain some amount of vitamin C or are on a warning list.",
        "conclusion-FOL": "((Contain(Cherry, VitaminC) & -On(Cherry, WarningList)) | (-Contain(Cherry, VitaminC) & On(Cherry, WarningList)))",
        "label": "ERROR"
    },
    {
        "premises": "All red fruits that grow in Ben's yard contain some Vitamin C.\nAll apples that grow in Ben's yard are red fruits.\nAll fruits that grow in Ben's yard and contain some Vitamin C are healthy. \nNo fruits that grow in Ben's yard and are healthy are on a warning list.\nThe cherries grow in Ben's yard.\nIf cherries are not apples and are not healthy, then they are red fruits.",
        "premises-FOL": [
            "all x. ((GrownIn(x, BenSYard) & RedFruit(x)) -> Contain(x, VitaminC))\nall x. (GrownIn(x, BenSYard) & Is(x, Apple) -> RedFruit(x))\nall x. ((GrownIn(x, BenSYard) & Contain(x, VitaminC)) -> Healthy(x))\nall x. ((GrownIn(x, BenSYard) & Healthy(x)) -> -On(x, WarningList))\nGrownIn(Cherry, BenSYard)\n-(Healthy(Cherry) & Is(Cherry, Apple)) -> RedFruit(Cherry)\n"
        ],
        "conclusion": "The cherries are either on a warning list or are red.",
        "conclusion-FOL": "((On(Cherry, WarningList) & -RedFruit(Cherry)) | (-On(Cherry, WarningList) & RedFruit(Cherry)))",
        "label": "ERROR"
    },
    {
        "premises": "All red fruits that grow in Ben's yard contain some Vitamin C.\nAll apples that grow in Ben's yard are red fruits.\nAll fruits that grow in Ben's yard and contain some Vitamin C are healthy. \nNo fruits that grow in Ben's yard and are healthy are on a warning list.\nThe cherries grow in Ben's yard.\nIf cherries are not apples and are not healthy, then they are red fruits.",
        "premises-FOL": [
            "all x. ((GrownIn(x, BenSYard) & RedFruit(x)) -> Contain(x, VitaminC))\nall x. (GrownIn(x, BenSYard) & Is(x, Apple) -> RedFruit(x))\nall x. ((GrownIn(x, BenSYard) & Contain(x, VitaminC)) -> Healthy(x))\nall x. ((GrownIn(x, BenSYard) & Healthy(x)) -> -On(x, WarningList))\nGrownIn(Cherry, BenSYard)\n-(Healthy(Cherry) & Is(Cherry, Apple)) -> RedFruit(Cherry)\n"
        ],
        "conclusion": "If the cherries are either healthy or are on a warning list, then they are not red.",
        "conclusion-FOL": "((BeneficialTo(Cherry, People) & -On(Cherry, WarningList)) | (-BeneficialTo(Cherry, People) & On(Cherry, WarningList))))) -> -RedFruit(Cherry)",
        "label": "ERROR"
    },
    {
        "premises": "All red fruits that grow in Ben's yard contain some Vitamin C.\nAll apples that grow in Ben's yard are red fruits.\nAll fruits that grow in Ben's yard and contain some Vitamin C are healthy. \nNo fruits that grow in Ben's yard and are healthy are on a warning list.\nThe cherries grow in Ben's yard.\nIf cherries are not apples and are not healthy, then they are red fruits.",
        "premises-FOL": [
            "all x. ((GrownIn(x, BenSYard) & RedFruit(x)) -> Contain(x, VitaminC))\nall x. (GrownIn(x, BenSYard) & Is(x, Apple) -> RedFruit(x))\nall x. ((GrownIn(x, BenSYard) & Contain(x, VitaminC)) -> Healthy(x))\nall x. ((GrownIn(x, BenSYard) & Healthy(x)) -> -On(x, WarningList))\nGrownIn(Cherry, BenSYard)\n-(Healthy(Cherry) & Is(Cherry, Apple)) -> RedFruit(Cherry)\n"
        ],
        "conclusion": "If the cherries are either on a warning list or are red, then they are not healthy and do not contain any amount of vitamin C.",
        "conclusion-FOL": "((On(Cherry, WarningList) & -RedFruit(Cherry)) | (-On(Cherry, WarningList) & RedFruit(Cherry)))) -> -(BeneficialTo(Cherry, People) & Contain(Cherry, VitaminC)",
        "label": "ERROR"
    },
    {
        "premises": "Everyone working at Meta has a high income. \nA person with a high income will not take a bus to their destination.\nPeople will either take a bus or drive to their destination. \nEveryone who has a car will choose to drive to their destination. \nNo students drive to their destination. \nJames has a car or works at Meta.",
        "premises-FOL": [
            "all x. (WorkAt(x, Meta) -> HighIncome(x))\nall x. (HighIncome(x) -> -MeansToDestination(x, Bus))\nall x. (((MeansToDestination(x, Bus) & -MeansToDestination(x, Drive)) | (-MeansToDestination(x, Bus) & MeansToDestination(x, Drive))))\nall x. (HaveCar(x) -> MeansToDestination(x, Drive))\nall x. (Student(x) -> - MeansToDestination(x, Drive))\nHaveCar(James) | WorkAt(James, Meta)"
        ],
        "conclusion": "James has a high income.",
        "conclusion-FOL": "HighIncome(James)",
        "label": "ERROR"
    },
    {
        "premises": "Everyone working at Meta has a high income. \nA person with a high income will not take a bus to their destination.\nPeople will either take a bus or drive to their destination. \nEveryone who has a car will choose to drive to their destination. \nNo students drive to their destination. \nJames has a car or works at Meta.",
        "premises-FOL": [
            "all x. (WorkAt(x, Meta) -> HighIncome(x))\nall x. (HighIncome(x) -> -MeansToDestination(x, Bus))\nall x. (((MeansToDestination(x, Bus) & -MeansToDestination(x, Drive)) | (-MeansToDestination(x, Bus) & MeansToDestination(x, Drive))))\nall x. (HaveCar(x) -> MeansToDestination(x, Drive))\nall x. (Student(x) -> - MeansToDestination(x, Drive))\nHaveCar(James) | WorkAt(James, Meta)"
        ],
        "conclusion": "James does not have a high income.",
        "conclusion-FOL": "-HighIncome(James)",
        "label": "ERROR"
    },
    {
        "premises": "Everyone working at Meta has a high income. \nA person with a high income will not take a bus to their destination.\nPeople will either take a bus or drive to their destination. \nEveryone who has a car will choose to drive to their destination. \nNo students drive to their destination. \nJames has a car or works at Meta.",
        "premises-FOL": [
            "all x. (WorkAt(x, Meta) -> HighIncome(x))\nall x. (HighIncome(x) -> -MeansToDestination(x, Bus))\nall x. (((MeansToDestination(x, Bus) & -MeansToDestination(x, Drive)) | (-MeansToDestination(x, Bus) & MeansToDestination(x, Drive))))\nall x. (HaveCar(x) -> MeansToDestination(x, Drive))\nall x. (Student(x) -> - MeansToDestination(x, Drive))\nHaveCar(James) | WorkAt(James, Meta)"
        ],
        "conclusion": "James is a student.",
        "conclusion-FOL": "Student(James)",
        "label": "ERROR"
    },
    {
        "premises": "Everyone working at Meta has a high income. \nA person with a high income will not take a bus to their destination.\nPeople will either take a bus or drive to their destination. \nEveryone who has a car will choose to drive to their destination. \nNo students drive to their destination. \nJames has a car or works at Meta.",
        "premises-FOL": [
            "all x. (WorkAt(x, Meta) -> HighIncome(x))\nall x. (HighIncome(x) -> -MeansToDestination(x, Bus))\nall x. (((MeansToDestination(x, Bus) & -MeansToDestination(x, Drive)) | (-MeansToDestination(x, Bus) & MeansToDestination(x, Drive))))\nall x. (HaveCar(x) -> MeansToDestination(x, Drive))\nall x. (Student(x) -> - MeansToDestination(x, Drive))\nHaveCar(James) | WorkAt(James, Meta)"
        ],
        "conclusion": "James drives to his destination or he is a student.",
        "conclusion-FOL": "MeansToDestination(x, Drive) | Student(James)",
        "label": "ERROR"
    },
    {
        "premises": "Everyone working at Meta has a high income. \nA person with a high income will not take a bus to their destination.\nPeople will either take a bus or drive to their destination. \nEveryone who has a car will choose to drive to their destination. \nNo students drive to their destination. \nJames has a car or works at Meta.",
        "premises-FOL": [
            "all x. (WorkAt(x, Meta) -> HighIncome(x))\nall x. (HighIncome(x) -> -MeansToDestination(x, Bus))\nall x. (((MeansToDestination(x, Bus) & -MeansToDestination(x, Drive)) | (-MeansToDestination(x, Bus) & MeansToDestination(x, Drive))))\nall x. (HaveCar(x) -> MeansToDestination(x, Drive))\nall x. (Student(x) -> - MeansToDestination(x, Drive))\nHaveCar(James) | WorkAt(James, Meta)"
        ],
        "conclusion": "James either drives to their destination or is a student.",
        "conclusion-FOL": "((MeansToDestination(x, Drive) & -Student(James)) | (-MeansToDestination(x, Drive) & Student(James)))",
        "label": "ERROR"
    },
    {
        "premises": "Everyone working at Meta has a high income. \nA person with a high income will not take a bus to their destination.\nPeople will either take a bus or drive to their destination. \nEveryone who has a car will choose to drive to their destination. \nNo students drive to their destination. \nJames has a car or works at Meta.",
        "premises-FOL": [
            "all x. (WorkAt(x, Meta) -> HighIncome(x))\nall x. (HighIncome(x) -> -MeansToDestination(x, Bus))\nall x. (((MeansToDestination(x, Bus) & -MeansToDestination(x, Drive)) | (-MeansToDestination(x, Bus) & MeansToDestination(x, Drive))))\nall x. (HaveCar(x) -> MeansToDestination(x, Drive))\nall x. (Student(x) -> - MeansToDestination(x, Drive))\nHaveCar(James) | WorkAt(James, Meta)"
        ],
        "conclusion": "If James either drives to his destination or is a student, then he has a high income and is a student.",
        "conclusion-FOL": "(((MeansToDestination(x, Drive) & -Student(James)) | (-MeansToDestination(x, Drive) & Student(James)))) -> (HighIncome(James) & Student(James))",
        "label": "ERROR"
    },
    {
        "premises": "Everyone at the business conference is either an investor or an entrepreneur.\nNone of those at the business conference who enjoy the opportunity of starting a business prefer a planned economy. \nAll entrepreneurs at the business conference enjoy the opportunity of starting a business. \nEveryone at the business conference who enjoys state ownership of means of production prefers a planned economy. \nEveryone at the business conference who is an ardent communist prefers state ownership of the means of production.\nHo is at the business conference and prefers state ownership of the means of production. ",
        "premises-FOL": [
            "all x. (At(x, BusinessConference) -> (((Investor(x) & -Entrepreneur(x)) | (-Investor(x) & Entrepreneur(x)))))\nall x. ((At(x, BusinessConference) & Enjoy(x, OpportunityOfStartingOwnBusiness)) -> -Prefer(x, PlannedEconomy))\nall x. ((At(x, BusinessConference) & Entrepreneur(x)) -> Enjoy(x, OpportunityOfStartingOwnBusiness))\nall x. ((At(x, BusinessConference) & Enjoy(x, StateOwnershipOfMeansOfProduction)) -> Prefer(x, PlannedEconomy))\nall x. ((At(x, BusinessConference) & ArdentCommunist(x)) -> Prefer(x, StateOwnershipOfMeansOfProduction))\nAt(Ho, BusinessConference) & Prefer(Ho, StateOwnershipOfMeansOfProduction)"
        ],
        "conclusion": "Ho is not an ardent communist.",
        "conclusion-FOL": "-ArdentCommunist(Ho)",
        "label": "ERROR"
    },
    {
        "premises": "Everyone at the business conference is either an investor or an entrepreneur.\nNone of those at the business conference who enjoy the opportunity of starting a business prefer a planned economy. \nAll entrepreneurs at the business conference enjoy the opportunity of starting a business. \nEveryone at the business conference who enjoys state ownership of means of production prefers a planned economy. \nEveryone at the business conference who is an ardent communist prefers state ownership of the means of production.\nHo is at the business conference and prefers state ownership of the means of production. ",
        "premises-FOL": [
            "all x. (At(x, BusinessConference) -> (((Investor(x) & -Entrepreneur(x)) | (-Investor(x) & Entrepreneur(x)))))\nall x. ((At(x, BusinessConference) & Enjoy(x, OpportunityOfStartingOwnBusiness)) -> -Prefer(x, PlannedEconomy))\nall x. ((At(x, BusinessConference) & Entrepreneur(x)) -> Enjoy(x, OpportunityOfStartingOwnBusiness))\nall x. ((At(x, BusinessConference) & Enjoy(x, StateOwnershipOfMeansOfProduction)) -> Prefer(x, PlannedEconomy))\nall x. ((At(x, BusinessConference) & ArdentCommunist(x)) -> Prefer(x, StateOwnershipOfMeansOfProduction))\nAt(Ho, BusinessConference) & Prefer(Ho, StateOwnershipOfMeansOfProduction)"
        ],
        "conclusion": "Ho is an investor or is not an ardent communist.",
        "conclusion-FOL": "Investor(Ho) | (-ArdentCommunist(Ho))",
        "label": "ERROR"
    },
    {
        "premises": "No television stars are certified public accountants.\nAll certified public accountants have good business sense.",
        "premises-FOL": [
            "all x. (TelevisionStar(x) -> -CertifiedPublicAccoutant(x))\nall x. (CertifiedPublicAccoutant(x) -> Have(x, GoodBusinessSense))"
        ],
        "conclusion": "All television stars have good business sense.",
        "conclusion-FOL": "all x. (TelevisionStar(x) -> Have(x, GoodBusinessSense))",
        "label": "ERROR"
    },
    {
        "premises": "Some students in the class who are good at math are also good at chemistry.\nAll students in the class who are good at chemistry enjoy conducting experiments. \nAll students in the class that enjoy conducting experiments are good at planning. \nNone of the students who are good at planning failed the class.\nJames is a student in the class; he is either good at chemistry and failed the class, or bad at chemistry and passed the class.",
        "premises-FOL": [
            "exists x. exists y. (StudentInTheClass(x) & GoodAt(x, Math) & GoodAt(x, Chemistry) & (-(x=y)) & StudentInTheClass(y) & GoodAt(y, Math) & GoodAt(y, Chemistry))\nall x. ((StudentInTheClass(x) & GoodAt(x, Chemistry)) -> Enjoy(x, ConductingExperiment))\nall x. ((StudentInTheClass(x) & Enjoy(x, ConductingExperiment)) -> GoodAt(x, Planning))\nall x. ((StudentInTheClass(x) & GoodAt(x, Planning)) -> -Failed(x, TheClass))\nStudentInTheClass(James) & (-(((GoodAt(James, Chemistry) & -Failed(James, TheClass)) | (-GoodAt(James, Chemistry) & Failed(James, TheClass)))))"
        ],
        "conclusion": "James is good at planning.",
        "conclusion-FOL": "GoodAt(James, Planning)",
        "label": "ERROR"
    },
    {
        "premises": "Some students in the class who are good at math are also good at chemistry.\nAll students in the class who are good at chemistry enjoy conducting experiments. \nAll students in the class that enjoy conducting experiments are good at planning. \nNone of the students who are good at planning failed the class.\nJames is a student in the class; he is either good at chemistry and failed the class, or bad at chemistry and passed the class.",
        "premises-FOL": [
            "exists x. exists y. (StudentInTheClass(x) & GoodAt(x, Math) & GoodAt(x, Chemistry) & (-(x=y)) & StudentInTheClass(y) & GoodAt(y, Math) & GoodAt(y, Chemistry))\nall x. ((StudentInTheClass(x) & GoodAt(x, Chemistry)) -> Enjoy(x, ConductingExperiment))\nall x. ((StudentInTheClass(x) & Enjoy(x, ConductingExperiment)) -> GoodAt(x, Planning))\nall x. ((StudentInTheClass(x) & GoodAt(x, Planning)) -> -Failed(x, TheClass))\nStudentInTheClass(James) & (-(((GoodAt(James, Chemistry) & -Failed(James, TheClass)) | (-GoodAt(James, Chemistry) & Failed(James, TheClass)))))"
        ],
        "conclusion": "James is good at math and chemistry.",
        "conclusion-FOL": "GoodAt(James, Chemistry) & GoodAt(James, Math)",
        "label": "ERROR"
    },
    {
        "premises": "Some students in the class who are good at math are also good at chemistry.\nAll students in the class who are good at chemistry enjoy conducting experiments. \nAll students in the class that enjoy conducting experiments are good at planning. \nNone of the students who are good at planning failed the class.\nJames is a student in the class; he is either good at chemistry and failed the class, or bad at chemistry and passed the class.",
        "premises-FOL": [
            "exists x. exists y. (StudentInTheClass(x) & GoodAt(x, Math) & GoodAt(x, Chemistry) & (-(x=y)) & StudentInTheClass(y) & GoodAt(y, Math) & GoodAt(y, Chemistry))\nall x. ((StudentInTheClass(x) & GoodAt(x, Chemistry)) -> Enjoy(x, ConductingExperiment))\nall x. ((StudentInTheClass(x) & Enjoy(x, ConductingExperiment)) -> GoodAt(x, Planning))\nall x. ((StudentInTheClass(x) & GoodAt(x, Planning)) -> -Failed(x, TheClass))\nStudentInTheClass(James) & (-(((GoodAt(James, Chemistry) & -Failed(James, TheClass)) | (-GoodAt(James, Chemistry) & Failed(James, TheClass)))))"
        ],
        "conclusion": "James failed the class and is good at math.",
        "conclusion-FOL": "Failed(James, James) & GoodAt(James, Math)",
        "label": "ERROR"
    },
    {
        "premises": "Some students in the class who are good at math are also good at chemistry.\nAll students in the class who are good at chemistry enjoy conducting experiments. \nAll students in the class that enjoy conducting experiments are good at planning. \nNone of the students who are good at planning failed the class.\nJames is a student in the class; he is either good at chemistry and failed the class, or bad at chemistry and passed the class.",
        "premises-FOL": [
            "exists x. exists y. (StudentInTheClass(x) & GoodAt(x, Math) & GoodAt(x, Chemistry) & (-(x=y)) & StudentInTheClass(y) & GoodAt(y, Math) & GoodAt(y, Chemistry))\nall x. ((StudentInTheClass(x) & GoodAt(x, Chemistry)) -> Enjoy(x, ConductingExperiment))\nall x. ((StudentInTheClass(x) & Enjoy(x, ConductingExperiment)) -> GoodAt(x, Planning))\nall x. ((StudentInTheClass(x) & GoodAt(x, Planning)) -> -Failed(x, TheClass))\nStudentInTheClass(James) & (-(((GoodAt(James, Chemistry) & -Failed(James, TheClass)) | (-GoodAt(James, Chemistry) & Failed(James, TheClass)))))"
        ],
        "conclusion": "If James is good at Chemistry or failed the class, then James is either good at planning or good at math.",
        "conclusion-FOL": "(GoodAt(James, Chemistry) | Failed(James, TheClass)) -> (((GoodAt(James, Planning) & -GoodAt(James, Math)) | (-GoodAt(James, Planning) & GoodAt(James, Math))))",
        "label": "ERROR"
    },
    {
        "premises": "If a Leetcode problem is at the easy level, then its AC rate is lower than 20 percent. \nAll Leetcode problems that are recommended to novices are easy. \nA Leetode problem is either easy or hard.\nLeetcode problems that are starred by more than one thousand users are hard.\n2Sum is recommended to novices. \n4Sum is starred by more than 1,000 users.",
        "premises-FOL": [
            "all x. (Easy(x) -> exists y. (LessThan(y, PercentTwoZero) & ACRate(x,y)))\nall x. (Recommended(x) -> Easy(x))\nall x. (((Easy(x) & -Hard(x)) | (-Easy(x) & Hard(x))))\nall x. (Starred(x)) -> Hard(x))\nRecommended(Twosum) \nStarred(Foursum)"
        ],
        "conclusion": "2Sum is a Leetcode problem at the easy level.",
        "conclusion-FOL": "Easy(Twosum)",
        "label": "ERROR"
    },
    {
        "premises": "If a Leetcode problem is at the easy level, then its AC rate is lower than 20 percent. \nAll Leetcode problems that are recommended to novices are easy. \nA Leetode problem is either easy or hard.\nLeetcode problems that are starred by more than one thousand users are hard.\n2Sum is recommended to novices. \n4Sum is starred by more than 1,000 users.",
        "premises-FOL": [
            "all x. (Easy(x) -> exists y. (LessThan(y, PercentTwoZero) & ACRate(x,y)))\nall x. (Recommended(x) -> Easy(x))\nall x. (((Easy(x) & -Hard(x)) | (-Easy(x) & Hard(x))))\nall x. (Starred(x)) -> Hard(x))\nRecommended(Twosum) \nStarred(Foursum)"
        ],
        "conclusion": "4Sum is a Leetcode problem recommended to the novice.",
        "conclusion-FOL": "Recommended(Foursum)",
        "label": "ERROR"
    },
    {
        "premises": "If a Leetcode problem is at the easy level, then its AC rate is lower than 20 percent. \nAll Leetcode problems that are recommended to novices are easy. \nA Leetode problem is either easy or hard.\nLeetcode problems that are starred by more than one thousand users are hard.\n2Sum is recommended to novices. \n4Sum is starred by more than 1,000 users.",
        "premises-FOL": [
            "all x. (Easy(x) -> exists y. (LessThan(y, PercentTwoZero) & ACRate(x,y)))\nall x. (Recommended(x) -> Easy(x))\nall x. (((Easy(x) & -Hard(x)) | (-Easy(x) & Hard(x))))\nall x. (Starred(x)) -> Hard(x))\nRecommended(Twosum) \nStarred(Foursum)"
        ],
        "conclusion": "2Sum has an AC rate higher than 20 percent.",
        "conclusion-FOL": "exists y.(GreaterThan(y, PercentTwoZero) & ACRate(TwoSum,y))",
        "label": "ERROR"
    },
    {
        "premises": "Everyone who rents a car spends money.\nWhenever Sarah goes to Vermont, Sarah drives there.\nSomeone who does not own a car to drive somewhere must either borrow a car or rent a car.\nSarah doesn\u2019t own a car.\nSarah never borrows a car to go camping.\nSarah is going to go camping in Vermont.\nTo go camping somewhere, you must go to that place.",
        "premises-FOL": [
            "all x. (Rent(x, Car) -> Spend(x, Money))\nGoTo(Sarah, Vermont) -> DriveTo(Sarah, Vermont)\nall x. all y. (-Own(x, Car) & DriveTo(x, y) -> ((Borrow(x, Car) & -Rent(x, Car)) | (-Borrow(x, Car) & Rent(x, Car))))\n-Own(Sarah, Car)\nall x. (Camping(Sarah, x) -> -(Borrow(Sarah, Car)))\nCamping(Sarah, Vermont)\nall x. all y. (Camping(x, y) -> GoTo(x, y))"
        ],
        "conclusion": "Sarah will spend money this weekend.",
        "conclusion-FOL": "Spend(Sarah, Money)",
        "label": "ERROR"
    },
    {
        "premises": "All people who attend weddings are getting married or know the people who are getting married.\nNo preteens or young children are getting married or know the people who are getting married.\nPeople who enjoy celebrating life milestone events with other people attend weddings.\nPeople who are fond of large group functions enjoy celebrating life milestone events with other people.\nAll people who are outgoing and spirited are fond of large group functions.\nIf Carol is not both a pre-teen or young child and attends a wedding, then Carol is not getting married or knows the people who are getting married.  ",
        "premises-FOL": [
            "all x. (Attend(x, Wedding) -> GettingMarried(x) | (exists y. (Know(x, y) & GettingMarried(y)))\nall x. (PreTeen(x) | YoungChild(x) -> -(GettingMarried(x) \u2295 (exists y. (Know(x, y) & GettingMarried(y)))))\nall x. (exists y. exists z. (-(x=y) & -(x=z) & -(y=z) & Enjoy(x, CelebratingLifeMileStoneEvent, y) & Enjoy(x, CelebratingLifeStoneEvent, z)) -> Attend(x, Wedding))\nall x. (FondOf(x, LargeGroupFunction) -> exists y. exists z. (-(x=y) & -(x=z) & -(y=z) & Enjoy(x, CelebratingLifeMileStoneEventWith, y) & Enjoy(x, CelebratingLifeStoneEvent, z)))\nall x. (Outgoing(x) & Sprited(x)  -> FondOf(x, LargeGroupFunction))\n-((PreTeen(Carol) | YoungChildren(Carol)) & Attend(Carol, Wedding)) -> -(GettingMarried(Carol) | (exists y. (Know(Carol, y) & GettingMarried(y))))"
        ],
        "conclusion": "Carol is outgoing and very spirited.",
        "conclusion-FOL": "Outgoing(Carol) & Sprited(Carol)",
        "label": "ERROR"
    },
    {
        "premises": "All people who attend weddings are getting married or know the people who are getting married.\nNo preteens or young children are getting married or know the people who are getting married.\nPeople who enjoy celebrating life milestone events with other people attend weddings.\nPeople who are fond of large group functions enjoy celebrating life milestone events with other people.\nAll people who are outgoing and spirited are fond of large group functions.\nIf Carol is not both a pre-teen or young child and attends a wedding, then Carol is not getting married or knows the people who are getting married.  ",
        "premises-FOL": [
            "all x. (Attend(x, Wedding) -> GettingMarried(x) | (exists y. (Know(x, y) & GettingMarried(y)))\nall x. (PreTeen(x) | YoungChild(x) -> -(GettingMarried(x) \u2295 (exists y. (Know(x, y) & GettingMarried(y)))))\nall x. (exists y. exists z. (-(x=y) & -(x=z) & -(y=z) & Enjoy(x, CelebratingLifeMileStoneEvent, y) & Enjoy(x, CelebratingLifeStoneEvent, z)) -> Attend(x, Wedding))\nall x. (FondOf(x, LargeGroupFunction) -> exists y. exists z. (-(x=y) & -(x=z) & -(y=z) & Enjoy(x, CelebratingLifeMileStoneEventWith, y) & Enjoy(x, CelebratingLifeStoneEvent, z)))\nall x. (Outgoing(x) & Sprited(x)  -> FondOf(x, LargeGroupFunction))\n-((PreTeen(Carol) | YoungChildren(Carol)) & Attend(Carol, Wedding)) -> -(GettingMarried(Carol) | (exists y. (Know(Carol, y) & GettingMarried(y))))"
        ],
        "conclusion": "Carol is a preteen or a young child.",
        "conclusion-FOL": "PreTeen(Carol) | YoungChild(Carol)",
        "label": "ERROR"
    },
    {
        "premises": "All people who attend weddings are getting married or know the people who are getting married.\nNo preteens or young children are getting married or know the people who are getting married.\nPeople who enjoy celebrating life milestone events with other people attend weddings.\nPeople who are fond of large group functions enjoy celebrating life milestone events with other people.\nAll people who are outgoing and spirited are fond of large group functions.\nIf Carol is not both a pre-teen or young child and attends a wedding, then Carol is not getting married or knows the people who are getting married.  ",
        "premises-FOL": [
            "all x. (Attend(x, Wedding) -> GettingMarried(x) | (exists y. (Know(x, y) & GettingMarried(y)))\nall x. (PreTeen(x) | YoungChild(x) -> -(GettingMarried(x) \u2295 (exists y. (Know(x, y) & GettingMarried(y)))))\nall x. (exists y. exists z. (-(x=y) & -(x=z) & -(y=z) & Enjoy(x, CelebratingLifeMileStoneEvent, y) & Enjoy(x, CelebratingLifeStoneEvent, z)) -> Attend(x, Wedding))\nall x. (FondOf(x, LargeGroupFunction) -> exists y. exists z. (-(x=y) & -(x=z) & -(y=z) & Enjoy(x, CelebratingLifeMileStoneEventWith, y) & Enjoy(x, CelebratingLifeStoneEvent, z)))\nall x. (Outgoing(x) & Sprited(x)  -> FondOf(x, LargeGroupFunction))\n-((PreTeen(Carol) | YoungChildren(Carol)) & Attend(Carol, Wedding)) -> -(GettingMarried(Carol) | (exists y. (Know(Carol, y) & GettingMarried(y))))"
        ],
        "conclusion": "Carol neither enjoys celebrating life milestone events with other people nor is outgoing and very spirited.",
        "conclusion-FOL": "-((exists y. exists z. (-(x=y) & -(x=z) & -(y=z) & Enjoy(x, CelebratingLifeMileStoneEvent, y) & Enjoy(x, CelebratingLifeStoneEvent, z)) | (Outgoing(Carol) & Sprited(Carol)))",
        "label": "ERROR"
    },
    {
        "premises": "All velvet-finish lipsticks in the Rouge Dior set, Lunar New Year Limited Edition are refillable.\nLipsticks in the Rouge Dior set, Lunar New Year Limited Edition have either a velvet-finish or a satin-finish.\nNo satin-finish lipsticks in the set do not have \"rosewood\" in its offical description. \nLipstcks in the Rouge Dior set, Lunar New Year Limited Edition either does not have \"rosewood\" in its offical description or it has \"rosewood\" in its official description. \nROUGE Dior Colored Lip Balm 999 is a lipstick in the set, and it either has \"rosewood\" in its official description or has a velvet finish.",
        "premises-FOL": [
            "all x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition) & VelvetFinish(x)) -> Refillable(x))\nall x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition)) -> (((VelvetFinish(x) & -SatinFinish(x)) | (-VelvetFinish(x) & SatinFinish(x))))\nall x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition) & SatinFinish(x)) -> -RosewoodInDescription(x))\nall x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition)) -> (RosewoodInDescription(x) \u2295 -RosewoodInDescription(x)))\nLipstick(RougeDiorColoredLipBalmNineNineNine) & In(RougeDiorColoredLipBalmNineNineNine, RougeDiorSet) & In(RougeDiorColoredLipBalmNineNineNine, LunarNewYearLimitedEdition) & (((RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine) & -VelvetFinish(RougeDiorColoredLipBalmNineNineNine)) | (-RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine) & VelvetFinish(RougeDiorColoredLipBalmNineNineNine))))"
        ],
        "conclusion": "ROUGE Dior Colored Lip Balm 999 has a satin finish.",
        "conclusion-FOL": "SatinFinish(RougeDiorColoredLipBalmNineNineNine)",
        "label": "ERROR"
    },
    {
        "premises": "All velvet-finish lipsticks in the Rouge Dior set, Lunar New Year Limited Edition are refillable.\nLipsticks in the Rouge Dior set, Lunar New Year Limited Edition have either a velvet-finish or a satin-finish.\nNo satin-finish lipsticks in the set do not have \"rosewood\" in its offical description. \nLipstcks in the Rouge Dior set, Lunar New Year Limited Edition either does not have \"rosewood\" in its offical description or it has \"rosewood\" in its official description. \nROUGE Dior Colored Lip Balm 999 is a lipstick in the set, and it either has \"rosewood\" in its official description or has a velvet finish.",
        "premises-FOL": [
            "all x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition) & VelvetFinish(x)) -> Refillable(x))\nall x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition)) -> (((VelvetFinish(x) & -SatinFinish(x)) | (-VelvetFinish(x) & SatinFinish(x))))\nall x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition) & SatinFinish(x)) -> -RosewoodInDescription(x))\nall x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition)) -> (RosewoodInDescription(x) \u2295 -RosewoodInDescription(x)))\nLipstick(RougeDiorColoredLipBalmNineNineNine) & In(RougeDiorColoredLipBalmNineNineNine, RougeDiorSet) & In(RougeDiorColoredLipBalmNineNineNine, LunarNewYearLimitedEdition) & (((RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine) & -VelvetFinish(RougeDiorColoredLipBalmNineNineNine)) | (-RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine) & VelvetFinish(RougeDiorColoredLipBalmNineNineNine))))"
        ],
        "conclusion": "ROUGE Dior Colored Lip Balm 999 has a satin finish and has \"rosewood\" in its official description.",
        "conclusion-FOL": "Refillable(RougeDiorColoredLipBalmNineNineNine) & RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine)",
        "label": "ERROR"
    },
    {
        "premises": "All velvet-finish lipsticks in the Rouge Dior set, Lunar New Year Limited Edition are refillable.\nLipsticks in the Rouge Dior set, Lunar New Year Limited Edition have either a velvet-finish or a satin-finish.\nNo satin-finish lipsticks in the set do not have \"rosewood\" in its offical description. \nLipstcks in the Rouge Dior set, Lunar New Year Limited Edition either does not have \"rosewood\" in its offical description or it has \"rosewood\" in its official description. \nROUGE Dior Colored Lip Balm 999 is a lipstick in the set, and it either has \"rosewood\" in its official description or has a velvet finish.",
        "premises-FOL": [
            "all x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition) & VelvetFinish(x)) -> Refillable(x))\nall x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition)) -> (((VelvetFinish(x) & -SatinFinish(x)) | (-VelvetFinish(x) & SatinFinish(x))))\nall x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition) & SatinFinish(x)) -> -RosewoodInDescription(x))\nall x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition)) -> (RosewoodInDescription(x) \u2295 -RosewoodInDescription(x)))\nLipstick(RougeDiorColoredLipBalmNineNineNine) & In(RougeDiorColoredLipBalmNineNineNine, RougeDiorSet) & In(RougeDiorColoredLipBalmNineNineNine, LunarNewYearLimitedEdition) & (((RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine) & -VelvetFinish(RougeDiorColoredLipBalmNineNineNine)) | (-RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine) & VelvetFinish(RougeDiorColoredLipBalmNineNineNine))))"
        ],
        "conclusion": "ROUGE Dior Colored Lip Balm 999 either is refillable or has \"rosewood\" in its official description.",
        "conclusion-FOL": "((Refillable(RougeDiorColoredLipBalmNineNineNine) & -RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine)) | (-Refillable(RougeDiorColoredLipBalmNineNineNine) & RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine)))",
        "label": "ERROR"
    },
    {
        "premises": "All velvet-finish lipsticks in the Rouge Dior set, Lunar New Year Limited Edition are refillable.\nLipsticks in the Rouge Dior set, Lunar New Year Limited Edition have either a velvet-finish or a satin-finish.\nNo satin-finish lipsticks in the set do not have \"rosewood\" in its offical description. \nLipstcks in the Rouge Dior set, Lunar New Year Limited Edition either does not have \"rosewood\" in its offical description or it has \"rosewood\" in its official description. \nROUGE Dior Colored Lip Balm 999 is a lipstick in the set, and it either has \"rosewood\" in its official description or has a velvet finish.",
        "premises-FOL": [
            "all x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition) & VelvetFinish(x)) -> Refillable(x))\nall x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition)) -> (((VelvetFinish(x) & -SatinFinish(x)) | (-VelvetFinish(x) & SatinFinish(x))))\nall x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition) & SatinFinish(x)) -> -RosewoodInDescription(x))\nall x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition)) -> (RosewoodInDescription(x) \u2295 -RosewoodInDescription(x)))\nLipstick(RougeDiorColoredLipBalmNineNineNine) & In(RougeDiorColoredLipBalmNineNineNine, RougeDiorSet) & In(RougeDiorColoredLipBalmNineNineNine, LunarNewYearLimitedEdition) & (((RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine) & -VelvetFinish(RougeDiorColoredLipBalmNineNineNine)) | (-RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine) & VelvetFinish(RougeDiorColoredLipBalmNineNineNine))))"
        ],
        "conclusion": "If ROUGE Dior Colored Lip Balm 999 is not both a velvet finish ipstick in the set and refillable, then it neither is refillable nor has \"rosewood\" in its official description.",
        "conclusion-FOL": "-((Lipstick(RougeDiorColoredLipBalmNineNineNine) & In(RougeDiorColoredLipBalmNineNineNine, RougeDiorSet) & In(RougeDiorColoredLipBalmNineNineNine, LunarNewYearLimitedEdition) & VelvetFinish(RougeDiorColoredLipBalmNineNineNine) & Refillable(RougeDiorColoredLipBalmNineNineNine)) -> (-Refillable(RougeDiorColoredLipBalmNineNineNine) & -RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine)))",
        "label": "ERROR"
    },
    {
        "premises": "All velvet-finish lipsticks in the Rouge Dior set, Lunar New Year Limited Edition are refillable.\nLipsticks in the Rouge Dior set, Lunar New Year Limited Edition have either a velvet-finish or a satin-finish.\nNo satin-finish lipsticks in the set do not have \"rosewood\" in its offical description. \nLipstcks in the Rouge Dior set, Lunar New Year Limited Edition either does not have \"rosewood\" in its offical description or it has \"rosewood\" in its official description. \nROUGE Dior Colored Lip Balm 999 is a lipstick in the set, and it either has \"rosewood\" in its official description or has a velvet finish.",
        "premises-FOL": [
            "all x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition) & VelvetFinish(x)) -> Refillable(x))\nall x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition)) -> (((VelvetFinish(x) & -SatinFinish(x)) | (-VelvetFinish(x) & SatinFinish(x))))\nall x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition) & SatinFinish(x)) -> -RosewoodInDescription(x))\nall x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition)) -> (RosewoodInDescription(x) \u2295 -RosewoodInDescription(x)))\nLipstick(RougeDiorColoredLipBalmNineNineNine) & In(RougeDiorColoredLipBalmNineNineNine, RougeDiorSet) & In(RougeDiorColoredLipBalmNineNineNine, LunarNewYearLimitedEdition) & (((RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine) & -VelvetFinish(RougeDiorColoredLipBalmNineNineNine)) | (-RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine) & VelvetFinish(RougeDiorColoredLipBalmNineNineNine))))"
        ],
        "conclusion": "If ROUGE Dior Colored Lip Balm 999 is refillable and has \"rosewood\" in its official description, then it either has a velvet-finish or has \"rosewood\" in its official description.",
        "conclusion-FOL": "(Refillable(RougeDiorColoredLipBalmNineNineNine) & RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine)) \u2014> (VelvetFinish(RougeDiorColoredLipBalmNineNineNine) | RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine))",
        "label": "ERROR"
    },
    {
        "premises": "All velvet-finish lipsticks in the Rouge Dior set, Lunar New Year Limited Edition are refillable.\nLipsticks in the Rouge Dior set, Lunar New Year Limited Edition have either a velvet-finish or a satin-finish.\nNo satin-finish lipsticks in the set do not have \"rosewood\" in its offical description. \nLipstcks in the Rouge Dior set, Lunar New Year Limited Edition either does not have \"rosewood\" in its offical description or it has \"rosewood\" in its official description. \nROUGE Dior Colored Lip Balm 999 is a lipstick in the set, and it either has \"rosewood\" in its official description or has a velvet finish.",
        "premises-FOL": [
            "all x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition) & VelvetFinish(x)) -> Refillable(x))\nall x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition)) -> (((VelvetFinish(x) & -SatinFinish(x)) | (-VelvetFinish(x) & SatinFinish(x))))\nall x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition) & SatinFinish(x)) -> -RosewoodInDescription(x))\nall x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition)) -> (RosewoodInDescription(x) \u2295 -RosewoodInDescription(x)))\nLipstick(RougeDiorColoredLipBalmNineNineNine) & In(RougeDiorColoredLipBalmNineNineNine, RougeDiorSet) & In(RougeDiorColoredLipBalmNineNineNine, LunarNewYearLimitedEdition) & (((RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine) & -VelvetFinish(RougeDiorColoredLipBalmNineNineNine)) | (-RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine) & VelvetFinish(RougeDiorColoredLipBalmNineNineNine))))"
        ],
        "conclusion": "If ROUGE Dior Colored Lip Balm 999 either does not have \"rosewood\" in its official description or is refillable, then it has \"rosewood\" in its official description.",
        "conclusion-FOL": "(-((RosewoodInDescription(RougeEDiorColoredLipBalmNineNineNine) & -Refillable(RougeDiorColoredLipBalmNineNineNine)) | (-RosewoodInDescription(RougeEDiorColoredLipBalmNineNineNine) & Refillable(RougeDiorColoredLipBalmNineNineNine)))) -> RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine)",
        "label": "ERROR"
    },
    {
        "premises": "All velvet-finish lipsticks in the Rouge Dior set, Lunar New Year Limited Edition are refillable.\nLipsticks in the Rouge Dior set, Lunar New Year Limited Edition have either a velvet-finish or a satin-finish.\nNo satin-finish lipsticks in the set do not have \"rosewood\" in its offical description. \nLipstcks in the Rouge Dior set, Lunar New Year Limited Edition either does not have \"rosewood\" in its offical description or it has \"rosewood\" in its official description. \nROUGE Dior Colored Lip Balm 999 is a lipstick in the set, and it either has \"rosewood\" in its official description or has a velvet finish.",
        "premises-FOL": [
            "all x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition) & VelvetFinish(x)) -> Refillable(x))\nall x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition)) -> (((VelvetFinish(x) & -SatinFinish(x)) | (-VelvetFinish(x) & SatinFinish(x))))\nall x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition) & SatinFinish(x)) -> -RosewoodInDescription(x))\nall x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition)) -> (RosewoodInDescription(x) \u2295 -RosewoodInDescription(x)))\nLipstick(RougeDiorColoredLipBalmNineNineNine) & In(RougeDiorColoredLipBalmNineNineNine, RougeDiorSet) & In(RougeDiorColoredLipBalmNineNineNine, LunarNewYearLimitedEdition) & (((RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine) & -VelvetFinish(RougeDiorColoredLipBalmNineNineNine)) | (-RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine) & VelvetFinish(RougeDiorColoredLipBalmNineNineNine))))"
        ],
        "conclusion": "If ROUGE Dior Colored Lip Balm 999 either does not have \"rosewood\" in its official description or is refillable, then it neither has a satin-finish nor has \"rosewood\" in its official description.",
        "conclusion-FOL": "(((RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine) & -Refillable(RougeDiorColoredLipBalmNineNineNine)) | (-RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine) & Refillable(RougeDiorColoredLipBalmNineNineNine)))) -> -(SatinFinish(RougeDiorColoredLipBalmNineNineNine) | RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine))",
        "label": "ERROR"
    },
    {
        "premises": "All velvet-finish lipsticks in the Rouge Dior set, Lunar New Year Limited Edition are refillable.\nLipsticks in the Rouge Dior set, Lunar New Year Limited Edition have either a velvet-finish or a satin-finish.\nNo satin-finish lipsticks in the set do not have \"rosewood\" in its offical description. \nLipstcks in the Rouge Dior set, Lunar New Year Limited Edition either does not have \"rosewood\" in its offical description or it has \"rosewood\" in its official description. \nROUGE Dior Colored Lip Balm 999 is a lipstick in the set, and it either has \"rosewood\" in its official description or has a velvet finish.",
        "premises-FOL": [
            "all x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition) & VelvetFinish(x)) -> Refillable(x))\nall x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition)) -> (((VelvetFinish(x) & -SatinFinish(x)) | (-VelvetFinish(x) & SatinFinish(x))))\nall x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition) & SatinFinish(x)) -> -RosewoodInDescription(x))\nall x. ((Lipstick(x) & In(x, RougeDiorSet) & In(x, LunarNewYearLimitedEdition)) -> (RosewoodInDescription(x) \u2295 -RosewoodInDescription(x)))\nLipstick(RougeDiorColoredLipBalmNineNineNine) & In(RougeDiorColoredLipBalmNineNineNine, RougeDiorSet) & In(RougeDiorColoredLipBalmNineNineNine, LunarNewYearLimitedEdition) & (((RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine) & -VelvetFinish(RougeDiorColoredLipBalmNineNineNine)) | (-RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine) & VelvetFinish(RougeDiorColoredLipBalmNineNineNine))))"
        ],
        "conclusion": "If ROUGE Dior Colored Lip Balm 999 is refillable or has \"rosewood\" in its official description, then it either is refillable or has \"rosewood\" in its official description..",
        "conclusion-FOL": "(Refillable(RougeDiorColoredLipBalmNineNineNine) | RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine)) -> (((Refillable(RougeEDiorColoredLipBalmNineNineNine) & -RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine)) | (-Refillable(RougeEDiorColoredLipBalmNineNineNine) & RosewoodInDescription(RougeDiorColoredLipBalmNineNineNine))))",
        "label": "ERROR"
    },
    {
        "premises": "All Senate Republicans are elected officials.\nSome elected officials are not conservatives.",
        "premises-FOL": [
            "all x. (SenateRepublican(x) -> ElectedOfficial(x))\nexists x. exists y. (ElectedOfficial(x) & ElectedOfficial(y) & -Conservative(x) & -Conservative(y) & -(x=y))"
        ],
        "conclusion": "Some conservatives are not Senate Republicans.",
        "conclusion-FOL": "exists x. exists y. (Conservative(x) & Conservative(y) & -SenateRepublican(x) & -SenateRepublican(y) & -(x=y))",
        "label": "ERROR"
    },
    {
        "premises": "No athletes never exercise.\nAll professional basketball players are athletes. \nAll NBA players are professional basketball players. \nAll Knicks players are NBA players. \nEither John is a professional basketball player and he never exercises, or he is not a professional basketball player and he sometimes exercises.",
        "premises-FOL": [
            "all x. (Athlete(x) -> -NeverExercises(x)) Never: Does Not Exist a Time\nall x. (ProfessionalBasketballPlayer(x) -> Athlete(x))\nall x. (NBAPlayer(x) -> ProfessionalBasketballPlayer(x))\nall x. (KnicksPlayer(x) -> NBAPlayer(x))\n-(((ProfessionalBasketballPlayer(Jim) & -NeverExercises(Jim)) | (-ProfessionalBasketballPlayer(Jim) & NeverExercises(Jim))))"
        ],
        "conclusion": "Jim is a Knicks player.",
        "conclusion-FOL": "KnicksPlayer(Jim)",
        "label": "ERROR"
    },
    {
        "premises": "No athletes never exercise.\nAll professional basketball players are athletes. \nAll NBA players are professional basketball players. \nAll Knicks players are NBA players. \nEither John is a professional basketball player and he never exercises, or he is not a professional basketball player and he sometimes exercises.",
        "premises-FOL": [
            "all x. (Athlete(x) -> -NeverExercises(x)) Never: Does Not Exist a Time\nall x. (ProfessionalBasketballPlayer(x) -> Athlete(x))\nall x. (NBAPlayer(x) -> ProfessionalBasketballPlayer(x))\nall x. (KnicksPlayer(x) -> NBAPlayer(x))\n-(((ProfessionalBasketballPlayer(Jim) & -NeverExercises(Jim)) | (-ProfessionalBasketballPlayer(Jim) & NeverExercises(Jim))))"
        ],
        "conclusion": "Jim is not a Knicks player.",
        "conclusion-FOL": "-KnicksPlayer(Jim)",
        "label": "ERROR"
    },
    {
        "premises": "No athletes never exercise.\nAll professional basketball players are athletes. \nAll NBA players are professional basketball players. \nAll Knicks players are NBA players. \nEither John is a professional basketball player and he never exercises, or he is not a professional basketball player and he sometimes exercises.",
        "premises-FOL": [
            "all x. (Athlete(x) -> -NeverExercises(x)) Never: Does Not Exist a Time\nall x. (ProfessionalBasketballPlayer(x) -> Athlete(x))\nall x. (NBAPlayer(x) -> ProfessionalBasketballPlayer(x))\nall x. (KnicksPlayer(x) -> NBAPlayer(x))\n-(((ProfessionalBasketballPlayer(Jim) & -NeverExercises(Jim)) | (-ProfessionalBasketballPlayer(Jim) & NeverExercises(Jim))))"
        ],
        "conclusion": "Jim is an athlete.",
        "conclusion-FOL": "Athlete(Jim)",
        "label": "ERROR"
    },
    {
        "premises": "All kids are young.\nAll toddlers are kids.\nIf someone is young, then they are not elderly.\nAll pirates are seafarers.\nIf Nancy is not a pirate, then Nancy is young.\nIf Nancy is not a toddler, then Nancy is a seafarer.",
        "premises-FOL": [
            "all x. (Kid(x) -> Young(x))\nall x. (Toddler(x) -> Kid(x))\nall x. (Young(x) -> -Elderly(x))\nall x. (Pirate(x) -> Seafarer(x))\n-Pirate(Nancy) -> Young(Nancy)\n-Toddler(Nancy) -> Seafarer(Nancy)"
        ],
        "conclusion": "Nancy is a pirate.",
        "conclusion-FOL": "Pirate(Nancy)",
        "label": "ERROR"
    },
    {
        "premises": "All kids are young.\nAll toddlers are kids.\nIf someone is young, then they are not elderly.\nAll pirates are seafarers.\nIf Nancy is not a pirate, then Nancy is young.\nIf Nancy is not a toddler, then Nancy is a seafarer.",
        "premises-FOL": [
            "all x. (Kid(x) -> Young(x))\nall x. (Toddler(x) -> Kid(x))\nall x. (Young(x) -> -Elderly(x))\nall x. (Pirate(x) -> Seafarer(x))\n-Pirate(Nancy) -> Young(Nancy)\n-Toddler(Nancy) -> Seafarer(Nancy)"
        ],
        "conclusion": "Nancy is either both a pirate and a toddler, or neither a pirate nor a toddler.",
        "conclusion-FOL": "-(((Pirate(Nancy) & -Toddler(Nancy)) | (-Pirate(Nancy) & Toddler(Nancy))))",
        "label": "ERROR"
    },
    {
        "premises": "All kids are young.\nAll toddlers are kids.\nIf someone is young, then they are not elderly.\nAll pirates are seafarers.\nIf Nancy is not a pirate, then Nancy is young.\nIf Nancy is not a toddler, then Nancy is a seafarer.",
        "premises-FOL": [
            "all x. (Kid(x) -> Young(x))\nall x. (Toddler(x) -> Kid(x))\nall x. (Young(x) -> -Elderly(x))\nall x. (Pirate(x) -> Seafarer(x))\n-Pirate(Nancy) -> Young(Nancy)\n-Toddler(Nancy) -> Seafarer(Nancy)"
        ],
        "conclusion": "If Nancy is not either a pirate or a toddler, then she is young and is a kid.",
        "conclusion-FOL": "-(((Pirate(Nancy) & -Toddler(Nancy)) | (-Pirate(Nancy) & Toddler(Nancy)))) -> Young(Nancy) & Kid(Nancy)",
        "label": "ERROR"
    },
    {
        "premises": "Lana Wilson directed After Tiller, The Departure, and Miss Americana.\nIf a film is directed by a person, the person is a filmmaker.\nAfter Tiller is a documentary.\nThe documentary is a type of film.\nLana Wilson is from Kirkland.\nKirkland is a US city.\nIf a person is from a city in a country, the person is from the country.\nAfter Tiller is nominated for the Independent Spirit Award for Best Documentary.",
        "premises-FOL": [
            "DirectedBy(AfterTiller, LanaWilson) & DirectedBy(TheDeparture, LanaWilson) & DirectedBy(MissAmericana, LanaWilson)\nall x. all y. (DirectedBy(x, y) -> Filmmaker(y))\nDocumentary(AfterTiller)\nall x. (Documentary(x) -> Film(x))\nFrom(LanaWilson, Kirkland)\nIn(Kirkland, UnitedStates)\nall x. all y. all z. ((From(x, y) & In(y, z)) -> From(x, z))\nNomination(AfterTiller, TheIndependentSpiritAwardForBestDocumentary)"
        ],
        "conclusion": "Lana Wilson is a US filmmaker.",
        "conclusion-FOL": "From(LanaWilson, UnitedStates) & Filmmaker(LanaWilson)",
        "label": "ERROR"
    },
    {
        "premises": "Lana Wilson directed After Tiller, The Departure, and Miss Americana.\nIf a film is directed by a person, the person is a filmmaker.\nAfter Tiller is a documentary.\nThe documentary is a type of film.\nLana Wilson is from Kirkland.\nKirkland is a US city.\nIf a person is from a city in a country, the person is from the country.\nAfter Tiller is nominated for the Independent Spirit Award for Best Documentary.",
        "premises-FOL": [
            "DirectedBy(AfterTiller, LanaWilson) & DirectedBy(TheDeparture, LanaWilson) & DirectedBy(MissAmericana, LanaWilson)\nall x. all y. (DirectedBy(x, y) -> Filmmaker(y))\nDocumentary(AfterTiller)\nall x. (Documentary(x) -> Film(x))\nFrom(LanaWilson, Kirkland)\nIn(Kirkland, UnitedStates)\nall x. all y. all z. ((From(x, y) & In(y, z)) -> From(x, z))\nNomination(AfterTiller, TheIndependentSpiritAwardForBestDocumentary)"
        ],
        "conclusion": "Miss Americana is not directed by a filmmaker from Kirkland.",
        "conclusion-FOL": "-exists x.(Filmmaker(x) & From(x, Kirkland) & DirectedBy(MissAmericana, x))",
        "label": "ERROR"
    },
    {
        "premises": "Lana Wilson directed After Tiller, The Departure, and Miss Americana.\nIf a film is directed by a person, the person is a filmmaker.\nAfter Tiller is a documentary.\nThe documentary is a type of film.\nLana Wilson is from Kirkland.\nKirkland is a US city.\nIf a person is from a city in a country, the person is from the country.\nAfter Tiller is nominated for the Independent Spirit Award for Best Documentary.",
        "premises-FOL": [
            "DirectedBy(AfterTiller, LanaWilson) & DirectedBy(TheDeparture, LanaWilson) & DirectedBy(MissAmericana, LanaWilson)\nall x. all y. (DirectedBy(x, y) -> Filmmaker(y))\nDocumentary(AfterTiller)\nall x. (Documentary(x) -> Film(x))\nFrom(LanaWilson, Kirkland)\nIn(Kirkland, UnitedStates)\nall x. all y. all z. ((From(x, y) & In(y, z)) -> From(x, z))\nNomination(AfterTiller, TheIndependentSpiritAwardForBestDocumentary)"
        ],
        "conclusion": "Lana Wilson has won the Independent Spirit Award.",
        "conclusion-FOL": "FilmmakerAward(LanaWilson, TheIndependentSpiritAwardForBestDocumentary)",
        "label": "ERROR"
    },
    {
        "premises": "All bears in zoos are not wild. \nSome bears are in zoos. ",
        "premises-FOL": [
            "all x. ((Bear(x) & In(x, Zoo)) -> -Wild(x))\nexists x. exists y. (Bear(x) & Bear(y) & In(x, Zoo) & In(y, Zoo) & -(x=y))"
        ],
        "conclusion": "Not all bears are wild.",
        "conclusion-FOL": "exists x. (Bear(x) & -Wild(x))",
        "label": "ERROR"
    },
    {
        "premises": "If a person is the leader of a country for life, that person has power.\nLeaders of a country for life are either a king or a queen.\nQueens are female.\nKings are male. \nElizabeth is a queen.\nElizabeth is a leader of a country for life.",
        "premises-FOL": [
            "all x. (Leader(x) -> HavePower(x))\nall x. (Leader(x) -> (((King(x) & -Queen(x)) | (-King(x) & Queen(x)))))\nall x. (Queen(x) -> Female(x))\nall x. (King(x) -> Male(x))\nQueen(Elizabeth)\nLeader(Elizabeth)"
        ],
        "conclusion": "Elizabeth is a king.",
        "conclusion-FOL": "King(Elizabeth)",
        "label": "ERROR"
    },
    {
        "premises": "If a person is the leader of a country for life, that person has power.\nLeaders of a country for life are either a king or a queen.\nQueens are female.\nKings are male. \nElizabeth is a queen.\nElizabeth is a leader of a country for life.",
        "premises-FOL": [
            "all x. (Leader(x) -> HavePower(x))\nall x. (Leader(x) -> (((King(x) & -Queen(x)) | (-King(x) & Queen(x)))))\nall x. (Queen(x) -> Female(x))\nall x. (King(x) -> Male(x))\nQueen(Elizabeth)\nLeader(Elizabeth)"
        ],
        "conclusion": "Elizabeth has power.",
        "conclusion-FOL": "HavePower(Elizabeth)",
        "label": "ERROR"
    },
    {
        "premises": "If a person is the leader of a country for life, that person has power.\nLeaders of a country for life are either a king or a queen.\nQueens are female.\nKings are male. \nElizabeth is a queen.\nElizabeth is a leader of a country for life.",
        "premises-FOL": [
            "all x. (Leader(x) -> HavePower(x))\nall x. (Leader(x) -> (((King(x) & -Queen(x)) | (-King(x) & Queen(x)))))\nall x. (Queen(x) -> Female(x))\nall x. (King(x) -> Male(x))\nQueen(Elizabeth)\nLeader(Elizabeth)"
        ],
        "conclusion": "Elizabeth is a leader of a country for life.",
        "conclusion-FOL": "Leader(Elizabeth)",
        "label": "ERROR"
    },
    {
        "premises": "All people who went to Clay's school and who make their own matcha teas every morning with ceremonial-grade matcha powder do not wake up late and start their schedules past noon regularly.\nAll people who went to Clay's school, who live in California, and attend yoga classes regularly, make their own matcha teas every morning with ceremonial-grade matcha powder.\nAll people who went to Clay's school, and work in the entertainment industry as high-profile celebrities, wake up late and start their schedules past noon regularly.\nAll people who went to Clay's school that do not have regular 9-5 jobs, work in the entertainment industry as high-profile celebrities.\nAll people who went to Clay's school and prefer working at home over going to the office daily do not have regular 9-5 jobs.\nBunny went to Clay's school, and she either prefers to work at home over going to the office and makes her own matcha teas every morning with ceremonial-grade matcha powder, or does not prefer to work at home over going to the office every day and does not make her own matcha teas every morning with ceremonial-grade matcha powder.",
        "premises-FOL": [
            "all x. (GoTo(x, ClaysSchool) & MakeWith(x, TheirOwnMatchTea, CeremonialGradePowder) -> -(WakeUpLate(x) & StartPastNoonRegularly(x, Schedule)))\nall x. (GoTo(x, ClaysSchool) & LiveIn(x, California) & AttendRegularly(x, YogaClass) -> MakeWith(x, OwnMatch, CeremonialGradePowder))\nall x. (GoTo(x, ClaysSchool) & WorkInAs(x, EntertainmentIndustry, HighProfileCelebrity) -> (WakeUpLate(x) & StartPastNoonRegularly(x, Schedule)))\nall x. (GoTo(x, ClaysSchool) & -(Have(x, y) & Regular(y) & NineToFiveJob(y)) -> WorkInAs(x, EntertainmentIndustry, HighProfileCelebrity))\nall x. (GoTo(x, ClaysSchool) & Prefer(x, WorkingAtHome, GoingToTheOffice) -> -(Have(x, y) & Regular(y) & NineToFiveJob(y)))\nGoTo(Bunny, ClaysSchool) & -(((Prefer(Bunny, WorkingAtHome, GoingToTheOffice) & -MakeWith(Bunny, TheirOwnMatchTea, CeremonialGradePowder)) | (-Prefer(Bunny, WorkingAtHome, GoingToTheOffice) & MakeWith(Bunny, TheirOwnMatchTea, CeremonialGradePowder))))"
        ],
        "conclusion": "Bunny does not have a regular 9-5 job.",
        "conclusion-FOL": "Have(Bunny, y) & Regular(y) & NineToFiveJob(y)",
        "label": "ERROR"
    },
    {
        "premises": "All people who went to Clay's school and who make their own matcha teas every morning with ceremonial-grade matcha powder do not wake up late and start their schedules past noon regularly.\nAll people who went to Clay's school, who live in California, and attend yoga classes regularly, make their own matcha teas every morning with ceremonial-grade matcha powder.\nAll people who went to Clay's school, and work in the entertainment industry as high-profile celebrities, wake up late and start their schedules past noon regularly.\nAll people who went to Clay's school that do not have regular 9-5 jobs, work in the entertainment industry as high-profile celebrities.\nAll people who went to Clay's school and prefer working at home over going to the office daily do not have regular 9-5 jobs.\nBunny went to Clay's school, and she either prefers to work at home over going to the office and makes her own matcha teas every morning with ceremonial-grade matcha powder, or does not prefer to work at home over going to the office every day and does not make her own matcha teas every morning with ceremonial-grade matcha powder.",
        "premises-FOL": [
            "all x. (GoTo(x, ClaysSchool) & MakeWith(x, TheirOwnMatchTea, CeremonialGradePowder) -> -(WakeUpLate(x) & StartPastNoonRegularly(x, Schedule)))\nall x. (GoTo(x, ClaysSchool) & LiveIn(x, California) & AttendRegularly(x, YogaClass) -> MakeWith(x, OwnMatch, CeremonialGradePowder))\nall x. (GoTo(x, ClaysSchool) & WorkInAs(x, EntertainmentIndustry, HighProfileCelebrity) -> (WakeUpLate(x) & StartPastNoonRegularly(x, Schedule)))\nall x. (GoTo(x, ClaysSchool) & -(Have(x, y) & Regular(y) & NineToFiveJob(y)) -> WorkInAs(x, EntertainmentIndustry, HighProfileCelebrity))\nall x. (GoTo(x, ClaysSchool) & Prefer(x, WorkingAtHome, GoingToTheOffice) -> -(Have(x, y) & Regular(y) & NineToFiveJob(y)))\nGoTo(Bunny, ClaysSchool) & -(((Prefer(Bunny, WorkingAtHome, GoingToTheOffice) & -MakeWith(Bunny, TheirOwnMatchTea, CeremonialGradePowder)) | (-Prefer(Bunny, WorkingAtHome, GoingToTheOffice) & MakeWith(Bunny, TheirOwnMatchTea, CeremonialGradePowder))))"
        ],
        "conclusion": "Bunny went to Clay's school and she lives in California and attends yoga classes regularly.",
        "conclusion-FOL": "LiveIn(Bunny, California) & AttendRegularly(Bunny, YogaClass)",
        "label": "ERROR"
    },
    {
        "premises": "All people who went to Clay's school and who make their own matcha teas every morning with ceremonial-grade matcha powder do not wake up late and start their schedules past noon regularly.\nAll people who went to Clay's school, who live in California, and attend yoga classes regularly, make their own matcha teas every morning with ceremonial-grade matcha powder.\nAll people who went to Clay's school, and work in the entertainment industry as high-profile celebrities, wake up late and start their schedules past noon regularly.\nAll people who went to Clay's school that do not have regular 9-5 jobs, work in the entertainment industry as high-profile celebrities.\nAll people who went to Clay's school and prefer working at home over going to the office daily do not have regular 9-5 jobs.\nBunny went to Clay's school, and she either prefers to work at home over going to the office and makes her own matcha teas every morning with ceremonial-grade matcha powder, or does not prefer to work at home over going to the office every day and does not make her own matcha teas every morning with ceremonial-grade matcha powder.",
        "premises-FOL": [
            "all x. (GoTo(x, ClaysSchool) & MakeWith(x, TheirOwnMatchTea, CeremonialGradePowder) -> -(WakeUpLate(x) & StartPastNoonRegularly(x, Schedule)))\nall x. (GoTo(x, ClaysSchool) & LiveIn(x, California) & AttendRegularly(x, YogaClass) -> MakeWith(x, OwnMatch, CeremonialGradePowder))\nall x. (GoTo(x, ClaysSchool) & WorkInAs(x, EntertainmentIndustry, HighProfileCelebrity) -> (WakeUpLate(x) & StartPastNoonRegularly(x, Schedule)))\nall x. (GoTo(x, ClaysSchool) & -(Have(x, y) & Regular(y) & NineToFiveJob(y)) -> WorkInAs(x, EntertainmentIndustry, HighProfileCelebrity))\nall x. (GoTo(x, ClaysSchool) & Prefer(x, WorkingAtHome, GoingToTheOffice) -> -(Have(x, y) & Regular(y) & NineToFiveJob(y)))\nGoTo(Bunny, ClaysSchool) & -(((Prefer(Bunny, WorkingAtHome, GoingToTheOffice) & -MakeWith(Bunny, TheirOwnMatchTea, CeremonialGradePowder)) | (-Prefer(Bunny, WorkingAtHome, GoingToTheOffice) & MakeWith(Bunny, TheirOwnMatchTea, CeremonialGradePowder))))"
        ],
        "conclusion": "Bunny went to Clay's school and she neither prefers working at home over going to the office nor lives in California and attends yoga classes regularly.",
        "conclusion-FOL": "-(Prefer(Bunny, WorkingAtHome, GoingToTheOffice) | (LiveIn(Bunny, California) & AttendRegularly(Bunny, YogaClass)))",
        "label": "ERROR"
    },
    {
        "premises": "Thomas Barber was an English professional footballer.\nThomas Barber played in the Football League for Aston Villa.\nThomas Barber played as a halfback and inside left.\nThomas Barber scored the winning goal in the 1913 FA Cup Final.",
        "premises-FOL": [
            "English(ThomasBarber) & ProfessionalFootballer(ThomasBarber)\nPlayedFor(ThomasBarber, AstonVilla) & PlayedIn(AstonVilla,TheFootballLeague)\nPlayedAs(ThomasBarber, HalfBack) & PlayedAs(ThomasBarber, InsideLeft)\nScoredTheWinningGoalIn(ThomasBarber, FacupfinalOneNineOneThree)"
        ],
        "conclusion": "Thomas Barber played in the Football League for Bolton Wanderers",
        "conclusion-FOL": "PlayedFor(ThomasBarber, BoltonWanderers) & PlayedIn(BoltonWanderers,TheFootballLeague)",
        "label": "ERROR"
    },
    {
        "premises": "Thomas Barber was an English professional footballer.\nThomas Barber played in the Football League for Aston Villa.\nThomas Barber played as a halfback and inside left.\nThomas Barber scored the winning goal in the 1913 FA Cup Final.",
        "premises-FOL": [
            "English(ThomasBarber) & ProfessionalFootballer(ThomasBarber)\nPlayedFor(ThomasBarber, AstonVilla) & PlayedIn(AstonVilla,TheFootballLeague)\nPlayedAs(ThomasBarber, HalfBack) & PlayedAs(ThomasBarber, InsideLeft)\nScoredTheWinningGoalIn(ThomasBarber, FacupfinalOneNineOneThree)"
        ],
        "conclusion": "Thomas Barber played as an inside left.",
        "conclusion-FOL": "PlayedAs(ThomasBarber, InsideLeft)",
        "label": "ERROR"
    },
    {
        "premises": "Thomas Barber was an English professional footballer.\nThomas Barber played in the Football League for Aston Villa.\nThomas Barber played as a halfback and inside left.\nThomas Barber scored the winning goal in the 1913 FA Cup Final.",
        "premises-FOL": [
            "English(ThomasBarber) & ProfessionalFootballer(ThomasBarber)\nPlayedFor(ThomasBarber, AstonVilla) & PlayedIn(AstonVilla,TheFootballLeague)\nPlayedAs(ThomasBarber, HalfBack) & PlayedAs(ThomasBarber, InsideLeft)\nScoredTheWinningGoalIn(ThomasBarber, FacupfinalOneNineOneThree)"
        ],
        "conclusion": "An English professional footballer scored the winning goal in the 1913 FA Cup Final.",
        "conclusion-FOL": "exists x. (English(x) & ProfessionalFootballer(x) & ScoredTheWinningGoalIn(x, FacupfinalOneNineOneThree))",
        "label": "ERROR"
    },
    {
        "premises": "If a person plays an instrument in a concert, they are good at playing this kind of instrument.\nPeter plays piano, violin, and saxophone.\nPeter plays piano in a concert.\nOliver and Peter both play instruments in a concert.\nOliver plays a different musical instrument from Peter in the concert.",
        "premises-FOL": [
            "all x. all y. (PlayIn(y, x, Concert) -> GoodAtPlaying(y, x))\nPlay(Peter, Piano) & Play(Peter, Violin) & Play(Peter, Saxophone)\nPlayIn(Peter, Piano, Concert)\nexists x. exists y. (PlayIn(Peter, x, Concert) & PlayIn(Oliver, y, Concert))\nall x. (PlayIn(Oliver, x, Concert) -> -PlayIn(Peter, y, Concert))"
        ],
        "conclusion": "Oliver plays piano in the concert.",
        "conclusion-FOL": "PlayIn(Oliver, Piano, Concert)",
        "label": "ERROR"
    },
    {
        "premises": "If a person plays an instrument in a concert, they are good at playing this kind of instrument.\nPeter plays piano, violin, and saxophone.\nPeter plays piano in a concert.\nOliver and Peter both play instruments in a concert.\nOliver plays a different musical instrument from Peter in the concert.",
        "premises-FOL": [
            "all x. all y. (PlayIn(y, x, Concert) -> GoodAtPlaying(y, x))\nPlay(Peter, Piano) & Play(Peter, Violin) & Play(Peter, Saxophone)\nPlayIn(Peter, Piano, Concert)\nexists x. exists y. (PlayIn(Peter, x, Concert) & PlayIn(Oliver, y, Concert))\nall x. (PlayIn(Oliver, x, Concert) -> -PlayIn(Peter, y, Concert))"
        ],
        "conclusion": "Oliver plays violin in the concert.",
        "conclusion-FOL": "PlayIn(Oliver, Violin, Concert)",
        "label": "ERROR"
    },
    {
        "premises": "If a person plays an instrument in a concert, they are good at playing this kind of instrument.\nPeter plays piano, violin, and saxophone.\nPeter plays piano in a concert.\nOliver and Peter both play instruments in a concert.\nOliver plays a different musical instrument from Peter in the concert.",
        "premises-FOL": [
            "all x. all y. (PlayIn(y, x, Concert) -> GoodAtPlaying(y, x))\nPlay(Peter, Piano) & Play(Peter, Violin) & Play(Peter, Saxophone)\nPlayIn(Peter, Piano, Concert)\nexists x. exists y. (PlayIn(Peter, x, Concert) & PlayIn(Oliver, y, Concert))\nall x. (PlayIn(Oliver, x, Concert) -> -PlayIn(Peter, y, Concert))"
        ],
        "conclusion": "Peter is good at playing piano.",
        "conclusion-FOL": "GoodAtPlaying(Peter, Piano)",
        "label": "ERROR"
    },
    {
        "premises": "Functional brainstems are necessary for breath control.\nAll humans that can swim can control their breath. \nHumans can swim or walk. \nHumans who can walk can stand on the ground by themselves. \nHumans whose brainstems are functional can control their balance.\nEvery human who can stand on the ground by themselves has functional leg muscles. \nGeorge and Archie are humans.\nGeorge can control his balance and can swim.\nArchie can walk if and only if he has functional brainstems.",
        "premises-FOL": [
            "all x. (CanControl(x, Breath) -> FunctionalBrainStem(x))\nall x. (Human(x) & CanSwim(x) -> CanControl(x, Breath))\nall x. (Human(x) -> (CanSwim(x) | CanWalk(x)))\nall x. (Human(x) & CanWalk(x) -> CanStandOnTheGround(x, Themselves))\nall x. (Human(x) & FunctionalBrainStem(x) -> CanControl(x, Balance))\nall x. (Human(x) & CanStandOnTheGround(x, Themselves) -> FunctionalLegMuscle(x)))\nHuman(George) & Human(Archie)\nCanControl(George, Balance) & CanSwim(George)\n-(((CanWalk(Archie) & -FunctionalBrainStem(x)) | (-CanWalk(Archie) & FunctionalBrainStem(x))))\n"
        ],
        "conclusion": "George has functional leg muscles.",
        "conclusion-FOL": "FunctionalLegMuscle(Archie)",
        "label": "ERROR"
    },
    {
        "premises": "Functional brainstems are necessary for breath control.\nAll humans that can swim can control their breath. \nHumans can swim or walk. \nHumans who can walk can stand on the ground by themselves. \nHumans whose brainstems are functional can control their balance.\nEvery human who can stand on the ground by themselves has functional leg muscles. \nGeorge and Archie are humans.\nGeorge can control his balance and can swim.\nArchie can walk if and only if he has functional brainstems.",
        "premises-FOL": [
            "all x. (CanControl(x, Breath) -> FunctionalBrainStem(x))\nall x. (Human(x) & CanSwim(x) -> CanControl(x, Breath))\nall x. (Human(x) -> (CanSwim(x) | CanWalk(x)))\nall x. (Human(x) & CanWalk(x) -> CanStandOnTheGround(x, Themselves))\nall x. (Human(x) & FunctionalBrainStem(x) -> CanControl(x, Balance))\nall x. (Human(x) & CanStandOnTheGround(x, Themselves) -> FunctionalLegMuscle(x)))\nHuman(George) & Human(Archie)\nCanControl(George, Balance) & CanSwim(George)\n-(((CanWalk(Archie) & -FunctionalBrainStem(x)) | (-CanWalk(Archie) & FunctionalBrainStem(x))))\n"
        ],
        "conclusion": "Archie has functional leg muscles and can control his balance.",
        "conclusion-FOL": "FunctionalLegMuscle(Archie) & CanControl(Archie, Balance)",
        "label": "ERROR"
    },
    {
        "premises": "Functional brainstems are necessary for breath control.\nAll humans that can swim can control their breath. \nHumans can swim or walk. \nHumans who can walk can stand on the ground by themselves. \nHumans whose brainstems are functional can control their balance.\nEvery human who can stand on the ground by themselves has functional leg muscles. \nGeorge and Archie are humans.\nGeorge can control his balance and can swim.\nArchie can walk if and only if he has functional brainstems.",
        "premises-FOL": [
            "all x. (CanControl(x, Breath) -> FunctionalBrainStem(x))\nall x. (Human(x) & CanSwim(x) -> CanControl(x, Breath))\nall x. (Human(x) -> (CanSwim(x) | CanWalk(x)))\nall x. (Human(x) & CanWalk(x) -> CanStandOnTheGround(x, Themselves))\nall x. (Human(x) & FunctionalBrainStem(x) -> CanControl(x, Balance))\nall x. (Human(x) & CanStandOnTheGround(x, Themselves) -> FunctionalLegMuscle(x)))\nHuman(George) & Human(Archie)\nCanControl(George, Balance) & CanSwim(George)\n-(((CanWalk(Archie) & -FunctionalBrainStem(x)) | (-CanWalk(Archie) & FunctionalBrainStem(x))))\n"
        ],
        "conclusion": "Archie cannot control his balance and doesn't have functional leg muscles.",
        "conclusion-FOL": "-CanControl(Archie, Balance) & -FunctionalLegMuscle(x)",
        "label": "ERROR"
    },
    {
        "premises": "Cancer biology is finding genetic alterations that confer a selective advantage to cancer cells. \nCancer researchers have frequently ranked the importance of substitutions to cancer growth by the P value.\nP values are thresholds for belief, not metrics of effect. ",
        "premises-FOL": [
            "Finding(CancerBiology, GeneticAlteration) & Confer(GeneticAlteration, SelectiveAdvantage, ToCancerCell)\nexists x. exists y. (CancerResearcher(x) & Ranked(x, ImportanceOfSubstitutionsToCancerGrowth) & PValue(y) & RankedBy(ImportanceOfSubstitutionsToCancerGrowth, y))\nall x. (PValue(x) -> ThresholdForBelief(x) & -MetricOfEffect(x))"
        ],
        "conclusion": "Cancer researchers tend to use the cancer effect size to determine the relative importance of the genetic alterations that confer selective advantage to cancer cells.",
        "conclusion-FOL": "exists x. exists y. (CancerResearcher(x) & Use(x, CancerEffectSize) & UsedToDetermine(CancerEffectSize, RelativeImportanceOfGeneteticAlterations))",
        "label": "ERROR"
    },
    {
        "premises": "Cancer biology is finding genetic alterations that confer a selective advantage to cancer cells. \nCancer researchers have frequently ranked the importance of substitutions to cancer growth by the P value.\nP values are thresholds for belief, not metrics of effect. ",
        "premises-FOL": [
            "Finding(CancerBiology, GeneticAlteration) & Confer(GeneticAlteration, SelectiveAdvantage, ToCancerCell)\nexists x. exists y. (CancerResearcher(x) & Ranked(x, ImportanceOfSubstitutionsToCancerGrowth) & PValue(y) & RankedBy(ImportanceOfSubstitutionsToCancerGrowth, y))\nall x. (PValue(x) -> ThresholdForBelief(x) & -MetricOfEffect(x))"
        ],
        "conclusion": "P value represents the selection intensity for somatic variants in cancer cell lineages.",
        "conclusion-FOL": "SelectionIntensitySomaticVariants(pValue)",
        "label": "ERROR"
    },
    {
        "premises": "Cancer biology is finding genetic alterations that confer a selective advantage to cancer cells. \nCancer researchers have frequently ranked the importance of substitutions to cancer growth by the P value.\nP values are thresholds for belief, not metrics of effect. ",
        "premises-FOL": [
            "Finding(CancerBiology, GeneticAlteration) & Confer(GeneticAlteration, SelectiveAdvantage, ToCancerCell)\nexists x. exists y. (CancerResearcher(x) & Ranked(x, ImportanceOfSubstitutionsToCancerGrowth) & PValue(y) & RankedBy(ImportanceOfSubstitutionsToCancerGrowth, y))\nall x. (PValue(x) -> ThresholdForBelief(x) & -MetricOfEffect(x))"
        ],
        "conclusion": "Cancer effect size is preferred by cancer researchers.",
        "conclusion-FOL": "Preferred(CancerResearchers, CancerEffectSize)",
        "label": "ERROR"
    },
    {
        "premises": "Cancer biology is finding genetic alterations that confer a selective advantage to cancer cells. \nCancer researchers have frequently ranked the importance of substitutions to cancer growth by the P value.\nP values are thresholds for belief, not metrics of effect. ",
        "premises-FOL": [
            "Finding(CancerBiology, GeneticAlteration) & Confer(GeneticAlteration, SelectiveAdvantage, ToCancerCell)\nexists x. exists y. (CancerResearcher(x) & Ranked(x, ImportanceOfSubstitutionsToCancerGrowth) & PValue(y) & RankedBy(ImportanceOfSubstitutionsToCancerGrowth, y))\nall x. (PValue(x) -> ThresholdForBelief(x) & -MetricOfEffect(x))"
        ],
        "conclusion": "P values don't represent metrics of effect.",
        "conclusion-FOL": "all x. (PValue(x) -> -MetricsOfEffect(x))",
        "label": "ERROR"
    },
    {
        "premises": "All biodegradable things are environment-friendly. \nAll woodware is biodegradable.\nAll paper is woodware. \nNothing is a good thing and also a bad thing.\nAll environment-friendly things are good.\nA worksheet is either paper or environment-friendly.",
        "premises-FOL": [
            "all x. (Biodegradable(x) -> EnvironmentFriendly(x))\nall x. (Woodware(x) -> Biodegradable(x))\nall x. (Paper(x) -> Woodware(x))\n-(exists x. (Good(x) & Bad(x)))\nall x. (EnvironmentFriendly(x) -> Good(x))\n((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))"
        ],
        "conclusion": "A worksheet is biodegradable.",
        "conclusion-FOL": "Bioegradable(Worksheet)",
        "label": "ERROR"
    },
    {
        "premises": "All biodegradable things are environment-friendly. \nAll woodware is biodegradable.\nAll paper is woodware. \nNothing is a good thing and also a bad thing.\nAll environment-friendly things are good.\nA worksheet is either paper or environment-friendly.",
        "premises-FOL": [
            "all x. (Biodegradable(x) -> EnvironmentFriendly(x))\nall x. (Woodware(x) -> Biodegradable(x))\nall x. (Paper(x) -> Woodware(x))\n-(exists x. (Good(x) & Bad(x)))\nall x. (EnvironmentFriendly(x) -> Good(x))\n((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))"
        ],
        "conclusion": "A worksheet is not biodegradable.",
        "conclusion-FOL": "-Bioegradable(Worksheet)",
        "label": "ERROR"
    },
    {
        "premises": "All biodegradable things are environment-friendly. \nAll woodware is biodegradable.\nAll paper is woodware. \nNothing is a good thing and also a bad thing.\nAll environment-friendly things are good.\nA worksheet is either paper or environment-friendly.",
        "premises-FOL": [
            "all x. (Biodegradable(x) -> EnvironmentFriendly(x))\nall x. (Woodware(x) -> Biodegradable(x))\nall x. (Paper(x) -> Woodware(x))\n-(exists x. (Good(x) & Bad(x)))\nall x. (EnvironmentFriendly(x) -> Good(x))\n((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))"
        ],
        "conclusion": "A worksheet is bad.",
        "conclusion-FOL": "Bad(Worksheet)",
        "label": "ERROR"
    },
    {
        "premises": "All biodegradable things are environment-friendly. \nAll woodware is biodegradable.\nAll paper is woodware. \nNothing is a good thing and also a bad thing.\nAll environment-friendly things are good.\nA worksheet is either paper or environment-friendly.",
        "premises-FOL": [
            "all x. (Biodegradable(x) -> EnvironmentFriendly(x))\nall x. (Woodware(x) -> Biodegradable(x))\nall x. (Paper(x) -> Woodware(x))\n-(exists x. (Good(x) & Bad(x)))\nall x. (EnvironmentFriendly(x) -> Good(x))\n((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))"
        ],
        "conclusion": "A worksheet is not bad.",
        "conclusion-FOL": "-Bad(Worksheet)",
        "label": "ERROR"
    },
    {
        "premises": "No reptile has fur.\nAll snakes are reptiles.",
        "premises-FOL": [
            "all x. (Reptile(x) -> -Have(x, Fur))\nall x. (Snake(x) -> Reptile(x))"
        ],
        "conclusion": "Some snake has fur.",
        "conclusion-FOL": "exists x. (Snake(x) & Have(x, Fur))",
        "label": "ERROR"
    },
    {
        "premises": "All buildings in New Haven are not high.\nAll buildings managed by Yale Housing are located in New Haven. \nAll buildings in Manhattans are high. \nAll buildings owned by Bloomberg are located in Manhattans. \nAll buildings with the Bloomberg logo are owned by Bloomberg. \nTower A is managed by Yale Housing.\nTower B is with the Bloomberg logo.",
        "premises-FOL": [
            "all x. (In(x, NewHaven) -> -High(x))\nall x. (YaleHousing(x) -> In(x, NewHaven))\nall x. (In(x, Manhattan) -> High(x))\nall x. (Bloomberg(x) -> In(x, Manhattan))\nall x. (BloombergLogo(x) -> Bloomberg(x))\nYaleHousing(Tower-a)\nBloombergLogo(Tower-b)"
        ],
        "conclusion": "Tower A is low.",
        "conclusion-FOL": "-High(Tower-a)",
        "label": "ERROR"
    },
    {
        "premises": "All buildings in New Haven are not high.\nAll buildings managed by Yale Housing are located in New Haven. \nAll buildings in Manhattans are high. \nAll buildings owned by Bloomberg are located in Manhattans. \nAll buildings with the Bloomberg logo are owned by Bloomberg. \nTower A is managed by Yale Housing.\nTower B is with the Bloomberg logo.",
        "premises-FOL": [
            "all x. (In(x, NewHaven) -> -High(x))\nall x. (YaleHousing(x) -> In(x, NewHaven))\nall x. (In(x, Manhattan) -> High(x))\nall x. (Bloomberg(x) -> In(x, Manhattan))\nall x. (BloombergLogo(x) -> Bloomberg(x))\nYaleHousing(Tower-a)\nBloombergLogo(Tower-b)"
        ],
        "conclusion": "Tower B is not located in Manhattans.",
        "conclusion-FOL": "-In(Tower-b, Manhattan)",
        "label": "ERROR"
    },
    {
        "premises": "All buildings in New Haven are not high.\nAll buildings managed by Yale Housing are located in New Haven. \nAll buildings in Manhattans are high. \nAll buildings owned by Bloomberg are located in Manhattans. \nAll buildings with the Bloomberg logo are owned by Bloomberg. \nTower A is managed by Yale Housing.\nTower B is with the Bloomberg logo.",
        "premises-FOL": [
            "all x. (In(x, NewHaven) -> -High(x))\nall x. (YaleHousing(x) -> In(x, NewHaven))\nall x. (In(x, Manhattan) -> High(x))\nall x. (Bloomberg(x) -> In(x, Manhattan))\nall x. (BloombergLogo(x) -> Bloomberg(x))\nYaleHousing(Tower-a)\nBloombergLogo(Tower-b)"
        ],
        "conclusion": "Tower B is located in New Haven.",
        "conclusion-FOL": "-In(Tower-b, NewHaven)",
        "label": "ERROR"
    },
    {
        "premises": "No birds are ectothermic.\nAll penguins are birds.\nAn animal is ectothermic or endothermic.\nAll endothermic animals produce heat within the body.\nRon and Henry are both animals.\nRon is not a bird and does not produce heat with the body. \nHenry is not a cat and does not produce heat with the body. ",
        "premises-FOL": [
            "all x. (Bird(x) -> -Ectothermic(x))\nall x. (Penguin(x) -> Bird(x))\nall x. (Animal(x) -> Ectothermic(x) | Endothermic(x))\nall x. (Endothermic(x) -> ProduceWithIn(x, Heat, Body))\nAnimal(Ron) & Animal(Henry)\n-Bird(Ron) & -ProduceWithIn(Ron, Heat, Body)\n-Cat(Henry) & -ProduceWithIn(Henry, Heat, Body)"
        ],
        "conclusion": "Ron is a cat.",
        "conclusion-FOL": "Cat(Ron)",
        "label": "ERROR"
    },
    {
        "premises": "No birds are ectothermic.\nAll penguins are birds.\nAn animal is ectothermic or endothermic.\nAll endothermic animals produce heat within the body.\nRon and Henry are both animals.\nRon is not a bird and does not produce heat with the body. \nHenry is not a cat and does not produce heat with the body. ",
        "premises-FOL": [
            "all x. (Bird(x) -> -Ectothermic(x))\nall x. (Penguin(x) -> Bird(x))\nall x. (Animal(x) -> Ectothermic(x) | Endothermic(x))\nall x. (Endothermic(x) -> ProduceWithIn(x, Heat, Body))\nAnimal(Ron) & Animal(Henry)\n-Bird(Ron) & -ProduceWithIn(Ron, Heat, Body)\n-Cat(Henry) & -ProduceWithIn(Henry, Heat, Body)"
        ],
        "conclusion": "Either Henry is a penguin or Henry is endothermic.",
        "conclusion-FOL": "((Penguin(Henry) & -Endothermic(Henry)) | (-Penguin(Henry) & Endothermic(Henry)))",
        "label": "ERROR"
    },
    {
        "premises": "No birds are ectothermic.\nAll penguins are birds.\nAn animal is ectothermic or endothermic.\nAll endothermic animals produce heat within the body.\nRon and Henry are both animals.\nRon is not a bird and does not produce heat with the body. \nHenry is not a cat and does not produce heat with the body. ",
        "premises-FOL": [
            "all x. (Bird(x) -> -Ectothermic(x))\nall x. (Penguin(x) -> Bird(x))\nall x. (Animal(x) -> Ectothermic(x) | Endothermic(x))\nall x. (Endothermic(x) -> ProduceWithIn(x, Heat, Body))\nAnimal(Ron) & Animal(Henry)\n-Bird(Ron) & -ProduceWithIn(Ron, Heat, Body)\n-Cat(Henry) & -ProduceWithIn(Henry, Heat, Body)"
        ],
        "conclusion": "Ron is either both a penguin and endothermic, or he is nether.",
        "conclusion-FOL": "-(((Penguin(Ron) & -Endothermic(Henry)) | (-Penguin(Ron) & Endothermic(Henry))))",
        "label": "ERROR"
    },
    {
        "premises": "Ambiortus is a prehistoric bird genus.\nAmbiortus Dementjevi is the only known species of Ambiortus.\nMongolia was where Ambiortus Dementjevi lived.\nYevgeny Kurochkin was the discoverer of Ambiortus.",
        "premises-FOL": [
            "Prehistoric(Ambiortus) & BirdGenus(Ambiortus)\nall x.(KnownSpeciesOf(x, Ambiortus) -> IsSpecies(x, AmbiortusDementjevi))\nLiveIn(AmbiortusDementjevi, Mongolia)\nDiscover(Yevgenykurochkin, Ambiortus)"
        ],
        "conclusion": "Yevgeny Kurochkin discovered a new bird genus.",
        "conclusion-FOL": "exists x. (Discover(Yevgenykurochkin, x) & BirdGenus(x))",
        "label": "ERROR"
    },
    {
        "premises": "Ambiortus is a prehistoric bird genus.\nAmbiortus Dementjevi is the only known species of Ambiortus.\nMongolia was where Ambiortus Dementjevi lived.\nYevgeny Kurochkin was the discoverer of Ambiortus.",
        "premises-FOL": [
            "Prehistoric(Ambiortus) & BirdGenus(Ambiortus)\nall x.(KnownSpeciesOf(x, Ambiortus) -> IsSpecies(x, AmbiortusDementjevi))\nLiveIn(AmbiortusDementjevi, Mongolia)\nDiscover(Yevgenykurochkin, Ambiortus)"
        ],
        "conclusion": "There is a species of Ambiortus that doesn't live in Mongolia.",
        "conclusion-FOL": "exists x. (KnownSpeciesOf(x, Ambiortus) & -LiveIn(x, Mongolia))",
        "label": "ERROR"
    },
    {
        "premises": "Ambiortus is a prehistoric bird genus.\nAmbiortus Dementjevi is the only known species of Ambiortus.\nMongolia was where Ambiortus Dementjevi lived.\nYevgeny Kurochkin was the discoverer of Ambiortus.",
        "premises-FOL": [
            "Prehistoric(Ambiortus) & BirdGenus(Ambiortus)\nall x.(KnownSpeciesOf(x, Ambiortus) -> IsSpecies(x, AmbiortusDementjevi))\nLiveIn(AmbiortusDementjevi, Mongolia)\nDiscover(Yevgenykurochkin, Ambiortus)"
        ],
        "conclusion": "Yevgeny Kurochkin lived in Mongolia.",
        "conclusion-FOL": "LiveIn(Yevgenykurochkin, Mongolia)",
        "label": "ERROR"
    },
    {
        "premises": "Ambiortus is a prehistoric bird genus.\nAmbiortus Dementjevi is the only known species of Ambiortus.\nMongolia was where Ambiortus Dementjevi lived.\nYevgeny Kurochkin was the discoverer of Ambiortus.",
        "premises-FOL": [
            "Prehistoric(Ambiortus) & BirdGenus(Ambiortus)\nall x.(KnownSpeciesOf(x, Ambiortus) -> IsSpecies(x, AmbiortusDementjevi))\nLiveIn(AmbiortusDementjevi, Mongolia)\nDiscover(Yevgenykurochkin, Ambiortus)"
        ],
        "conclusion": "All species of Ambiortus live in Mongolia.",
        "conclusion-FOL": "all x. (SpeciesOf(x, Ambiortus) -> LiveIn(x, Mongolia))",
        "label": "ERROR"
    },
    {
        "premises": "Everyone that knows about breath-first-search knows how to use a queue. \nIf someone is a seasoned software engineer interviewer at Google, then they know what breath-first-search is. \nSomeone is either a seasoned software engineer interviewer at Google, has human rights, or both. \nEvery person who has human rights is entitled to the right to life and liberty. \nEveryone that knows how to use a queue knows about the first-in-first-out data structure. \nEveryone that is entitled to the right to life and liberty cannot be deprived of their rights without due process of law. \nJack is entitled to the right to life and liberty, has human rights, or knows about the first-in-first-out data structure. ",
        "premises-FOL": [
            "all x. (Know(x, BreathFirstSearch) -> Know(x, HowToUseQueue))\nall x. (Seasoned(x) & SoftwareEngineerInterviewer(x) & At(x, Google) -> Know(x, BreathFirstSearch))\nall x. ((Seasoned(x) & SoftwareEngineerInterviewer(x) & At(x, Google)) | Have(x, HumanRights))\nall x. (Have(x, HumanRights) -> EntitledTo(x, RightToLifeAndLiberty))\nall x. (Know(x, HowToUseQueue) -> Know(x, FirstInFirstOutDataStructure))\nall x. (EntitledTo(x, RightToLifeAndLiberty) -> -DeprivedOfWithout(x, Rights, DueProcessOfLaw))\n(EntitledTo(Jack, RightToLifeAndLiberty) | Have(Jack, HumanRights) | Know(Jack, FirstInFirstOutDataStructure))"
        ],
        "conclusion": "Jack is a seasoned software engineer interviewer.",
        "conclusion-FOL": "Seasoned(Jack) & SoftwareEngineerInterviewer(Jack) & At(Jack, Google)",
        "label": "ERROR"
    },
    {
        "premises": "Everyone that knows about breath-first-search knows how to use a queue. \nIf someone is a seasoned software engineer interviewer at Google, then they know what breath-first-search is. \nSomeone is either a seasoned software engineer interviewer at Google, has human rights, or both. \nEvery person who has human rights is entitled to the right to life and liberty. \nEveryone that knows how to use a queue knows about the first-in-first-out data structure. \nEveryone that is entitled to the right to life and liberty cannot be deprived of their rights without due process of law. \nJack is entitled to the right to life and liberty, has human rights, or knows about the first-in-first-out data structure. ",
        "premises-FOL": [
            "all x. (Know(x, BreathFirstSearch) -> Know(x, HowToUseQueue))\nall x. (Seasoned(x) & SoftwareEngineerInterviewer(x) & At(x, Google) -> Know(x, BreathFirstSearch))\nall x. ((Seasoned(x) & SoftwareEngineerInterviewer(x) & At(x, Google)) | Have(x, HumanRights))\nall x. (Have(x, HumanRights) -> EntitledTo(x, RightToLifeAndLiberty))\nall x. (Know(x, HowToUseQueue) -> Know(x, FirstInFirstOutDataStructure))\nall x. (EntitledTo(x, RightToLifeAndLiberty) -> -DeprivedOfWithout(x, Rights, DueProcessOfLaw))\n(EntitledTo(Jack, RightToLifeAndLiberty) | Have(Jack, HumanRights) | Know(Jack, FirstInFirstOutDataStructure))"
        ],
        "conclusion": "Jack cannot be deprived of their rights without due process of law.",
        "conclusion-FOL": "-DeprivedOfWithout(Jack, Rights, DueProcessOfLaw)",
        "label": "ERROR"
    },
    {
        "premises": "Everyone that knows about breath-first-search knows how to use a queue. \nIf someone is a seasoned software engineer interviewer at Google, then they know what breath-first-search is. \nSomeone is either a seasoned software engineer interviewer at Google, has human rights, or both. \nEvery person who has human rights is entitled to the right to life and liberty. \nEveryone that knows how to use a queue knows about the first-in-first-out data structure. \nEveryone that is entitled to the right to life and liberty cannot be deprived of their rights without due process of law. \nJack is entitled to the right to life and liberty, has human rights, or knows about the first-in-first-out data structure. ",
        "premises-FOL": [
            "all x. (Know(x, BreathFirstSearch) -> Know(x, HowToUseQueue))\nall x. (Seasoned(x) & SoftwareEngineerInterviewer(x) & At(x, Google) -> Know(x, BreathFirstSearch))\nall x. ((Seasoned(x) & SoftwareEngineerInterviewer(x) & At(x, Google)) | Have(x, HumanRights))\nall x. (Have(x, HumanRights) -> EntitledTo(x, RightToLifeAndLiberty))\nall x. (Know(x, HowToUseQueue) -> Know(x, FirstInFirstOutDataStructure))\nall x. (EntitledTo(x, RightToLifeAndLiberty) -> -DeprivedOfWithout(x, Rights, DueProcessOfLaw))\n(EntitledTo(Jack, RightToLifeAndLiberty) | Have(Jack, HumanRights) | Know(Jack, FirstInFirstOutDataStructure))"
        ],
        "conclusion": "Jack can be deprived of their rights without due process of law.",
        "conclusion-FOL": "DeprivedOfWithout(Jack, Rights, DueProcessOfLaw)",
        "label": "ERROR"
    },
    {
        "premises": "Fort Ticonderoga is the current name for Fort Carillon.\nPierre de Rigaud de Vaudreuil built Fort Carillon.\nFort Carillon was located in New France.\nNew France is not in Europe.",
        "premises-FOL": [
            "RenamedAs(FortCarillon, FortTiconderoga)\nBuilt(PierredeRigauddeVaudreuil, FortCarillon)\nLocatedIn(FortCarillon, NewFrance)\n-LocatedIn(NewFrance, Europe) "
        ],
        "conclusion": "Pierre de Rigaud de Vaudreuil built a fort in New France.",
        "conclusion-FOL": "exists x. (Built(PierredeRigauddeVaudreuil, x) & LocatedIn(x, NewFrance))",
        "label": "ERROR"
    },
    {
        "premises": "Fort Ticonderoga is the current name for Fort Carillon.\nPierre de Rigaud de Vaudreuil built Fort Carillon.\nFort Carillon was located in New France.\nNew France is not in Europe.",
        "premises-FOL": [
            "RenamedAs(FortCarillon, FortTiconderoga)\nBuilt(PierredeRigauddeVaudreuil, FortCarillon)\nLocatedIn(FortCarillon, NewFrance)\n-LocatedIn(NewFrance, Europe) "
        ],
        "conclusion": "Pierre de Rigaud de Vaudreuil built a fort in New England.",
        "conclusion-FOL": "exists x. (Built(PierredeRigauddeVaudreuil, x) & LocatedIn(x, NewEngland))",
        "label": "ERROR"
    },
    {
        "premises": "Fort Ticonderoga is the current name for Fort Carillon.\nPierre de Rigaud de Vaudreuil built Fort Carillon.\nFort Carillon was located in New France.\nNew France is not in Europe.",
        "premises-FOL": [
            "RenamedAs(FortCarillon, FortTiconderoga)\nBuilt(PierredeRigauddeVaudreuil, FortCarillon)\nLocatedIn(FortCarillon, NewFrance)\n-LocatedIn(NewFrance, Europe) "
        ],
        "conclusion": "Fort Carillon was located in Europe.",
        "conclusion-FOL": "LocatedIn(FortCarillon, Europe)",
        "label": "ERROR"
    },
    {
        "premises": "No soccer players are professional basketball players.\nAll NBA players are professional basketball players.\nAll soccer defenders are soccer players.\nAll centerback players are soccer defenders.\nIf Stephen Curry is an NBA player or a soccer player, then he is a professional basketball player.",
        "premises-FOL": [
            "all x. (ProfessionalSoccerPlayer(x) -> -ProfessionalBasketballPlayer(x))\nall x. (NBAPlayer(x) -> ProfessionalBasketballPlayer(x))\nall x. (ProfessionalSoccerDefender(x) -> ProfessionalSoccerPlayer(x))\nall x. (ProfessionalCenterback(x) -> ProfessionalSoccerDefender(x))\n(((NBAPlayer(Stephencurry) & -ProfessionalSoccerPlayer(Stephencurry)) | (-NBAPlayer(Stephencurry) & ProfessionalSoccerPlayer(Stephencurry)))) -> ProfessionalBasketballPlayer(Stephencurry)"
        ],
        "conclusion": "Stephen Curry is an NBA player.",
        "conclusion-FOL": "NBAPlayer(StephenCurry)",
        "label": "ERROR"
    },
    {
        "premises": "No soccer players are professional basketball players.\nAll NBA players are professional basketball players.\nAll soccer defenders are soccer players.\nAll centerback players are soccer defenders.\nIf Stephen Curry is an NBA player or a soccer player, then he is a professional basketball player.",
        "premises-FOL": [
            "all x. (ProfessionalSoccerPlayer(x) -> -ProfessionalBasketballPlayer(x))\nall x. (NBAPlayer(x) -> ProfessionalBasketballPlayer(x))\nall x. (ProfessionalSoccerDefender(x) -> ProfessionalSoccerPlayer(x))\nall x. (ProfessionalCenterback(x) -> ProfessionalSoccerDefender(x))\n(((NBAPlayer(Stephencurry) & -ProfessionalSoccerPlayer(Stephencurry)) | (-NBAPlayer(Stephencurry) & ProfessionalSoccerPlayer(Stephencurry)))) -> ProfessionalBasketballPlayer(Stephencurry)"
        ],
        "conclusion": "Stephen Curry is a centerback player.",
        "conclusion-FOL": "ProfessionalCenterback(StephenCurry)",
        "label": "ERROR"
    },
    {
        "premises": "No soccer players are professional basketball players.\nAll NBA players are professional basketball players.\nAll soccer defenders are soccer players.\nAll centerback players are soccer defenders.\nIf Stephen Curry is an NBA player or a soccer player, then he is a professional basketball player.",
        "premises-FOL": [
            "all x. (ProfessionalSoccerPlayer(x) -> -ProfessionalBasketballPlayer(x))\nall x. (NBAPlayer(x) -> ProfessionalBasketballPlayer(x))\nall x. (ProfessionalSoccerDefender(x) -> ProfessionalSoccerPlayer(x))\nall x. (ProfessionalCenterback(x) -> ProfessionalSoccerDefender(x))\n(((NBAPlayer(Stephencurry) & -ProfessionalSoccerPlayer(Stephencurry)) | (-NBAPlayer(Stephencurry) & ProfessionalSoccerPlayer(Stephencurry)))) -> ProfessionalBasketballPlayer(Stephencurry)"
        ],
        "conclusion": "Stephen Curry is not a centerback player.",
        "conclusion-FOL": "-ProfessionalCenterback(StephenCurry)",
        "label": "ERROR"
    },
    {
        "premises": "No songs are visuals. \nAll folk songs are songs. \nAll videos are visuals. \nAll movies are videos.\nAll sci-fi movies are movies.\nInception is a sci-fi movie.\nMac is neither a folk song nor a sci-fi movie.",
        "premises-FOL": [
            "all x. (Song(x) -> -Visual(x))\nall x. (FolkSong(x) -> Song(x))\nall x. (Video(x) -> Visual(x))\nall x. (Movie(x) -> Video(x))\nall x. (ScifiMovie(x) -> Movie(x))\nScifiMovie(Inception)\n-FolkSong(Mac) & -ScifiMovie(Mac)"
        ],
        "conclusion": "Inception is a folk song.",
        "conclusion-FOL": "FolkSong(Inception)",
        "label": "ERROR"
    },
    {
        "premises": "No songs are visuals. \nAll folk songs are songs. \nAll videos are visuals. \nAll movies are videos.\nAll sci-fi movies are movies.\nInception is a sci-fi movie.\nMac is neither a folk song nor a sci-fi movie.",
        "premises-FOL": [
            "all x. (Song(x) -> -Visual(x))\nall x. (FolkSong(x) -> Song(x))\nall x. (Video(x) -> Visual(x))\nall x. (Movie(x) -> Video(x))\nall x. (ScifiMovie(x) -> Movie(x))\nScifiMovie(Inception)\n-FolkSong(Mac) & -ScifiMovie(Mac)"
        ],
        "conclusion": "Inception is not a folk song.",
        "conclusion-FOL": "-FolkSong(Inception)",
        "label": "ERROR"
    },
    {
        "premises": "No songs are visuals. \nAll folk songs are songs. \nAll videos are visuals. \nAll movies are videos.\nAll sci-fi movies are movies.\nInception is a sci-fi movie.\nMac is neither a folk song nor a sci-fi movie.",
        "premises-FOL": [
            "all x. (Song(x) -> -Visual(x))\nall x. (FolkSong(x) -> Song(x))\nall x. (Video(x) -> Visual(x))\nall x. (Movie(x) -> Video(x))\nall x. (ScifiMovie(x) -> Movie(x))\nScifiMovie(Inception)\n-FolkSong(Mac) & -ScifiMovie(Mac)"
        ],
        "conclusion": "Inception is either a video or a folk song.",
        "conclusion-FOL": "((Video(Inception) & -FolkSong(Inception)) | (-Video(Inception) & FolkSong(Inception)))",
        "label": "ERROR"
    },
    {
        "premises": "No songs are visuals. \nAll folk songs are songs. \nAll videos are visuals. \nAll movies are videos.\nAll sci-fi movies are movies.\nInception is a sci-fi movie.\nMac is neither a folk song nor a sci-fi movie.",
        "premises-FOL": [
            "all x. (Song(x) -> -Visual(x))\nall x. (FolkSong(x) -> Song(x))\nall x. (Video(x) -> Visual(x))\nall x. (Movie(x) -> Video(x))\nall x. (ScifiMovie(x) -> Movie(x))\nScifiMovie(Inception)\n-FolkSong(Mac) & -ScifiMovie(Mac)"
        ],
        "conclusion": "Mac is a video.",
        "conclusion-FOL": "Video(Mac)",
        "label": "ERROR"
    },
    {
        "premises": "All inductive reasoning processes derive general principles from a body of observations.\nTwo major types of reasoning rules are inductive reasoning and deductive reasoning. \nAll deductive reasoning processes are only based on facts and rules. \nNothing only based on facts and rules is used for statistical generalization. \nModus Ponens is not both used in inductive reasoning and used for statistical generalization. \nModus Ponens is a component of a major part of reasoning rule. ",
        "premises-FOL": [
            "all x. (InductiveReasoning(x) -> DeriveFrom(GeneralPrinciple, Observations))\nall x. (MajorArgumentForm(x) -> (((InductiveReasoning(x) & -DeductiveReasoning(x)) | (-InductiveReasoning(x) & DeductiveReasoning(x))))\nall x. (DeductiveReasoning(x) -> (BasedOn(x, Fact) | BasedOn(x, Rule)))\nall x. ((BasedOn(x, Fact) | BasedOn(x, Rule)) -> (-UsedFor(x, StatisticalGeneralization)))\n-(InductiveReasoning(ModusPonens) & UsedFor(ModusPonens, StatisticalGeneralization))\nArgumentForm(ModusPonens)"
        ],
        "conclusion": "Reasoning with Modus Ponens is based on facts and rules.",
        "conclusion-FOL": "BasedOn(x, Fact) | BasedOn(x, Rule)",
        "label": "ERROR"
    },
    {
        "premises": "All inductive reasoning processes derive general principles from a body of observations.\nTwo major types of reasoning rules are inductive reasoning and deductive reasoning. \nAll deductive reasoning processes are only based on facts and rules. \nNothing only based on facts and rules is used for statistical generalization. \nModus Ponens is not both used in inductive reasoning and used for statistical generalization. \nModus Ponens is a component of a major part of reasoning rule. ",
        "premises-FOL": [
            "all x. (InductiveReasoning(x) -> DeriveFrom(GeneralPrinciple, Observations))\nall x. (MajorArgumentForm(x) -> (((InductiveReasoning(x) & -DeductiveReasoning(x)) | (-InductiveReasoning(x) & DeductiveReasoning(x))))\nall x. (DeductiveReasoning(x) -> (BasedOn(x, Fact) | BasedOn(x, Rule)))\nall x. ((BasedOn(x, Fact) | BasedOn(x, Rule)) -> (-UsedFor(x, StatisticalGeneralization)))\n-(InductiveReasoning(ModusPonens) & UsedFor(ModusPonens, StatisticalGeneralization))\nArgumentForm(ModusPonens)"
        ],
        "conclusion": "Modus Ponens derives general principles from a body of observations and is used for statistical generalization.",
        "conclusion-FOL": "DeriveFrom(GeneralPrinciple, Observations) & UsedFor(x, StatisticalGeneralization)",
        "label": "ERROR"
    },
    {
        "premises": "All inductive reasoning processes derive general principles from a body of observations.\nTwo major types of reasoning rules are inductive reasoning and deductive reasoning. \nAll deductive reasoning processes are only based on facts and rules. \nNothing only based on facts and rules is used for statistical generalization. \nModus Ponens is not both used in inductive reasoning and used for statistical generalization. \nModus Ponens is a component of a major part of reasoning rule. ",
        "premises-FOL": [
            "all x. (InductiveReasoning(x) -> DeriveFrom(GeneralPrinciple, Observations))\nall x. (MajorArgumentForm(x) -> (((InductiveReasoning(x) & -DeductiveReasoning(x)) | (-InductiveReasoning(x) & DeductiveReasoning(x))))\nall x. (DeductiveReasoning(x) -> (BasedOn(x, Fact) | BasedOn(x, Rule)))\nall x. ((BasedOn(x, Fact) | BasedOn(x, Rule)) -> (-UsedFor(x, StatisticalGeneralization)))\n-(InductiveReasoning(ModusPonens) & UsedFor(ModusPonens, StatisticalGeneralization))\nArgumentForm(ModusPonens)"
        ],
        "conclusion": "If Modus Ponens either derives general principles from a body of observations and is used for statistical generalization, or neither, then Modus Ponens is is neither used in inductive reasoning  nor used for statistical generalization.",
        "conclusion-FOL": "-(((Derive(GeneralPrinciple, Observations) & -UsedFor(x, StatisticalGeneralization)) | (-Derive(GeneralPrinciple, Observations) & UsedFor(x, StatisticalGeneralization)))) -> (-InductiveReasoning(ModusPonens) & (-UsedFor(ModusPonens, StatisticalGeneralization)))",
        "label": "ERROR"
    },
    {
        "premises": "No trick-shot artist in Yale's varsity team struggles with half court shots.\nEveryone on Yale's varsity team is someone who struggles with half court shots or who successfully shoots a high percentage of 3-pointers.  \nEveryone on Yale's varsity team who successfully shoots a high percentage of 3-pointers is solid at shooting 2-pointers.  \nNo one on Yale's varsity team who is solid at shooting 2-pointers is bad at mid-range shots.  \nJack is on Yale's varsity team, and he is either a trick-shot artist or he successfully shoots a high percentage of 3-pointers.",
        "premises-FOL": [
            "all x. ((In(x, YaleSVarsityTeam) & TrickShotArtist(x)) -> -StruggleAt(x, HalfCourtShot))\nall x. (In(x, YaleSVarsityTeam) -> (StruggleAt(x, HalfCourtShot) | GoodAt(x, Threes)))\nall x. ((In(x, YaleSVarsityTeam) & GoodAt(x, Threes)) -> GoodAt(x, Twos))\nall x. ((In(x, YaleSVarsityTeam) & GoodAt(x, Twos)) -> BadAt(x, MidRangeShot))\nIn(Jack, YaleSVarsityTeam) & (TrickShotArtist(Jack) \u2295  GoodAt(Jack, Threes))"
        ],
        "conclusion": "Jack struggles at half court shots.",
        "conclusion-FOL": "StruggleAt(Jack, HalfCourtShot)",
        "label": "ERROR"
    },
    {
        "premises": "No trick-shot artist in Yale's varsity team struggles with half court shots.\nEveryone on Yale's varsity team is someone who struggles with half court shots or who successfully shoots a high percentage of 3-pointers.  \nEveryone on Yale's varsity team who successfully shoots a high percentage of 3-pointers is solid at shooting 2-pointers.  \nNo one on Yale's varsity team who is solid at shooting 2-pointers is bad at mid-range shots.  \nJack is on Yale's varsity team, and he is either a trick-shot artist or he successfully shoots a high percentage of 3-pointers.",
        "premises-FOL": [
            "all x. ((In(x, YaleSVarsityTeam) & TrickShotArtist(x)) -> -StruggleAt(x, HalfCourtShot))\nall x. (In(x, YaleSVarsityTeam) -> (StruggleAt(x, HalfCourtShot) | GoodAt(x, Threes)))\nall x. ((In(x, YaleSVarsityTeam) & GoodAt(x, Threes)) -> GoodAt(x, Twos))\nall x. ((In(x, YaleSVarsityTeam) & GoodAt(x, Twos)) -> BadAt(x, MidRangeShot))\nIn(Jack, YaleSVarsityTeam) & (TrickShotArtist(Jack) \u2295  GoodAt(Jack, Threes))"
        ],
        "conclusion": "Jack is bad at mid-range shots.",
        "conclusion-FOL": "BadAt(Jack, MidRangeShot)",
        "label": "ERROR"
    },
    {
        "premises": "No trick-shot artist in Yale's varsity team struggles with half court shots.\nEveryone on Yale's varsity team is someone who struggles with half court shots or who successfully shoots a high percentage of 3-pointers.  \nEveryone on Yale's varsity team who successfully shoots a high percentage of 3-pointers is solid at shooting 2-pointers.  \nNo one on Yale's varsity team who is solid at shooting 2-pointers is bad at mid-range shots.  \nJack is on Yale's varsity team, and he is either a trick-shot artist or he successfully shoots a high percentage of 3-pointers.",
        "premises-FOL": [
            "all x. ((In(x, YaleSVarsityTeam) & TrickShotArtist(x)) -> -StruggleAt(x, HalfCourtShot))\nall x. (In(x, YaleSVarsityTeam) -> (StruggleAt(x, HalfCourtShot) | GoodAt(x, Threes)))\nall x. ((In(x, YaleSVarsityTeam) & GoodAt(x, Threes)) -> GoodAt(x, Twos))\nall x. ((In(x, YaleSVarsityTeam) & GoodAt(x, Twos)) -> BadAt(x, MidRangeShot))\nIn(Jack, YaleSVarsityTeam) & (TrickShotArtist(Jack) \u2295  GoodAt(Jack, Threes))"
        ],
        "conclusion": "Jack is solid at shooting 2-pointers or bad at mid-range shots.",
        "conclusion-FOL": "GoodAt(Jack, Twos) | BadAt(Jack, MidRangeShot)",
        "label": "ERROR"
    },
    {
        "premises": "No trick-shot artist in Yale's varsity team struggles with half court shots.\nEveryone on Yale's varsity team is someone who struggles with half court shots or who successfully shoots a high percentage of 3-pointers.  \nEveryone on Yale's varsity team who successfully shoots a high percentage of 3-pointers is solid at shooting 2-pointers.  \nNo one on Yale's varsity team who is solid at shooting 2-pointers is bad at mid-range shots.  \nJack is on Yale's varsity team, and he is either a trick-shot artist or he successfully shoots a high percentage of 3-pointers.",
        "premises-FOL": [
            "all x. ((In(x, YaleSVarsityTeam) & TrickShotArtist(x)) -> -StruggleAt(x, HalfCourtShot))\nall x. (In(x, YaleSVarsityTeam) -> (StruggleAt(x, HalfCourtShot) | GoodAt(x, Threes)))\nall x. ((In(x, YaleSVarsityTeam) & GoodAt(x, Threes)) -> GoodAt(x, Twos))\nall x. ((In(x, YaleSVarsityTeam) & GoodAt(x, Twos)) -> BadAt(x, MidRangeShot))\nIn(Jack, YaleSVarsityTeam) & (TrickShotArtist(Jack) \u2295  GoodAt(Jack, Threes))"
        ],
        "conclusion": "Jack is either solid at shooting 2-pointers or bad at mid-range shots.",
        "conclusion-FOL": "((GoodAt(Jack, Twos) & -BadAt(Jack, MidRangeShot)) | (-GoodAt(Jack, Twos) & BadAt(Jack, MidRangeShot)))",
        "label": "ERROR"
    },
    {
        "premises": "No trick-shot artist in Yale's varsity team struggles with half court shots.\nEveryone on Yale's varsity team is someone who struggles with half court shots or who successfully shoots a high percentage of 3-pointers.  \nEveryone on Yale's varsity team who successfully shoots a high percentage of 3-pointers is solid at shooting 2-pointers.  \nNo one on Yale's varsity team who is solid at shooting 2-pointers is bad at mid-range shots.  \nJack is on Yale's varsity team, and he is either a trick-shot artist or he successfully shoots a high percentage of 3-pointers.",
        "premises-FOL": [
            "all x. ((In(x, YaleSVarsityTeam) & TrickShotArtist(x)) -> -StruggleAt(x, HalfCourtShot))\nall x. (In(x, YaleSVarsityTeam) -> (StruggleAt(x, HalfCourtShot) | GoodAt(x, Threes)))\nall x. ((In(x, YaleSVarsityTeam) & GoodAt(x, Threes)) -> GoodAt(x, Twos))\nall x. ((In(x, YaleSVarsityTeam) & GoodAt(x, Twos)) -> BadAt(x, MidRangeShot))\nIn(Jack, YaleSVarsityTeam) & (TrickShotArtist(Jack) \u2295  GoodAt(Jack, Threes))"
        ],
        "conclusion": "Jack is a trick-shot artist or bad at mid-range shots.",
        "conclusion-FOL": "TrickShotArtist(Jack) | BadAt(Jack, MidRangeShot))",
        "label": "ERROR"
    },
    {
        "premises": "No trick-shot artist in Yale's varsity team struggles with half court shots.\nEveryone on Yale's varsity team is someone who struggles with half court shots or who successfully shoots a high percentage of 3-pointers.  \nEveryone on Yale's varsity team who successfully shoots a high percentage of 3-pointers is solid at shooting 2-pointers.  \nNo one on Yale's varsity team who is solid at shooting 2-pointers is bad at mid-range shots.  \nJack is on Yale's varsity team, and he is either a trick-shot artist or he successfully shoots a high percentage of 3-pointers.",
        "premises-FOL": [
            "all x. ((In(x, YaleSVarsityTeam) & TrickShotArtist(x)) -> -StruggleAt(x, HalfCourtShot))\nall x. (In(x, YaleSVarsityTeam) -> (StruggleAt(x, HalfCourtShot) | GoodAt(x, Threes)))\nall x. ((In(x, YaleSVarsityTeam) & GoodAt(x, Threes)) -> GoodAt(x, Twos))\nall x. ((In(x, YaleSVarsityTeam) & GoodAt(x, Twos)) -> BadAt(x, MidRangeShot))\nIn(Jack, YaleSVarsityTeam) & (TrickShotArtist(Jack) \u2295  GoodAt(Jack, Threes))"
        ],
        "conclusion": "Jack is either a trick-shot artist or bad at mid-range shots.",
        "conclusion-FOL": "((TrickShotArtist(Jack) & -BadAt(Jack, MidRangeShots)) | (-TrickShotArtist(Jack) & BadAt(Jack, MidRangeShots)))",
        "label": "ERROR"
    },
    {
        "premises": "No trick-shot artist in Yale's varsity team struggles with half court shots.\nEveryone on Yale's varsity team is someone who struggles with half court shots or who successfully shoots a high percentage of 3-pointers.  \nEveryone on Yale's varsity team who successfully shoots a high percentage of 3-pointers is solid at shooting 2-pointers.  \nNo one on Yale's varsity team who is solid at shooting 2-pointers is bad at mid-range shots.  \nJack is on Yale's varsity team, and he is either a trick-shot artist or he successfully shoots a high percentage of 3-pointers.",
        "premises-FOL": [
            "all x. ((In(x, YaleSVarsityTeam) & TrickShotArtist(x)) -> -StruggleAt(x, HalfCourtShot))\nall x. (In(x, YaleSVarsityTeam) -> (StruggleAt(x, HalfCourtShot) | GoodAt(x, Threes)))\nall x. ((In(x, YaleSVarsityTeam) & GoodAt(x, Threes)) -> GoodAt(x, Twos))\nall x. ((In(x, YaleSVarsityTeam) & GoodAt(x, Twos)) -> BadAt(x, MidRangeShot))\nIn(Jack, YaleSVarsityTeam) & (TrickShotArtist(Jack) \u2295  GoodAt(Jack, Threes))"
        ],
        "conclusion": "Jack is either a player who successfully shoots a high percentage of 3-pointers or is bad at mid-range shots.",
        "conclusion-FOL": "((GoodAt(Jack, Threes) & -BadAt(Jack, MidRangeShot)) | (-GoodAt(Jack, Threes) & BadAt(Jack, MidRangeShot)))",
        "label": "ERROR"
    },
    {
        "premises": "No trick-shot artist in Yale's varsity team struggles with half court shots.\nEveryone on Yale's varsity team is someone who struggles with half court shots or who successfully shoots a high percentage of 3-pointers.  \nEveryone on Yale's varsity team who successfully shoots a high percentage of 3-pointers is solid at shooting 2-pointers.  \nNo one on Yale's varsity team who is solid at shooting 2-pointers is bad at mid-range shots.  \nJack is on Yale's varsity team, and he is either a trick-shot artist or he successfully shoots a high percentage of 3-pointers.",
        "premises-FOL": [
            "all x. ((In(x, YaleSVarsityTeam) & TrickShotArtist(x)) -> -StruggleAt(x, HalfCourtShot))\nall x. (In(x, YaleSVarsityTeam) -> (StruggleAt(x, HalfCourtShot) | GoodAt(x, Threes)))\nall x. ((In(x, YaleSVarsityTeam) & GoodAt(x, Threes)) -> GoodAt(x, Twos))\nall x. ((In(x, YaleSVarsityTeam) & GoodAt(x, Twos)) -> BadAt(x, MidRangeShot))\nIn(Jack, YaleSVarsityTeam) & (TrickShotArtist(Jack) \u2295  GoodAt(Jack, Threes))"
        ],
        "conclusion": "If Jack is not solid at shooting 2-pointers and bad at mid-range shots, then Jack is not solid at shooting 2-pointers and is a player who successfully shoots a high percentage of 3-pointers.",
        "conclusion-FOL": "BadAt(Jack, MidRangeShot) & GoodAt(Jack, Twos) -> -GoodAt(Jack, Twos) & GoodAt(Jack, Threes)",
        "label": "ERROR"
    },
    {
        "premises": "No trick-shot artist in Yale's varsity team struggles with half court shots.\nEveryone on Yale's varsity team is someone who struggles with half court shots or who successfully shoots a high percentage of 3-pointers.  \nEveryone on Yale's varsity team who successfully shoots a high percentage of 3-pointers is solid at shooting 2-pointers.  \nNo one on Yale's varsity team who is solid at shooting 2-pointers is bad at mid-range shots.  \nJack is on Yale's varsity team, and he is either a trick-shot artist or he successfully shoots a high percentage of 3-pointers.",
        "premises-FOL": [
            "all x. ((In(x, YaleSVarsityTeam) & TrickShotArtist(x)) -> -StruggleAt(x, HalfCourtShot))\nall x. (In(x, YaleSVarsityTeam) -> (StruggleAt(x, HalfCourtShot) | GoodAt(x, Threes)))\nall x. ((In(x, YaleSVarsityTeam) & GoodAt(x, Threes)) -> GoodAt(x, Twos))\nall x. ((In(x, YaleSVarsityTeam) & GoodAt(x, Twos)) -> BadAt(x, MidRangeShot))\nIn(Jack, YaleSVarsityTeam) & (TrickShotArtist(Jack) \u2295  GoodAt(Jack, Threes))"
        ],
        "conclusion": "If Jack is solid at shooting 2-pointers or successfully shoots a high percentage of 3-pointers, then Jack struggles at half court shots and is bad at mid-range shots.",
        "conclusion-FOL": "GoodAt(Jack, Twos) | GoodAt(Jack, Threes) -> BadAt(Jack, HalfCourtShot) & BadAt(Jack, MidRangeShot)",
        "label": "ERROR"
    },
    {
        "premises": "No plants are fungi.\nMushrooms are fungi.",
        "premises-FOL": [
            "all x. (Plant(x) -> -Fungi(x))\nall x. (Mushroom(x) -> Fungi(x))"
        ],
        "conclusion": "No plants are mushrooms.",
        "conclusion-FOL": "all x. (Plant(x) -> -Mushroom(x))",
        "label": "ERROR"
    },
    {
        "premises": "No road is dustless.\nSome streets are roads.",
        "premises-FOL": [
            "all x. (Road(x) -> -Dustless(x))\nexists x. exists y. (Street(x) & Street(y) & Road(x) & Road(y) & -(x=y))"
        ],
        "conclusion": "Some streets are dustless.",
        "conclusion-FOL": "exists x. exists y. (Street(x) & Street(y) & Dustless(x) & Dustless(y) & -(x=y))",
        "label": "ERROR"
    },
    {
        "premises": "New York City is located on the East Coast. \nSeattle is located on the West Coast. \nIf a person is somewhere located on the East coast and is traveling to somewhere located on the west coast, they will be on a long flight.\nPeople in business class from New York City to Seattle are not in first class.\nPeople on long flights are uncomfortable unless they're in first class.",
        "premises-FOL": [
            "LocatedOn(NewYorkCity, EastCoast)\nLocatedOn(Seattle, WestCoast)\nall x. all y. all z. ((TravelingFrom(x, y) & LocatedOn(y, Eastcoast) & TravelingTo(x, z) & LocatedOn(z, Westcoast)) -> OnLongFlight(x))\nall x. (InBuisnessClass(x) & TravelingTo(x, Seattle) & TravelingFrom(x, NewYorkCity) -> -InFirstClass(x))\nall x. (OnLongFlight(x) & -InFirstClass(x) -> Uncomfortable(x))"
        ],
        "conclusion": "People traveling in business class from New York City to Seattle will be uncomfortable.",
        "conclusion-FOL": "exists x. (TravelingTo(x, Seattle) & TravelingFrom(x, NewYorkCity) & Uncomfortable(x))",
        "label": "ERROR"
    },
    {
        "premises": "Musicians have very busy lives.\nSingh Kaur is a musician and famous.\nIf a musician is not famous, that musician will not make a lot of money.\nA musician can be a singer or a writer.",
        "premises-FOL": [
            "all x. (Musician(x) -> Have(x, BusyLife))\nMusician(SinghKaur) & Famous(SinghKaur)\nall x. (Musician(x) & -Famous(x) -> -MakeALotOfMoney(x))\nexists x. (Musician(x) & (Singer(x) | Writer(x)))"
        ],
        "conclusion": "Singh Kaur makes a lot of money.",
        "conclusion-FOL": "MakeALotOfMoney(SinghKaur)",
        "label": "ERROR"
    },
    {
        "premises": "Musicians have very busy lives.\nSingh Kaur is a musician and famous.\nIf a musician is not famous, that musician will not make a lot of money.\nA musician can be a singer or a writer.",
        "premises-FOL": [
            "all x. (Musician(x) -> Have(x, BusyLife))\nMusician(SinghKaur) & Famous(SinghKaur)\nall x. (Musician(x) & -Famous(x) -> -MakeALotOfMoney(x))\nexists x. (Musician(x) & (Singer(x) | Writer(x)))"
        ],
        "conclusion": "Singh Kaur is a writer.",
        "conclusion-FOL": "Writer(SinghKaur)",
        "label": "ERROR"
    },
    {
        "premises": "Musicians have very busy lives.\nSingh Kaur is a musician and famous.\nIf a musician is not famous, that musician will not make a lot of money.\nA musician can be a singer or a writer.",
        "premises-FOL": [
            "all x. (Musician(x) -> Have(x, BusyLife))\nMusician(SinghKaur) & Famous(SinghKaur)\nall x. (Musician(x) & -Famous(x) -> -MakeALotOfMoney(x))\nexists x. (Musician(x) & (Singer(x) | Writer(x)))"
        ],
        "conclusion": "Singh Kaur has a very busy life.",
        "conclusion-FOL": "Have(SinghKaur, BusyLife)",
        "label": "ERROR"
    },
    {
        "premises": "Each building is tall. \nEverything tall has height.",
        "premises-FOL": [
            "all x. (Building(x) -> Tall(x))\nall x. (Tall(x) -> Height(x))"
        ],
        "conclusion": "All buildings are magnificent.",
        "conclusion-FOL": "all x. (Building(x) -> Magnificent(x))",
        "label": "ERROR"
    },
    {
        "premises": "A cat named Garfield, the main character of the film Garfield, is orange and fat and likes having lasagna. \nGarfield shares a home with Odie, another pet of Jon's. \nGarfield hates Odie.\nA pet who hates the pet with whom he shares the same owner is childish and possessive.",
        "premises-FOL": [
            "Cat(Garfield) & MainCharacterOf(Garfield, FilmGarfield) & Orange(Garfield) & Fat(Garfield) & Like(Garfield, Lasagna)\nPetOf(Garfield, Jon) & PetOf(Odie, Jon) & ShareHomeWith(Garfield, Odie)\nHate(Garfield, Odie)\nall x. all y. exists z. (PetOf(x, z) & PetOf(y, z) & Hate(x, y) -> Childish(x) & Possessive(x))"
        ],
        "conclusion": "The main character of the film Garfield is childish and possessive.",
        "conclusion-FOL": "exists x. (MainCharacterOf(x, Garfield) & Childish(x) & Possessive(x))",
        "label": "ERROR"
    },
    {
        "premises": "All humans are capable of abstract thoughts.\nPlants are not capable of abstract thoughts.\nAll multicellular creatures that are autotrophic or digest food internally are plants and animals.\nAll goats are animals.\nDirt is not an animal.\nHulu is a goat or a human.\nHulu is a multicellular creature that is autotrophic or digests food internally. ",
        "premises-FOL": [
            "all x. (Human(x) -> CapableOf(x, AbstractThought))\nall x. (Plant(x) -> -CapableOf(x, AbstractThought))\nall x. (MulticellularCreature(x) & (Autotrophic(x) | DigestFoodInternally (x)) -> ((Plant(x) & -Animal(x)) | (-Plant(x) & Animal(x))))\nall x. (Goat(x) -> Animal(x))\nall x. (Dirt(x) -> -Animal(x))\nGoat(Hulu) | HumanBeing(Hulu)\n(MulticellularCreature(Hulu) & (Autotrophic(Hulu) | DigestFoodInternally (Hulu))"
        ],
        "conclusion": "Hulu is capable of abstract thoughts.",
        "conclusion-FOL": "CapableOf(Hulu, AbstractThought)",
        "label": "ERROR"
    },
    {
        "premises": "All humans are capable of abstract thoughts.\nPlants are not capable of abstract thoughts.\nAll multicellular creatures that are autotrophic or digest food internally are plants and animals.\nAll goats are animals.\nDirt is not an animal.\nHulu is a goat or a human.\nHulu is a multicellular creature that is autotrophic or digests food internally. ",
        "premises-FOL": [
            "all x. (Human(x) -> CapableOf(x, AbstractThought))\nall x. (Plant(x) -> -CapableOf(x, AbstractThought))\nall x. (MulticellularCreature(x) & (Autotrophic(x) | DigestFoodInternally (x)) -> ((Plant(x) & -Animal(x)) | (-Plant(x) & Animal(x))))\nall x. (Goat(x) -> Animal(x))\nall x. (Dirt(x) -> -Animal(x))\nGoat(Hulu) | HumanBeing(Hulu)\n(MulticellularCreature(Hulu) & (Autotrophic(Hulu) | DigestFoodInternally (Hulu))"
        ],
        "conclusion": "Hulu is not capable of abstract thoughts.",
        "conclusion-FOL": "-CapableOf(Hulu, AbstractThought)",
        "label": "ERROR"
    },
    {
        "premises": "All humans are capable of abstract thoughts.\nPlants are not capable of abstract thoughts.\nAll multicellular creatures that are autotrophic or digest food internally are plants and animals.\nAll goats are animals.\nDirt is not an animal.\nHulu is a goat or a human.\nHulu is a multicellular creature that is autotrophic or digests food internally. ",
        "premises-FOL": [
            "all x. (Human(x) -> CapableOf(x, AbstractThought))\nall x. (Plant(x) -> -CapableOf(x, AbstractThought))\nall x. (MulticellularCreature(x) & (Autotrophic(x) | DigestFoodInternally (x)) -> ((Plant(x) & -Animal(x)) | (-Plant(x) & Animal(x))))\nall x. (Goat(x) -> Animal(x))\nall x. (Dirt(x) -> -Animal(x))\nGoat(Hulu) | HumanBeing(Hulu)\n(MulticellularCreature(Hulu) & (Autotrophic(Hulu) | DigestFoodInternally (Hulu))"
        ],
        "conclusion": "Hulu is dirt.",
        "conclusion-FOL": "Dirt(Hulu)",
        "label": "ERROR"
    },
    {
        "premises": "All humans are capable of abstract thoughts.\nPlants are not capable of abstract thoughts.\nAll multicellular creatures that are autotrophic or digest food internally are plants and animals.\nAll goats are animals.\nDirt is not an animal.\nHulu is a goat or a human.\nHulu is a multicellular creature that is autotrophic or digests food internally. ",
        "premises-FOL": [
            "all x. (Human(x) -> CapableOf(x, AbstractThought))\nall x. (Plant(x) -> -CapableOf(x, AbstractThought))\nall x. (MulticellularCreature(x) & (Autotrophic(x) | DigestFoodInternally (x)) -> ((Plant(x) & -Animal(x)) | (-Plant(x) & Animal(x))))\nall x. (Goat(x) -> Animal(x))\nall x. (Dirt(x) -> -Animal(x))\nGoat(Hulu) | HumanBeing(Hulu)\n(MulticellularCreature(Hulu) & (Autotrophic(Hulu) | DigestFoodInternally (Hulu))"
        ],
        "conclusion": "Hulu is an animal or dirt.",
        "conclusion-FOL": "Animal(Hulu) | Dirt(Hulu)",
        "label": "ERROR"
    },
    {
        "premises": "All humans are capable of abstract thoughts.\nPlants are not capable of abstract thoughts.\nAll multicellular creatures that are autotrophic or digest food internally are plants and animals.\nAll goats are animals.\nDirt is not an animal.\nHulu is a goat or a human.\nHulu is a multicellular creature that is autotrophic or digests food internally. ",
        "premises-FOL": [
            "all x. (Human(x) -> CapableOf(x, AbstractThought))\nall x. (Plant(x) -> -CapableOf(x, AbstractThought))\nall x. (MulticellularCreature(x) & (Autotrophic(x) | DigestFoodInternally (x)) -> ((Plant(x) & -Animal(x)) | (-Plant(x) & Animal(x))))\nall x. (Goat(x) -> Animal(x))\nall x. (Dirt(x) -> -Animal(x))\nGoat(Hulu) | HumanBeing(Hulu)\n(MulticellularCreature(Hulu) & (Autotrophic(Hulu) | DigestFoodInternally (Hulu))"
        ],
        "conclusion": "Hulu is either an animal or dirt, but not both.",
        "conclusion-FOL": "((Animal(Hulu) & -Dirt(Hulu)) | (-Animal(Hulu) & Dirt(Hulu)))",
        "label": "ERROR"
    },
    {
        "premises": "All humans are capable of abstract thoughts.\nPlants are not capable of abstract thoughts.\nAll multicellular creatures that are autotrophic or digest food internally are plants and animals.\nAll goats are animals.\nDirt is not an animal.\nHulu is a goat or a human.\nHulu is a multicellular creature that is autotrophic or digests food internally. ",
        "premises-FOL": [
            "all x. (Human(x) -> CapableOf(x, AbstractThought))\nall x. (Plant(x) -> -CapableOf(x, AbstractThought))\nall x. (MulticellularCreature(x) & (Autotrophic(x) | DigestFoodInternally (x)) -> ((Plant(x) & -Animal(x)) | (-Plant(x) & Animal(x))))\nall x. (Goat(x) -> Animal(x))\nall x. (Dirt(x) -> -Animal(x))\nGoat(Hulu) | HumanBeing(Hulu)\n(MulticellularCreature(Hulu) & (Autotrophic(Hulu) | DigestFoodInternally (Hulu))"
        ],
        "conclusion": "If Hulu is either an animal or dirt, then Hulu is capable of abstract thoughts and is dirt.",
        "conclusion-FOL": "((Animal(Hulu) & -Dirt(Hulu)) | (-Animal(Hulu) & Dirt(Hulu))) -> CapableOf(Hulu, AbstractThought) & Dirt(Hulu)",
        "label": "ERROR"
    },
    {
        "premises": "A controlled substance is a drug.\nThere exist both harmful and beneficial controlled substances.\nIf a child is exposed to a controlled substance, they are in chemical endangerment.\nChemical Endangerment is harmful. \nThe Controlled Substances Act was an act passed in 1971.\nSome Acts prevent harmful things.",
        "premises-FOL": [
            "all x. (ControlledSubstances(x) -> Drugs(x))\nexists x. exists y. (ControlledSubstances(x) & ControlledSubstances(y) & (-(x=y)) & Beneficial(x) & Harmful(y))\nall x. all y. ((Child(x) & ControlledSubstances(y) & ExposedTo(x, y)) -> InChemicalEndangerment(x))\nall x. (InChemicalEndangerment(x) -> Harmful(x))\nPassedIn(ControlledSubstancesAct, YrOneNineSevenOne) & Act(ControlledSubstancesAct)\nexists x. exists y.(Act(x) & PreventsHarm(x) & (-(x=y)) & Act(y) & PreventsHarm(y))"
        ],
        "conclusion": "The Controlled Substances Act prevents harmful things.",
        "conclusion-FOL": "PreventsHarm(ControlledSubstancesAct)",
        "label": "ERROR"
    },
    {
        "premises": "A controlled substance is a drug.\nThere exist both harmful and beneficial controlled substances.\nIf a child is exposed to a controlled substance, they are in chemical endangerment.\nChemical Endangerment is harmful. \nThe Controlled Substances Act was an act passed in 1971.\nSome Acts prevent harmful things.",
        "premises-FOL": [
            "all x. (ControlledSubstances(x) -> Drugs(x))\nexists x. exists y. (ControlledSubstances(x) & ControlledSubstances(y) & (-(x=y)) & Beneficial(x) & Harmful(y))\nall x. all y. ((Child(x) & ControlledSubstances(y) & ExposedTo(x, y)) -> InChemicalEndangerment(x))\nall x. (InChemicalEndangerment(x) -> Harmful(x))\nPassedIn(ControlledSubstancesAct, YrOneNineSevenOne) & Act(ControlledSubstancesAct)\nexists x. exists y.(Act(x) & PreventsHarm(x) & (-(x=y)) & Act(y) & PreventsHarm(y))"
        ],
        "conclusion": "Some drugs are beneficial.",
        "conclusion-FOL": "exists x. exists y.(Drugs(x) & Beneficial(x) & (-(x=y)) & Drugs(y) & Beneficial(y))",
        "label": "ERROR"
    },
    {
        "premises": "A controlled substance is a drug.\nThere exist both harmful and beneficial controlled substances.\nIf a child is exposed to a controlled substance, they are in chemical endangerment.\nChemical Endangerment is harmful. \nThe Controlled Substances Act was an act passed in 1971.\nSome Acts prevent harmful things.",
        "premises-FOL": [
            "all x. (ControlledSubstances(x) -> Drugs(x))\nexists x. exists y. (ControlledSubstances(x) & ControlledSubstances(y) & (-(x=y)) & Beneficial(x) & Harmful(y))\nall x. all y. ((Child(x) & ControlledSubstances(y) & ExposedTo(x, y)) -> InChemicalEndangerment(x))\nall x. (InChemicalEndangerment(x) -> Harmful(x))\nPassedIn(ControlledSubstancesAct, YrOneNineSevenOne) & Act(ControlledSubstancesAct)\nexists x. exists y.(Act(x) & PreventsHarm(x) & (-(x=y)) & Act(y) & PreventsHarm(y))"
        ],
        "conclusion": "A child in chemical endangerment is in harm.",
        "conclusion-FOL": "all x. ((Child(x) & InChemicalEndangerment(x)) -> Harmful(x))",
        "label": "ERROR"
    },
    {
        "premises": "No people who have corporate jobs are taking more than normal financial risks.\nAll entrepreneurs are taking more than normal financial risks.\nAll risk-averse working people are people who have corporate jobs.\nAll working people who hate working for others want to be entrepreneurs.\nIf Mark Zuckerberg is neither an entrepreneur nor a person who hates working for others, then Mark Zuckerberg is not a risk-averse working person.",
        "premises-FOL": [
            "all x. (Have(x, CorporateJob) -> -Take(x, FinancialRisk))\nall x. (Entrepreneur(x) -> Take(x, FinancialRisk))\nall x. (RiskAverse(x) -> Have(x, CorporateJob))\nall x. (exists y. exists z. (-(y=x) & -(z=x) & -(y=z) & HateWorkingFor(x, y) & HateWorkingFor(x, z)) -> Entrepreneur(x))\n-Entrepreneur(MarkZuckerberg) & -(exists y. exists z. (-(y=MarkZuckerberg) & -(z=MarkZuckerberg) & -(y=z) & HateWorkingFor(MarkZuckerberg, y) & HateWorkingFor(MarkZuckerberg, z))) -> -RiskAverse(MarkZuckerberg)"
        ],
        "conclusion": "Mark Zuckerberg is an entrepreneur.",
        "conclusion-FOL": "Entrepreneur(MarkZuckerberg)",
        "label": "ERROR"
    },
    {
        "premises": "No people who have corporate jobs are taking more than normal financial risks.\nAll entrepreneurs are taking more than normal financial risks.\nAll risk-averse working people are people who have corporate jobs.\nAll working people who hate working for others want to be entrepreneurs.\nIf Mark Zuckerberg is neither an entrepreneur nor a person who hates working for others, then Mark Zuckerberg is not a risk-averse working person.",
        "premises-FOL": [
            "all x. (Have(x, CorporateJob) -> -Take(x, FinancialRisk))\nall x. (Entrepreneur(x) -> Take(x, FinancialRisk))\nall x. (RiskAverse(x) -> Have(x, CorporateJob))\nall x. (exists y. exists z. (-(y=x) & -(z=x) & -(y=z) & HateWorkingFor(x, y) & HateWorkingFor(x, z)) -> Entrepreneur(x))\n-Entrepreneur(MarkZuckerberg) & -(exists y. exists z. (-(y=MarkZuckerberg) & -(z=MarkZuckerberg) & -(y=z) & HateWorkingFor(MarkZuckerberg, y) & HateWorkingFor(MarkZuckerberg, z))) -> -RiskAverse(MarkZuckerberg)"
        ],
        "conclusion": "Mark Zuckerberg is a risk-averse person.",
        "conclusion-FOL": "RiskAverse(MarkZuckerberg)",
        "label": "ERROR"
    },
    {
        "premises": "No people who have corporate jobs are taking more than normal financial risks.\nAll entrepreneurs are taking more than normal financial risks.\nAll risk-averse working people are people who have corporate jobs.\nAll working people who hate working for others want to be entrepreneurs.\nIf Mark Zuckerberg is neither an entrepreneur nor a person who hates working for others, then Mark Zuckerberg is not a risk-averse working person.",
        "premises-FOL": [
            "all x. (Have(x, CorporateJob) -> -Take(x, FinancialRisk))\nall x. (Entrepreneur(x) -> Take(x, FinancialRisk))\nall x. (RiskAverse(x) -> Have(x, CorporateJob))\nall x. (exists y. exists z. (-(y=x) & -(z=x) & -(y=z) & HateWorkingFor(x, y) & HateWorkingFor(x, z)) -> Entrepreneur(x))\n-Entrepreneur(MarkZuckerberg) & -(exists y. exists z. (-(y=MarkZuckerberg) & -(z=MarkZuckerberg) & -(y=z) & HateWorkingFor(MarkZuckerberg, y) & HateWorkingFor(MarkZuckerberg, z))) -> -RiskAverse(MarkZuckerberg)"
        ],
        "conclusion": "Mark Zuckerberg is not a risk-averse person.",
        "conclusion-FOL": "-RiskAverse(MarkZuckerberg)",
        "label": "ERROR"
    },
    {
        "premises": "Wildfeed exists as an unannounced program.\nWildfeed can be sporting events, news, or syndicated shows.\nPre-recorded content is a copyright violation.\nPrograms are pre-recorded.",
        "premises-FOL": [
            "exists x. (Wildfeed(x) & Unannounced(x) & Program(x))\nall x. (Wildfeed(x) -> SportingEvent(x) | News(x) | SyndicatedShow(x))\nall x. (Prerecorded(x) -> CopyrightViolation(x))\nall x. (Program(x) -> Prerecorded(x))"
        ],
        "conclusion": "Some wildfeed is violating copyright laws.",
        "conclusion-FOL": "exists x. (Wildfeed(x) & CopyrightViolation(x))",
        "label": "ERROR"
    },
    {
        "premises": "Wildfeed exists as an unannounced program.\nWildfeed can be sporting events, news, or syndicated shows.\nPre-recorded content is a copyright violation.\nPrograms are pre-recorded.",
        "premises-FOL": [
            "exists x. (Wildfeed(x) & Unannounced(x) & Program(x))\nall x. (Wildfeed(x) -> SportingEvent(x) | News(x) | SyndicatedShow(x))\nall x. (Prerecorded(x) -> CopyrightViolation(x))\nall x. (Program(x) -> Prerecorded(x))"
        ],
        "conclusion": "Wildfeed can be prerecorded.",
        "conclusion-FOL": "exists x. (Wildfeed(x) & Prerecorded(x))",
        "label": "ERROR"
    },
    {
        "premises": "Wildfeed exists as an unannounced program.\nWildfeed can be sporting events, news, or syndicated shows.\nPre-recorded content is a copyright violation.\nPrograms are pre-recorded.",
        "premises-FOL": [
            "exists x. (Wildfeed(x) & Unannounced(x) & Program(x))\nall x. (Wildfeed(x) -> SportingEvent(x) | News(x) | SyndicatedShow(x))\nall x. (Prerecorded(x) -> CopyrightViolation(x))\nall x. (Program(x) -> Prerecorded(x))"
        ],
        "conclusion": "Syndicated shows are copyright violations.",
        "conclusion-FOL": "exists x. (SyndicatedShows(x) & CopyrightViolation(x))",
        "label": "ERROR"
    },
    {
        "premises": "New York City is Located in the United States of America.\nThe United States of America is part of North America.\nNorth America is in the western hemisphere of the earth.\nNew York City is a highly developed city.\nIf place A is located in place B and place B is located in place C, then place A is located in place C.",
        "premises-FOL": [
            "LocatedIn(NewYorkCity, UnitedStatesOfAmerica)\nLocatedIn(Usa, NorthAmerica)\nLocatedIn(NorthAmerica, WesternHemisphere)\nHighlyDeveloped(NewYorkCity)\nall x. all y. all z. ((LocatedIn(x, y) & LocatedIn(y, z)) -> LocatedIn(x, z))"
        ],
        "conclusion": "A highly developed city is located in the western hemisphere of the earth.",
        "conclusion-FOL": "exists x. (HighlyDeveloped(x) & LocatedIn(x, WesternHemisphere))",
        "label": "ERROR"
    },
    {
        "premises": "New York City is Located in the United States of America.\nThe United States of America is part of North America.\nNorth America is in the western hemisphere of the earth.\nNew York City is a highly developed city.\nIf place A is located in place B and place B is located in place C, then place A is located in place C.",
        "premises-FOL": [
            "LocatedIn(NewYorkCity, UnitedStatesOfAmerica)\nLocatedIn(Usa, NorthAmerica)\nLocatedIn(NorthAmerica, WesternHemisphere)\nHighlyDeveloped(NewYorkCity)\nall x. all y. all z. ((LocatedIn(x, y) & LocatedIn(y, z)) -> LocatedIn(x, z))"
        ],
        "conclusion": "The United States of America is not located in the western hemisphere of the earth.",
        "conclusion-FOL": "-LocatedIn(UnitedStatesOfAmerica, WestHemisphere)",
        "label": "ERROR"
    },
    {
        "premises": "New York City is Located in the United States of America.\nThe United States of America is part of North America.\nNorth America is in the western hemisphere of the earth.\nNew York City is a highly developed city.\nIf place A is located in place B and place B is located in place C, then place A is located in place C.",
        "premises-FOL": [
            "LocatedIn(NewYorkCity, UnitedStatesOfAmerica)\nLocatedIn(Usa, NorthAmerica)\nLocatedIn(NorthAmerica, WesternHemisphere)\nHighlyDeveloped(NewYorkCity)\nall x. all y. all z. ((LocatedIn(x, y) & LocatedIn(y, z)) -> LocatedIn(x, z))"
        ],
        "conclusion": "New York City is located in New York State.",
        "conclusion-FOL": "LocatedIn(NewYorkCity, NewYork)",
        "label": "ERROR"
    },
    {
        "premises": "Catullus 4 is a poem written by the ancient Roman writer Catullus.\nCatullus 4 is a story about the retirement of a well-traveled ship.\nThere is a strong analogy of human aging in the poem Catullus 4.\nCatullus 4 is written in an unusual iambic trimeter to convey a sense of speed over the waves.",
        "premises-FOL": [
            "Poem(CatullusFour) & WrittenBy(CatullusFour, Catullus) & AncientRomanWriter(Catullus)\nStory(CatullusFour) & About(CatullusFour, RetirementOfAWellTraveledShip)\nPoem(CatullusFour) & StrongAgingAnalogy(CatullusFour)\nPoem(CatullusFour) & WrittenIn(CatullusFour, IambicTrimeter) & Convey(CatullusFour, aSenseOfSpeedOverTheWaves)"
        ],
        "conclusion": "There is a poem written by an ancient Roman writer with a strong analogy of human aging.",
        "conclusion-FOL": "exists x. exists y. (Poem(x) & WrittenBy(x, y) & AncietRomanWriter(y) & StrongAgingAnalogy(x))",
        "label": "ERROR"
    },
    {
        "premises": "Catullus 4 is a poem written by the ancient Roman writer Catullus.\nCatullus 4 is a story about the retirement of a well-traveled ship.\nThere is a strong analogy of human aging in the poem Catullus 4.\nCatullus 4 is written in an unusual iambic trimeter to convey a sense of speed over the waves.",
        "premises-FOL": [
            "Poem(CatullusFour) & WrittenBy(CatullusFour, Catullus) & AncientRomanWriter(Catullus)\nStory(CatullusFour) & About(CatullusFour, RetirementOfAWellTraveledShip)\nPoem(CatullusFour) & StrongAgingAnalogy(CatullusFour)\nPoem(CatullusFour) & WrittenIn(CatullusFour, IambicTrimeter) & Convey(CatullusFour, aSenseOfSpeedOverTheWaves)"
        ],
        "conclusion": "There is a poem written by an ancient Roman writer in iambic trimeter.",
        "conclusion-FOL": "exists x. exists y. (Poem(x) & WrittenBy(x, y) & AncientRomanWriter(y) & WrittenIn(x, IambicTrimeter))",
        "label": "ERROR"
    },
    {
        "premises": "Catullus 4 is a poem written by the ancient Roman writer Catullus.\nCatullus 4 is a story about the retirement of a well-traveled ship.\nThere is a strong analogy of human aging in the poem Catullus 4.\nCatullus 4 is written in an unusual iambic trimeter to convey a sense of speed over the waves.",
        "premises-FOL": [
            "Poem(CatullusFour) & WrittenBy(CatullusFour, Catullus) & AncientRomanWriter(Catullus)\nStory(CatullusFour) & About(CatullusFour, RetirementOfAWellTraveledShip)\nPoem(CatullusFour) & StrongAgingAnalogy(CatullusFour)\nPoem(CatullusFour) & WrittenIn(CatullusFour, IambicTrimeter) & Convey(CatullusFour, aSenseOfSpeedOverTheWaves)"
        ],
        "conclusion": "Callus 4 is written in an unusual iambic trimeter to convey a strong analogy of human aging.",
        "conclusion-FOL": "Poem(CatullusFour) & WrittenIn(CatullusFour, IambicTrimeter) & StrongAgingAnalogy(CatullusFour)",
        "label": "ERROR"
    },
    {
        "premises": "Westworld is an American science fiction-thriller TV series.\nIn 2016, a television series named Westworld debuted on HBO.\nThe TV series Westworld is adapted from the original film in 1973, which was written and directed by Michael Crichton.\nThe 1973 film Westworld is about robots that malfunction and begin killing human visitors.",
        "premises-FOL": [
            "American(Westworld) & ScienceFictionThriller(Westworld)\nDebut(Westworld, YearTwoZeroOneSix) & TvSeries(Westworld)\nAdapted(Westworld, WestworldTheFilm) & Produce(WestworldTheFilm, YearOneNineSevenThree) & Wrote(Michael, WestworldTheFilm) & Directed(Michael, WestworldTheFilm)\nFilm(WestworldTheFilm) & About(WestworldTheFilm, MalfunctioningRobots)"
        ],
        "conclusion": "Michael Crichton has directed a film about malfunctioning robots.",
        "conclusion-FOL": "exists x. (Film(x) & Directed(Michael, x) & About(x, MalfunctioningRobots))",
        "label": "ERROR"
    },
    {
        "premises": "Westworld is an American science fiction-thriller TV series.\nIn 2016, a television series named Westworld debuted on HBO.\nThe TV series Westworld is adapted from the original film in 1973, which was written and directed by Michael Crichton.\nThe 1973 film Westworld is about robots that malfunction and begin killing human visitors.",
        "premises-FOL": [
            "American(Westworld) & ScienceFictionThriller(Westworld)\nDebut(Westworld, YearTwoZeroOneSix) & TvSeries(Westworld)\nAdapted(Westworld, WestworldTheFilm) & Produce(WestworldTheFilm, YearOneNineSevenThree) & Wrote(Michael, WestworldTheFilm) & Directed(Michael, WestworldTheFilm)\nFilm(WestworldTheFilm) & About(WestworldTheFilm, MalfunctioningRobots)"
        ],
        "conclusion": "An American TV series debuted in 2016.",
        "conclusion-FOL": "exists x. (TVSeries(x) & American(x) & Debut(x, YearTwoZeroOneSix))",
        "label": "ERROR"
    },
    {
        "premises": "The 2008 Summer Olympics were held in Beijing, China.\nThe 2008 Summer Olympics was the second Summer Olympic Games held in a communist state.\nChina won the most gold medals (48) in the 2008 Summer Olympics.\nThe United States placed second in the gold medal tally but won the highest number of medals overall (112) in the 2008 Summer Olympics.\nThe third place in the gold medal tally was achieved by Russia in the 2008 Summer Olympics.\nIf a country placed third in gold medals, then it had fewer gold medals than the team that won the most gold medals.",
        "premises-FOL": [
            "HeldIn(TwoZeroZeroEightSummerOlympics, BeijingChina)\nSecondSummerOlympicsGames(TwoZeroZeroEightSummerOlympics) & BeHeldIn(TwoZeroZeroEightSummerOlympics, CommunistState)\nWon(China, TheMostGoldMedals)\nPlacedSecondInGoldMedalsIn(UnitedStates, TwoZeroZeroEightSummerOlympics) & Won(UnitedStates, HighestNumberOfMedals)\nPlacedThirdInGoldMedalsIn(Russia, TwoZeroZeroEightSummerOlympics)\nall x. all y. (Placed(x, ThirdInGoldMedals) & Won(y, MostGoldMedals) -> FewerGoldMedalsThan(x, y))"
        ],
        "conclusion": "Russia did not win fewer gold medals than China.",
        "conclusion-FOL": "-FewerGoldMedalsThan(Russia, China)",
        "label": "ERROR"
    },
    {
        "premises": "The 2008 Summer Olympics were held in Beijing, China.\nThe 2008 Summer Olympics was the second Summer Olympic Games held in a communist state.\nChina won the most gold medals (48) in the 2008 Summer Olympics.\nThe United States placed second in the gold medal tally but won the highest number of medals overall (112) in the 2008 Summer Olympics.\nThe third place in the gold medal tally was achieved by Russia in the 2008 Summer Olympics.\nIf a country placed third in gold medals, then it had fewer gold medals than the team that won the most gold medals.",
        "premises-FOL": [
            "HeldIn(TwoZeroZeroEightSummerOlympics, BeijingChina)\nSecondSummerOlympicsGames(TwoZeroZeroEightSummerOlympics) & BeHeldIn(TwoZeroZeroEightSummerOlympics, CommunistState)\nWon(China, TheMostGoldMedals)\nPlacedSecondInGoldMedalsIn(UnitedStates, TwoZeroZeroEightSummerOlympics) & Won(UnitedStates, HighestNumberOfMedals)\nPlacedThirdInGoldMedalsIn(Russia, TwoZeroZeroEightSummerOlympics)\nall x. all y. (Placed(x, ThirdInGoldMedals) & Won(y, MostGoldMedals) -> FewerGoldMedalsThan(x, y))"
        ],
        "conclusion": "Russia won fewer gold medals than China.",
        "conclusion-FOL": "FewerGoldMedalsThan(Russia, China)",
        "label": "ERROR"
    },
    {
        "premises": "Xiufeng, Xiangshan, Diecai, Qixing are districts in the city of Guilin.\nYangshuo is not a district in Guilin. ",
        "premises-FOL": [
            "DistrictIn(Xiufeng, Guilin) & DistrictIn(Xiangshan, Guilin) & DistrictIn(Diecai, Guilin) & DistrictIn(Qixing, Guilin) & City(Guilin)\n-DistrictIn(Yangshuo, Guilin)"
        ],
        "conclusion": "Xiangshan and Diecai are districts in the same city.",
        "conclusion-FOL": "exists x. (DistrictIn(Xiangshan, x) & DistrictIn(Diecai, x) & City(x))",
        "label": "ERROR"
    },
    {
        "premises": "Xiufeng, Xiangshan, Diecai, Qixing are districts in the city of Guilin.\nYangshuo is not a district in Guilin. ",
        "premises-FOL": [
            "DistrictIn(Xiufeng, Guilin) & DistrictIn(Xiangshan, Guilin) & DistrictIn(Diecai, Guilin) & DistrictIn(Qixing, Guilin) & City(Guilin)\n-DistrictIn(Yangshuo, Guilin)"
        ],
        "conclusion": "Xiufeng is a district in Guilin.",
        "conclusion-FOL": "DistrictIn(Xiufeng, Guilin)",
        "label": "ERROR"
    },
    {
        "premises": "Xiufeng, Xiangshan, Diecai, Qixing are districts in the city of Guilin.\nYangshuo is not a district in Guilin. ",
        "premises-FOL": [
            "DistrictIn(Xiufeng, Guilin) & DistrictIn(Xiangshan, Guilin) & DistrictIn(Diecai, Guilin) & DistrictIn(Qixing, Guilin) & City(Guilin)\n-DistrictIn(Yangshuo, Guilin)"
        ],
        "conclusion": "Kowloon District is in Hong Kong.",
        "conclusion-FOL": "DistrictIn(Kowloon, HongKong)",
        "label": "ERROR"
    },
    {
        "premises": "All of Michael's neighbors who grow their own fresh vegetables in their home gardens also have ample space.\nAll of Michael's neighbors who are young working professionals and live in large cities, do not have ample space.\nAll of Michael's neighbors who order takeout from delivery services often grow their own fresh vegetables in their home garden.\nAll of Michael's neighbors who enjoy going out often to restaurants with friends order takeout from delivery services often.\nAll of Michael's neighbors who regularly tout the benefits of homegrown and homecooked meals over fast food enjoy going out often to restaurants with friends. \nPeter, Michael's neighbor, grows his own fresh vegetables in his home garden, or regularly touts the benefits of homegrown and homecooked meals over fast food, or both.",
        "premises-FOL": [
            "all x. (MichaelsNeightbor(x) & GrowIn(x, Vegetable, Garden) -> Have(x, AmpleSpace))\nall x. (MichaelsNeightbor(x) & YoungWorkingProfession(x) & LiveIn(x, LargeCity) -> -Have(x, AmpleSpace))\nall x. (MichaelsNeightbor(x) & OrderOften(x, Takeout) -> Grow(x, Vegetable, Garden))\nall x. (MichaelsNeightbor(x) & EnjoyGoingOutOftenToWith(x, Restaurant, Friend) -> OrderOften(x, Takeout))\nall x. (MichaelsNeightbor(x) & ToutOver(x, HomecookedMeals, FastFood) -> EnjoyGoingOutOftenToWith(x, Restaurant, Friend))\nMichaelsNeightbor(Peter) & (GrowIn(Peter, Vegetable, Garden) | ToutOver(Peter, HomecookedMeals, FastFood))"
        ],
        "conclusion": "Peter enjoys going out often to restaurants with friends.",
        "conclusion-FOL": "EnjoyGoingOutOftenTo(Peter, Restaurant, Friend)",
        "label": "ERROR"
    },
    {
        "premises": "All of Michael's neighbors who grow their own fresh vegetables in their home gardens also have ample space.\nAll of Michael's neighbors who are young working professionals and live in large cities, do not have ample space.\nAll of Michael's neighbors who order takeout from delivery services often grow their own fresh vegetables in their home garden.\nAll of Michael's neighbors who enjoy going out often to restaurants with friends order takeout from delivery services often.\nAll of Michael's neighbors who regularly tout the benefits of homegrown and homecooked meals over fast food enjoy going out often to restaurants with friends. \nPeter, Michael's neighbor, grows his own fresh vegetables in his home garden, or regularly touts the benefits of homegrown and homecooked meals over fast food, or both.",
        "premises-FOL": [
            "all x. (MichaelsNeightbor(x) & GrowIn(x, Vegetable, Garden) -> Have(x, AmpleSpace))\nall x. (MichaelsNeightbor(x) & YoungWorkingProfession(x) & LiveIn(x, LargeCity) -> -Have(x, AmpleSpace))\nall x. (MichaelsNeightbor(x) & OrderOften(x, Takeout) -> Grow(x, Vegetable, Garden))\nall x. (MichaelsNeightbor(x) & EnjoyGoingOutOftenToWith(x, Restaurant, Friend) -> OrderOften(x, Takeout))\nall x. (MichaelsNeightbor(x) & ToutOver(x, HomecookedMeals, FastFood) -> EnjoyGoingOutOftenToWith(x, Restaurant, Friend))\nMichaelsNeightbor(Peter) & (GrowIn(Peter, Vegetable, Garden) | ToutOver(Peter, HomecookedMeals, FastFood))"
        ],
        "conclusion": "Peter is a young working professional who lives in large cities.",
        "conclusion-FOL": "YoungWorkingProfession(Peter) & LiveIn(Peter, LargeCity)",
        "label": "ERROR"
    },
    {
        "premises": "All of Michael's neighbors who grow their own fresh vegetables in their home gardens also have ample space.\nAll of Michael's neighbors who are young working professionals and live in large cities, do not have ample space.\nAll of Michael's neighbors who order takeout from delivery services often grow their own fresh vegetables in their home garden.\nAll of Michael's neighbors who enjoy going out often to restaurants with friends order takeout from delivery services often.\nAll of Michael's neighbors who regularly tout the benefits of homegrown and homecooked meals over fast food enjoy going out often to restaurants with friends. \nPeter, Michael's neighbor, grows his own fresh vegetables in his home garden, or regularly touts the benefits of homegrown and homecooked meals over fast food, or both.",
        "premises-FOL": [
            "all x. (MichaelsNeightbor(x) & GrowIn(x, Vegetable, Garden) -> Have(x, AmpleSpace))\nall x. (MichaelsNeightbor(x) & YoungWorkingProfession(x) & LiveIn(x, LargeCity) -> -Have(x, AmpleSpace))\nall x. (MichaelsNeightbor(x) & OrderOften(x, Takeout) -> Grow(x, Vegetable, Garden))\nall x. (MichaelsNeightbor(x) & EnjoyGoingOutOftenToWith(x, Restaurant, Friend) -> OrderOften(x, Takeout))\nall x. (MichaelsNeightbor(x) & ToutOver(x, HomecookedMeals, FastFood) -> EnjoyGoingOutOftenToWith(x, Restaurant, Friend))\nMichaelsNeightbor(Peter) & (GrowIn(Peter, Vegetable, Garden) | ToutOver(Peter, HomecookedMeals, FastFood))"
        ],
        "conclusion": "Peter grows his own fresh vegetables in their home garden or is a young working professional who lives in large cities.",
        "conclusion-FOL": "GrowIn(Peter, Vegetable, Garden) | (YoungWorkingProfession(Peter) & LiveIn(Peter, LargeCity))",
        "label": "ERROR"
    },
    {
        "premises": "All devices belonging to the company are connected to Google Home. \nAll devices belonging to employees are connected to the company's wifi. \nAll devices connected to Google Home are controlled by the managers. \nAll devices that connect to the company's wifi are easy to operate. \nModelXX belongs to employees. ",
        "premises-FOL": [
            "all x. (OwnedBy(x, Company) -> ConnectedTo(x, GoogleHome))\nall x. (OwnedBy(x, Employee) -> ConnectedTo(x, CompanyWiFi))\nall x. (ConnectedTo(x, GoogleHome) -> ControlledBy(x, Managers))\nall x. (ConnectedTo(x, CompanyWiFi) -> EasyToOperate(x))\nOwnedBy(ModelXX, Employee)"
        ],
        "conclusion": "ModelXX is easy to operate.",
        "conclusion-FOL": "EasyToOperate(ModelXX)",
        "label": "ERROR"
    },
    {
        "premises": "All devices belonging to the company are connected to Google Home. \nAll devices belonging to employees are connected to the company's wifi. \nAll devices connected to Google Home are controlled by the managers. \nAll devices that connect to the company's wifi are easy to operate. \nModelXX belongs to employees. ",
        "premises-FOL": [
            "all x. (OwnedBy(x, Company) -> ConnectedTo(x, GoogleHome))\nall x. (OwnedBy(x, Employee) -> ConnectedTo(x, CompanyWiFi))\nall x. (ConnectedTo(x, GoogleHome) -> ControlledBy(x, Managers))\nall x. (ConnectedTo(x, CompanyWiFi) -> EasyToOperate(x))\nOwnedBy(ModelXX, Employee)"
        ],
        "conclusion": "ModelXX is controlled by managers.",
        "conclusion-FOL": "ControlledBy(ModelXX, Managers)",
        "label": "ERROR"
    },
    {
        "premises": "All devices belonging to the company are connected to Google Home. \nAll devices belonging to employees are connected to the company's wifi. \nAll devices connected to Google Home are controlled by the managers. \nAll devices that connect to the company's wifi are easy to operate. \nModelXX belongs to employees. ",
        "premises-FOL": [
            "all x. (OwnedBy(x, Company) -> ConnectedTo(x, GoogleHome))\nall x. (OwnedBy(x, Employee) -> ConnectedTo(x, CompanyWiFi))\nall x. (ConnectedTo(x, GoogleHome) -> ControlledBy(x, Managers))\nall x. (ConnectedTo(x, CompanyWiFi) -> EasyToOperate(x))\nOwnedBy(ModelXX, Employee)"
        ],
        "conclusion": "ModelXX is connected to Google Home.",
        "conclusion-FOL": "ConnectedTo(ModelXX, GoogleHome)",
        "label": "ERROR"
    },
    {
        "premises": "No touring musicians who perform at the New Haven Symphony Orchestra are permanent members of the orchestra.\nMusicians who perform at the New Haven Symphony Orchestra are permanent members of an orchestra, or they have temporary roles at the orchestra.\nAll touring musicians who perform at the New Haven Symphony Orchestra have temporary roles at the orchestra.\nAll musicians performing at the New Haven Symphony Orchestra who have temporary roles at the orchestra are interesting soloists.\nAll musicians performing at New Haven Symphony Orchestra who are interesting soloists are capable of attracting audiences.\nRyan is performing at New Haven Symphony Orchestra.\nIf Ryan is an interesting soloist and has a temporary role at the orchestra, then he is capable of attracting large audiences if and only if he is a touring soloist musician. ",
        "premises-FOL": [
            "all x. ((PerformAt(x, NewHavenSymphonyOrchestra) & TouringMusician(x)) -> -PermanentMemberOf(x, TheOrchestra))\nall x. (PerformAt(x, NewHavenSymphonyOrchestra) -> (PermanentMemberOf(x, TheOrchestra) | HaveTemporaryRoleAt(x, TheOrchestra)))\nall x. ((PerformAt(x, NewHavenSymphonyOrchestra) & TouringMusicians(x)) -> HaveTemporaryRoleAt(x, TheOrchestra))\nall x. ((PerformAt(x, NewHavenSymphonyOrchestra) & HaveTemporaryRoleAt(x, TheOrchestra)) -> InterestingSoloist(x))\nall x. ((PerformAt(x, NewHavenSymphonyOrchestra) & InterestingSoloist(x)) -> CapableOfAttractingAudiences(x))\nPerformAt(Ryan, NewHavenSymphonyOrchestra)\n(InterestingSoloist(Ryan) & HaveTemporaryRoleAt(Ryan, TheOrchestra)) -> -(((TouringMusician(Ryan) & -CapableOfAttractingAudiences(Ryan)) | (-TouringMusician(Ryan) & CapableOfAttractingAudiences(Ryan))))"
        ],
        "conclusion": "Ryan is an interesting soloist.",
        "conclusion-FOL": "InterestingSoloist(Ryan)",
        "label": "ERROR"
    },
    {
        "premises": "No touring musicians who perform at the New Haven Symphony Orchestra are permanent members of the orchestra.\nMusicians who perform at the New Haven Symphony Orchestra are permanent members of an orchestra, or they have temporary roles at the orchestra.\nAll touring musicians who perform at the New Haven Symphony Orchestra have temporary roles at the orchestra.\nAll musicians performing at the New Haven Symphony Orchestra who have temporary roles at the orchestra are interesting soloists.\nAll musicians performing at New Haven Symphony Orchestra who are interesting soloists are capable of attracting audiences.\nRyan is performing at New Haven Symphony Orchestra.\nIf Ryan is an interesting soloist and has a temporary role at the orchestra, then he is capable of attracting large audiences if and only if he is a touring soloist musician. ",
        "premises-FOL": [
            "all x. ((PerformAt(x, NewHavenSymphonyOrchestra) & TouringMusician(x)) -> -PermanentMemberOf(x, TheOrchestra))\nall x. (PerformAt(x, NewHavenSymphonyOrchestra) -> (PermanentMemberOf(x, TheOrchestra) | HaveTemporaryRoleAt(x, TheOrchestra)))\nall x. ((PerformAt(x, NewHavenSymphonyOrchestra) & TouringMusicians(x)) -> HaveTemporaryRoleAt(x, TheOrchestra))\nall x. ((PerformAt(x, NewHavenSymphonyOrchestra) & HaveTemporaryRoleAt(x, TheOrchestra)) -> InterestingSoloist(x))\nall x. ((PerformAt(x, NewHavenSymphonyOrchestra) & InterestingSoloist(x)) -> CapableOfAttractingAudiences(x))\nPerformAt(Ryan, NewHavenSymphonyOrchestra)\n(InterestingSoloist(Ryan) & HaveTemporaryRoleAt(Ryan, TheOrchestra)) -> -(((TouringMusician(Ryan) & -CapableOfAttractingAudiences(Ryan)) | (-TouringMusician(Ryan) & CapableOfAttractingAudiences(Ryan))))"
        ],
        "conclusion": "Ryan is either a permanent member of an orchestra or a touring soloist musician.",
        "conclusion-FOL": "(((PermanentMemberOf(Ryan, Orchestra) & -TouringMusician(Ryan)) | (-PermanentMemberOf(Ryan, Orchestra) & TouringMusician(Ryan))))",
        "label": "ERROR"
    },
    {
        "premises": "No touring musicians who perform at the New Haven Symphony Orchestra are permanent members of the orchestra.\nMusicians who perform at the New Haven Symphony Orchestra are permanent members of an orchestra, or they have temporary roles at the orchestra.\nAll touring musicians who perform at the New Haven Symphony Orchestra have temporary roles at the orchestra.\nAll musicians performing at the New Haven Symphony Orchestra who have temporary roles at the orchestra are interesting soloists.\nAll musicians performing at New Haven Symphony Orchestra who are interesting soloists are capable of attracting audiences.\nRyan is performing at New Haven Symphony Orchestra.\nIf Ryan is an interesting soloist and has a temporary role at the orchestra, then he is capable of attracting large audiences if and only if he is a touring soloist musician. ",
        "premises-FOL": [
            "all x. ((PerformAt(x, NewHavenSymphonyOrchestra) & TouringMusician(x)) -> -PermanentMemberOf(x, TheOrchestra))\nall x. (PerformAt(x, NewHavenSymphonyOrchestra) -> (PermanentMemberOf(x, TheOrchestra) | HaveTemporaryRoleAt(x, TheOrchestra)))\nall x. ((PerformAt(x, NewHavenSymphonyOrchestra) & TouringMusicians(x)) -> HaveTemporaryRoleAt(x, TheOrchestra))\nall x. ((PerformAt(x, NewHavenSymphonyOrchestra) & HaveTemporaryRoleAt(x, TheOrchestra)) -> InterestingSoloist(x))\nall x. ((PerformAt(x, NewHavenSymphonyOrchestra) & InterestingSoloist(x)) -> CapableOfAttractingAudiences(x))\nPerformAt(Ryan, NewHavenSymphonyOrchestra)\n(InterestingSoloist(Ryan) & HaveTemporaryRoleAt(Ryan, TheOrchestra)) -> -(((TouringMusician(Ryan) & -CapableOfAttractingAudiences(Ryan)) | (-TouringMusician(Ryan) & CapableOfAttractingAudiences(Ryan))))"
        ],
        "conclusion": "Ryan is either a permanent member of an orchestra or has a temporary role at the orchestra.",
        "conclusion-FOL": "(((PermanentMemberOf(Ryan, Orchestra) & -HaveTemporaryRoleAt(Ryan, Orchestra)) | (-PermanentMemberOf(Ryan, Orchestra) & HaveTemporaryRoleAt(Ryan, Orchestra))))",
        "label": "ERROR"
    },
    {
        "premises": "If someone in Potterville yells, then they are not cool.\nIf someone in Potterville is angry, then they yell.\nIf someone in Potterville flies, then they are cool.\nEvery person in Potterville that knows magic flies.\nAll wizards in Potterville know magic.\nHarry, who lives in Potterville either yells or flies. \nPotter, who lives in Potterville, is a wizard and flies.",
        "premises-FOL": [
            "all x. (In(x, Potterville) & Yell(x) -> -Cool(x))\nall x. (In(x, Potterville) & Angry(x) -> Yell(x))\nall x. (In(x, Potterville) & Fly(x) -> Cool(x))\nall x. (In(x, Potterville) & Know(x, Magic) -> Fly(x))\nall x. (In(x, Potterville) & Wizard(x) -> Know(x, Magic))\nIn(Harry, Potterville) & (((Yell(Harry) & -Fly(Harry)) | (-Yell(Harry) & Fly(Harry))))\nWizard(Potter) & Fly(Potter)"
        ],
        "conclusion": "Harry is cool.",
        "conclusion-FOL": "Cool(Harry)",
        "label": "ERROR"
    },
    {
        "premises": "If someone in Potterville yells, then they are not cool.\nIf someone in Potterville is angry, then they yell.\nIf someone in Potterville flies, then they are cool.\nEvery person in Potterville that knows magic flies.\nAll wizards in Potterville know magic.\nHarry, who lives in Potterville either yells or flies. \nPotter, who lives in Potterville, is a wizard and flies.",
        "premises-FOL": [
            "all x. (In(x, Potterville) & Yell(x) -> -Cool(x))\nall x. (In(x, Potterville) & Angry(x) -> Yell(x))\nall x. (In(x, Potterville) & Fly(x) -> Cool(x))\nall x. (In(x, Potterville) & Know(x, Magic) -> Fly(x))\nall x. (In(x, Potterville) & Wizard(x) -> Know(x, Magic))\nIn(Harry, Potterville) & (((Yell(Harry) & -Fly(Harry)) | (-Yell(Harry) & Fly(Harry))))\nWizard(Potter) & Fly(Potter)"
        ],
        "conclusion": "Harry is not cool.",
        "conclusion-FOL": "-Cool(Harry)",
        "label": "ERROR"
    },
    {
        "premises": "If someone in Potterville yells, then they are not cool.\nIf someone in Potterville is angry, then they yell.\nIf someone in Potterville flies, then they are cool.\nEvery person in Potterville that knows magic flies.\nAll wizards in Potterville know magic.\nHarry, who lives in Potterville either yells or flies. \nPotter, who lives in Potterville, is a wizard and flies.",
        "premises-FOL": [
            "all x. (In(x, Potterville) & Yell(x) -> -Cool(x))\nall x. (In(x, Potterville) & Angry(x) -> Yell(x))\nall x. (In(x, Potterville) & Fly(x) -> Cool(x))\nall x. (In(x, Potterville) & Know(x, Magic) -> Fly(x))\nall x. (In(x, Potterville) & Wizard(x) -> Know(x, Magic))\nIn(Harry, Potterville) & (((Yell(Harry) & -Fly(Harry)) | (-Yell(Harry) & Fly(Harry))))\nWizard(Potter) & Fly(Potter)"
        ],
        "conclusion": "Harry is a wizard or angry.",
        "conclusion-FOL": "Wizard(Harry) | Angry(Harry)",
        "label": "ERROR"
    },
    {
        "premises": "If someone in Potterville yells, then they are not cool.\nIf someone in Potterville is angry, then they yell.\nIf someone in Potterville flies, then they are cool.\nEvery person in Potterville that knows magic flies.\nAll wizards in Potterville know magic.\nHarry, who lives in Potterville either yells or flies. \nPotter, who lives in Potterville, is a wizard and flies.",
        "premises-FOL": [
            "all x. (In(x, Potterville) & Yell(x) -> -Cool(x))\nall x. (In(x, Potterville) & Angry(x) -> Yell(x))\nall x. (In(x, Potterville) & Fly(x) -> Cool(x))\nall x. (In(x, Potterville) & Know(x, Magic) -> Fly(x))\nall x. (In(x, Potterville) & Wizard(x) -> Know(x, Magic))\nIn(Harry, Potterville) & (((Yell(Harry) & -Fly(Harry)) | (-Yell(Harry) & Fly(Harry))))\nWizard(Potter) & Fly(Potter)"
        ],
        "conclusion": "Harry is neither a wizard nor angry.",
        "conclusion-FOL": "-Wizard(Harry) & -Angry(Harry)",
        "label": "ERROR"
    },
    {
        "premises": "All of this brand's products are either produced in China or in the US. \nAll of this brand's products produced in China are labeled. \nAll of this brand's products produced in the US are sold in the US. \nThe products of this brand that are labeled are cheaper.\nAll of this brand's products sold in the US are sold at Walmart. \nAll products of this brand displayed on the homepage are sold at Walmart. \nNone of this brand's products that are returned by customers are sold at Walmart. \nG-910 is a product of this brand, and it is either displayed on the homepage and is cheaper, or it is neither displayed on the homepage nor is it cheaper.",
        "premises-FOL": [
            "all x. (ThisBrand(x) & Product(x) -> (((ProducedIn(x, China) & -ProducedIn(x, uS)) | (-ProducedIn(x, China) & ProducedIn(x, uS)))))\nall x. ((ThisBrand(x) & Product(x) & ProducedIn(x, China)) -> Labeled(x))\nall x. ((ThisBrand(x) & Product(x) & ProducedIn(x, Us)) -> SoldIn(x, Us))\nall x. ((ThisBrand(x) & Product(x) & Labeled(x)) -> Cheaper(x))\nall x. ((ThisBrand(x) & Product(x) & SoldIn(x, Us)) -> SoldIn(x, Walmart))\nall x. (ThisBrand(x) & Product(x) & DisplayedIn(x, Homepage) -> SoldIn(x, Walmart))\nall x. (ThisBrand(x) & Product(x) & ReturnedBy(x, Customer) -> -SoldIn(x, Walmart))\nProduct(gNineOneZero) & ThisBrand(gNineOneZero) & (-(((DisplayedIn(gNineOneZero, Homepage) & -Cheaper(gNineOneZero)) | (-DisplayedIn(gNineOneZero, Homepage) & Cheaper(gNineOneZero)))))"
        ],
        "conclusion": "G-910 is displayed on the homepage.",
        "conclusion-FOL": "DisplayedIn(gNineOneZero, Homepage)",
        "label": "ERROR"
    },
    {
        "premises": "All of this brand's products are either produced in China or in the US. \nAll of this brand's products produced in China are labeled. \nAll of this brand's products produced in the US are sold in the US. \nThe products of this brand that are labeled are cheaper.\nAll of this brand's products sold in the US are sold at Walmart. \nAll products of this brand displayed on the homepage are sold at Walmart. \nNone of this brand's products that are returned by customers are sold at Walmart. \nG-910 is a product of this brand, and it is either displayed on the homepage and is cheaper, or it is neither displayed on the homepage nor is it cheaper.",
        "premises-FOL": [
            "all x. (ThisBrand(x) & Product(x) -> (((ProducedIn(x, China) & -ProducedIn(x, uS)) | (-ProducedIn(x, China) & ProducedIn(x, uS)))))\nall x. ((ThisBrand(x) & Product(x) & ProducedIn(x, China)) -> Labeled(x))\nall x. ((ThisBrand(x) & Product(x) & ProducedIn(x, Us)) -> SoldIn(x, Us))\nall x. ((ThisBrand(x) & Product(x) & Labeled(x)) -> Cheaper(x))\nall x. ((ThisBrand(x) & Product(x) & SoldIn(x, Us)) -> SoldIn(x, Walmart))\nall x. (ThisBrand(x) & Product(x) & DisplayedIn(x, Homepage) -> SoldIn(x, Walmart))\nall x. (ThisBrand(x) & Product(x) & ReturnedBy(x, Customer) -> -SoldIn(x, Walmart))\nProduct(gNineOneZero) & ThisBrand(gNineOneZero) & (-(((DisplayedIn(gNineOneZero, Homepage) & -Cheaper(gNineOneZero)) | (-DisplayedIn(gNineOneZero, Homepage) & Cheaper(gNineOneZero)))))"
        ],
        "conclusion": "G-910 is not displayed on the homepage.",
        "conclusion-FOL": "-DisplayedIn(gNineOneZero, Homepage)",
        "label": "ERROR"
    },
    {
        "premises": "All of this brand's products are either produced in China or in the US. \nAll of this brand's products produced in China are labeled. \nAll of this brand's products produced in the US are sold in the US. \nThe products of this brand that are labeled are cheaper.\nAll of this brand's products sold in the US are sold at Walmart. \nAll products of this brand displayed on the homepage are sold at Walmart. \nNone of this brand's products that are returned by customers are sold at Walmart. \nG-910 is a product of this brand, and it is either displayed on the homepage and is cheaper, or it is neither displayed on the homepage nor is it cheaper.",
        "premises-FOL": [
            "all x. (ThisBrand(x) & Product(x) -> (((ProducedIn(x, China) & -ProducedIn(x, uS)) | (-ProducedIn(x, China) & ProducedIn(x, uS)))))\nall x. ((ThisBrand(x) & Product(x) & ProducedIn(x, China)) -> Labeled(x))\nall x. ((ThisBrand(x) & Product(x) & ProducedIn(x, Us)) -> SoldIn(x, Us))\nall x. ((ThisBrand(x) & Product(x) & Labeled(x)) -> Cheaper(x))\nall x. ((ThisBrand(x) & Product(x) & SoldIn(x, Us)) -> SoldIn(x, Walmart))\nall x. (ThisBrand(x) & Product(x) & DisplayedIn(x, Homepage) -> SoldIn(x, Walmart))\nall x. (ThisBrand(x) & Product(x) & ReturnedBy(x, Customer) -> -SoldIn(x, Walmart))\nProduct(gNineOneZero) & ThisBrand(gNineOneZero) & (-(((DisplayedIn(gNineOneZero, Homepage) & -Cheaper(gNineOneZero)) | (-DisplayedIn(gNineOneZero, Homepage) & Cheaper(gNineOneZero)))))"
        ],
        "conclusion": "G-910 is a product returned by customers.",
        "conclusion-FOL": "ThisBrand(gNineOneZero) & ReturnedBy(gNineOneZero, Customer)",
        "label": "ERROR"
    },
    {
        "premises": "All of this brand's products are either produced in China or in the US. \nAll of this brand's products produced in China are labeled. \nAll of this brand's products produced in the US are sold in the US. \nThe products of this brand that are labeled are cheaper.\nAll of this brand's products sold in the US are sold at Walmart. \nAll products of this brand displayed on the homepage are sold at Walmart. \nNone of this brand's products that are returned by customers are sold at Walmart. \nG-910 is a product of this brand, and it is either displayed on the homepage and is cheaper, or it is neither displayed on the homepage nor is it cheaper.",
        "premises-FOL": [
            "all x. (ThisBrand(x) & Product(x) -> (((ProducedIn(x, China) & -ProducedIn(x, uS)) | (-ProducedIn(x, China) & ProducedIn(x, uS)))))\nall x. ((ThisBrand(x) & Product(x) & ProducedIn(x, China)) -> Labeled(x))\nall x. ((ThisBrand(x) & Product(x) & ProducedIn(x, Us)) -> SoldIn(x, Us))\nall x. ((ThisBrand(x) & Product(x) & Labeled(x)) -> Cheaper(x))\nall x. ((ThisBrand(x) & Product(x) & SoldIn(x, Us)) -> SoldIn(x, Walmart))\nall x. (ThisBrand(x) & Product(x) & DisplayedIn(x, Homepage) -> SoldIn(x, Walmart))\nall x. (ThisBrand(x) & Product(x) & ReturnedBy(x, Customer) -> -SoldIn(x, Walmart))\nProduct(gNineOneZero) & ThisBrand(gNineOneZero) & (-(((DisplayedIn(gNineOneZero, Homepage) & -Cheaper(gNineOneZero)) | (-DisplayedIn(gNineOneZero, Homepage) & Cheaper(gNineOneZero)))))"
        ],
        "conclusion": "G-910 is a product returned by customers or sold in Walmart.",
        "conclusion-FOL": "ThisBrand(gNineOneZero) & (ReturnedBy(gNineOneZero, Customer) | SoldIn(gNineOneZero, Walmart))",
        "label": "ERROR"
    },
    {
        "premises": "All of this brand's products are either produced in China or in the US. \nAll of this brand's products produced in China are labeled. \nAll of this brand's products produced in the US are sold in the US. \nThe products of this brand that are labeled are cheaper.\nAll of this brand's products sold in the US are sold at Walmart. \nAll products of this brand displayed on the homepage are sold at Walmart. \nNone of this brand's products that are returned by customers are sold at Walmart. \nG-910 is a product of this brand, and it is either displayed on the homepage and is cheaper, or it is neither displayed on the homepage nor is it cheaper.",
        "premises-FOL": [
            "all x. (ThisBrand(x) & Product(x) -> (((ProducedIn(x, China) & -ProducedIn(x, uS)) | (-ProducedIn(x, China) & ProducedIn(x, uS)))))\nall x. ((ThisBrand(x) & Product(x) & ProducedIn(x, China)) -> Labeled(x))\nall x. ((ThisBrand(x) & Product(x) & ProducedIn(x, Us)) -> SoldIn(x, Us))\nall x. ((ThisBrand(x) & Product(x) & Labeled(x)) -> Cheaper(x))\nall x. ((ThisBrand(x) & Product(x) & SoldIn(x, Us)) -> SoldIn(x, Walmart))\nall x. (ThisBrand(x) & Product(x) & DisplayedIn(x, Homepage) -> SoldIn(x, Walmart))\nall x. (ThisBrand(x) & Product(x) & ReturnedBy(x, Customer) -> -SoldIn(x, Walmart))\nProduct(gNineOneZero) & ThisBrand(gNineOneZero) & (-(((DisplayedIn(gNineOneZero, Homepage) & -Cheaper(gNineOneZero)) | (-DisplayedIn(gNineOneZero, Homepage) & Cheaper(gNineOneZero)))))"
        ],
        "conclusion": "G-910 is either returned by customers or sold in Walmart.",
        "conclusion-FOL": "((ReturnedBy(gNineOneZero, Customer) & -SoldIn(gNineOneZero, Walmart)) | (-ReturnedBy(gNineOneZero, Customer) & SoldIn(gNineOneZero, Walmart)))",
        "label": "ERROR"
    },
    {
        "premises": "People either believe in Santa Claus, or think he is made up.\nPeople who believe in Santa Claus expect to get presents on Christmas morning.\nPeople who think Santa Claus is made up, then they would be surprised to see him in their house.\nPeople who expect presents on Christmas morning are excited for it to be Christmas.\nIf people would be surprised to see Santa Claus in their house, then they don't leave out cookies on Chrismtas Eve.\nMercy is not someone who expects presents Christmas morning, is excited for Chrismtas, and believes in Santa Claus.",
        "premises-FOL": [
            "all x. (((BelieveIn(x, SantaClaus) & -ThinkMadeUp(x, SantaClaus)) | (-BelieveIn(x, SantaClaus) & ThinkMadeUp(x, SantaClaus))))\nall x. (BelieveIn(x, SantaClaus) -> Expect(x, Present, ChristmasMorning))\nall x. (ThinkMadeUp(x, SantaClaus) -> WouldBeSurprisedToSeeIn(x, SantaClaus, House))\nall x. (Expect(x, Present, ChristmasMorning) -> ExcitedFor(x, Christmas))\nall x. (WouldBeSurprisedToSeeIn(x, SantaClaus, House) -> -LeaveOut(x, Cookies))\n-(Expect(Marcy, Present, ChristmasMorning) & ExcitedFor(Marcy, Christmas) & BelieveIn(Marcy, SantaClaus))"
        ],
        "conclusion": "Marcy either believes in Santa Claus or doesn't leave cookies out on Christmas Eve.",
        "conclusion-FOL": "((BelieveIn(Marcy, SantaClaus) & -LeaveOut(Marcy, Cookies)) | (-BelieveIn(Marcy, SantaClaus) & LeaveOut(Marcy, Cookies)))",
        "label": "ERROR"
    },
    {
        "premises": "People either believe in Santa Claus, or think he is made up.\nPeople who believe in Santa Claus expect to get presents on Christmas morning.\nPeople who think Santa Claus is made up, then they would be surprised to see him in their house.\nPeople who expect presents on Christmas morning are excited for it to be Christmas.\nIf people would be surprised to see Santa Claus in their house, then they don't leave out cookies on Chrismtas Eve.\nMercy is not someone who expects presents Christmas morning, is excited for Chrismtas, and believes in Santa Claus.",
        "premises-FOL": [
            "all x. (((BelieveIn(x, SantaClaus) & -ThinkMadeUp(x, SantaClaus)) | (-BelieveIn(x, SantaClaus) & ThinkMadeUp(x, SantaClaus))))\nall x. (BelieveIn(x, SantaClaus) -> Expect(x, Present, ChristmasMorning))\nall x. (ThinkMadeUp(x, SantaClaus) -> WouldBeSurprisedToSeeIn(x, SantaClaus, House))\nall x. (Expect(x, Present, ChristmasMorning) -> ExcitedFor(x, Christmas))\nall x. (WouldBeSurprisedToSeeIn(x, SantaClaus, House) -> -LeaveOut(x, Cookies))\n-(Expect(Marcy, Present, ChristmasMorning) & ExcitedFor(Marcy, Christmas) & BelieveIn(Marcy, SantaClaus))"
        ],
        "conclusion": "Marcy is not someone who both leaves out cookies on Chrismtas eve and thinks Santa Claus is made up, or Marcy believes in Santa Claus.",
        "conclusion-FOL": "-(LeaveOut(Marcy, Cookies) & ThinkMadeUp(Marcy, SantaClaus)) | BelieveIn(Marcy, SantaClaus)",
        "label": "ERROR"
    },
    {
        "premises": "Indonesia is a country.\nIn Indonesia, the prosecutor only personally investigates cases of some special crimes.\nCorruption is a type of crime.\nOnce the police complete crime investigations, the evidence is handed to the prosecutor. \nEvidence can be either satisfactory or unsatisfactory.\nIf the evidence is handed to the prosecutor and the evidence is satisfactory, the prosecutor will prosecute the offender in an appropriate court.",
        "premises-FOL": [
            "Country(Indonesia)\nall x. exists y. (In(Indonesia) & Prosecutor(x) & SpecialCrime(y) -> InvestigatePersonally(x, y))\nCrime(Corruption)\nall x. all y. all z. (Crime(y) & PoliceCompleteInvestigation(y) & Prosecutor(x) -> Evidence(z) & HandedTo(z, x))\nall x. (Evidence(x) & (((Satisfactory(x) & -Unsatisfactory(x)) | (-Satisfactory(x) & Unsatisfactory(x)))))\nall x. all y. (Evidence(y) & Prosecutor(x) & HandedTo(x) & Satisfactory(y) -> ProsecuteInAppropriateCourt(x, TheOffender))"
        ],
        "conclusion": "When the police complete investigations, the prosecutor will prosecute the offender at an appropriate court.",
        "conclusion-FOL": "all x. all y. (Crime(y) & PoliceCompleteInvestigation(y) & Prosecutor(x) -> ProsecuteInAppropriateCourt(x, TheOffender))",
        "label": "ERROR"
    },
    {
        "premises": "Indonesia is a country.\nIn Indonesia, the prosecutor only personally investigates cases of some special crimes.\nCorruption is a type of crime.\nOnce the police complete crime investigations, the evidence is handed to the prosecutor. \nEvidence can be either satisfactory or unsatisfactory.\nIf the evidence is handed to the prosecutor and the evidence is satisfactory, the prosecutor will prosecute the offender in an appropriate court.",
        "premises-FOL": [
            "Country(Indonesia)\nall x. exists y. (In(Indonesia) & Prosecutor(x) & SpecialCrime(y) -> InvestigatePersonally(x, y))\nCrime(Corruption)\nall x. all y. all z. (Crime(y) & PoliceCompleteInvestigation(y) & Prosecutor(x) -> Evidence(z) & HandedTo(z, x))\nall x. (Evidence(x) & (((Satisfactory(x) & -Unsatisfactory(x)) | (-Satisfactory(x) & Unsatisfactory(x)))))\nall x. all y. (Evidence(y) & Prosecutor(x) & HandedTo(x) & Satisfactory(y) -> ProsecuteInAppropriateCourt(x, TheOffender))"
        ],
        "conclusion": "In Indonesia, the prosecutor personally investigates cases of corruption.",
        "conclusion-FOL": "all x. (Country(Indonesia) & Prosecutor(x) & Crime(Corruption) -> InvestigatePersonally(x, Corruption))",
        "label": "ERROR"
    },
    {
        "premises": "Indonesia is a country.\nIn Indonesia, the prosecutor only personally investigates cases of some special crimes.\nCorruption is a type of crime.\nOnce the police complete crime investigations, the evidence is handed to the prosecutor. \nEvidence can be either satisfactory or unsatisfactory.\nIf the evidence is handed to the prosecutor and the evidence is satisfactory, the prosecutor will prosecute the offender in an appropriate court.",
        "premises-FOL": [
            "Country(Indonesia)\nall x. exists y. (In(Indonesia) & Prosecutor(x) & SpecialCrime(y) -> InvestigatePersonally(x, y))\nCrime(Corruption)\nall x. all y. all z. (Crime(y) & PoliceCompleteInvestigation(y) & Prosecutor(x) -> Evidence(z) & HandedTo(z, x))\nall x. (Evidence(x) & (((Satisfactory(x) & -Unsatisfactory(x)) | (-Satisfactory(x) & Unsatisfactory(x)))))\nall x. all y. (Evidence(y) & Prosecutor(x) & HandedTo(x) & Satisfactory(y) -> ProsecuteInAppropriateCourt(x, TheOffender))"
        ],
        "conclusion": "When the police complete investigations, the prosecutor investigates personally.",
        "conclusion-FOL": "all x. all y. (Crime(y) & PoliceCompleteInvestigation(y) & Prosecutor(x) -> InvestigatePersonally(x, y))",
        "label": "ERROR"
    },
    {
        "premises": "No battery-powered watch is automatic.\nAll digital watches are battery-powered.\nSome mechanical watches are automatic.\nAll smart watches are digital.\nMoonwatch is either a digital watch and an automatic, or it is neither.",
        "premises-FOL": [
            "all x. (BatteryPoweredWatch(x) -> -AutomaticWatch(x))\nall x. (DigitalWatch(x) -> BatteryPoweredWatch(x))\nexists x. (MechanicalWatch(x) & AutomaticWatch(x))\nall x. (SmartWatch(x) -> DigitalWatch(x))\n-(((DigitalWatch(Moonwatch) & -AutomaticWatch(Moonwatch)) | (-DigitalWatch(Moonwatch) & AutomaticWatch(Moonwatch))))"
        ],
        "conclusion": "Moonwatch is a mechanical watch.",
        "conclusion-FOL": "MechanicalWatch(MoonWatch)",
        "label": "ERROR"
    },
    {
        "premises": "No battery-powered watch is automatic.\nAll digital watches are battery-powered.\nSome mechanical watches are automatic.\nAll smart watches are digital.\nMoonwatch is either a digital watch and an automatic, or it is neither.",
        "premises-FOL": [
            "all x. (BatteryPoweredWatch(x) -> -AutomaticWatch(x))\nall x. (DigitalWatch(x) -> BatteryPoweredWatch(x))\nexists x. (MechanicalWatch(x) & AutomaticWatch(x))\nall x. (SmartWatch(x) -> DigitalWatch(x))\n-(((DigitalWatch(Moonwatch) & -AutomaticWatch(Moonwatch)) | (-DigitalWatch(Moonwatch) & AutomaticWatch(Moonwatch))))"
        ],
        "conclusion": "Moonwatch is a smartwatch and a mechanical watch.",
        "conclusion-FOL": "SmartWatch(Moonwatch) & MechanicalWatch(Moonwatch)",
        "label": "ERROR"
    },
    {
        "premises": "No battery-powered watch is automatic.\nAll digital watches are battery-powered.\nSome mechanical watches are automatic.\nAll smart watches are digital.\nMoonwatch is either a digital watch and an automatic, or it is neither.",
        "premises-FOL": [
            "all x. (BatteryPoweredWatch(x) -> -AutomaticWatch(x))\nall x. (DigitalWatch(x) -> BatteryPoweredWatch(x))\nexists x. (MechanicalWatch(x) & AutomaticWatch(x))\nall x. (SmartWatch(x) -> DigitalWatch(x))\n-(((DigitalWatch(Moonwatch) & -AutomaticWatch(Moonwatch)) | (-DigitalWatch(Moonwatch) & AutomaticWatch(Moonwatch))))"
        ],
        "conclusion": "If Moonwatch is a smartwatch and a mechanical watch, then Moonwatch is not a mechanical watch.",
        "conclusion-FOL": "SmartWatch(Moonwatch) & MechanicalWatch(Moonwatch) -> -MechanicalWatch(Moonwatch)",
        "label": "ERROR"
    },
    {
        "premises": "No battery-powered watch is automatic.\nAll digital watches are battery-powered.\nSome mechanical watches are automatic.\nAll smart watches are digital.\nMoonwatch is either a digital watch and an automatic, or it is neither.",
        "premises-FOL": [
            "all x. (BatteryPoweredWatch(x) -> -AutomaticWatch(x))\nall x. (DigitalWatch(x) -> BatteryPoweredWatch(x))\nexists x. (MechanicalWatch(x) & AutomaticWatch(x))\nall x. (SmartWatch(x) -> DigitalWatch(x))\n-(((DigitalWatch(Moonwatch) & -AutomaticWatch(Moonwatch)) | (-DigitalWatch(Moonwatch) & AutomaticWatch(Moonwatch))))"
        ],
        "conclusion": "If Moonwatch is a mechanical or battery-powered watch, then Moonwatch is not a smartwatch.",
        "conclusion-FOL": "MechanicalWatch(Moonwatch)) | BatteryPoweredWatch(Moonwatch) -> -SmartWatch(Moonwatch)",
        "label": "ERROR"
    },
    {
        "premises": "If a person can distinguish the taste of different condiments, then they can also use different condiments for cooking.\nPeople who have a talent of cooking can distinguish the taste of different condiments.\nOnly people with the talent of cooking can make delicious meals.\nIf the meal is popular at the party, then it is delicious.\nJohn can make meals which are popular at the party.",
        "premises-FOL": [
            "all x. (Person(x) & Can(x, DistinguishTheTasteOfDifferentCondiments) -> Can(x, UseDifferentCondimentsToCook))\nall x. (Person(x) & Has(x, TalentOfCooking) -> Can(x, DistinguishTheTasteOfDifferentCondiments))\nall x. all y. (CanMake(x, y) & Meal(y) & Delicious(y) & Person(x) -> Has(x, TalentOfCooking)) \nall x. all y. (Meal(y) & PopularAt(y, Party) -> Delicious(y))\nexists x. (Person(John) & MakeMeal(John, x) & Meal(x) & PopularAt(x, Party))"
        ],
        "conclusion": "John cannot use different condiments for cooking.",
        "conclusion-FOL": "-Can(John, UseDifferentCondimentsToCook)",
        "label": "ERROR"
    },
    {
        "premises": "For a country, if effective monetary policy is possible, it must have successful inflation control and a strong national currency.\nA country cannot simultaneously regulate the exchange rate and successfully control inflation.\nThe introduction of an embargo on foreign trade goods in a country leads to a sharp decrease in exports.\nIf exports fall sharply, this country's national currency cannot be strong.\nInflation control is required to have a strong national currency. \nThere is an embargo on Russian foreign trade goods.",
        "premises-FOL": [
            "all x. (Country(x) & PossibleEffectiveMonetaryPolicy(x) -> SuccessfulInflationControl(x) & StongNationalCurrency(x))\n-(exists x. (Country(x) & SuccessfulInflationControl(x) & RegulateExchangeRate(x)))\nall x. (IntroductionOfOn(x, Embargo, ForeightTradeGoods) -> SharpDecreasesInExport(x))\nall x. (SharpDecreasesInExport(x) -> -StongNationalCurrency(x))\nall x. (InflationControl(x) -> StongNationalCurrency(x))\nIntroductionOfOn(Russia, Embargo, ForeightTradeGoods)"
        ],
        "conclusion": "In Russia, an effective monetary policy is possible.",
        "conclusion-FOL": "PossibleEffectiveMonetaryPolicy(Russia)",
        "label": "ERROR"
    },
    {
        "premises": "Video Gag is a French television series that airs weekly.\nVideo Gag airs on the French broadcast channel TF1. \nIf viewers send funny videos to the French broadcast channel TF1, then Video Gag airs them weekly.\nAll videos aired on Video Gag are in French.",
        "premises-FOL": [
            "FrenchTelevision(VideoGag) & AirWeekly(VideoGag)\nAirOn(VideoGag, FrenchBroadcastChannelTFOne)\nall x. (Funny(x) & Video(x) & SendIn(Viewers, x, FrenchBroadcastChannelTFOne)  -> AirWeekly(x) ) & AirOn(VideoGag, x))\nall x. (Video(x) & AirOn(VideoGag, x) -> In(x, French))"
        ],
        "conclusion": "Viewers send funny videos to the French broadcast channel TF1 that are in French.",
        "conclusion-FOL": "exists x. (SendIn(Viewers, x, FrenchBroadcastChannelTFOne) & French(x))",
        "label": "ERROR"
    },
    {
        "premises": "Video Gag is a French television series that airs weekly.\nVideo Gag airs on the French broadcast channel TF1. \nIf viewers send funny videos to the French broadcast channel TF1, then Video Gag airs them weekly.\nAll videos aired on Video Gag are in French.",
        "premises-FOL": [
            "FrenchTelevision(VideoGag) & AirWeekly(VideoGag)\nAirOn(VideoGag, FrenchBroadcastChannelTFOne)\nall x. (Funny(x) & Video(x) & SendIn(Viewers, x, FrenchBroadcastChannelTFOne)  -> AirWeekly(x) ) & AirOn(VideoGag, x))\nall x. (Video(x) & AirOn(VideoGag, x) -> In(x, French))"
        ],
        "conclusion": "Viewers send funny videos to the French broadcast channel that are in English.",
        "conclusion-FOL": "exists x. (SendIn(Viewers, x, FrenchBroadcastChannelTFOne) & English(x))",
        "label": "ERROR"
    },
    {
        "premises": "All phones are things.\nAll cell phones are phones. \nAll iPhones are cell phones. \nAll employees are wage earners.\nAll wage earners are human. \nJack is either an employee or a wage earner.\nJack is either a human or a phone.",
        "premises-FOL": [
            "all x. (Phone(x) -> Thing(x))\nall x. (Cellphone(x) -> Phone(x))\nall x. (Iphone(x) -> Cellphone(x))\nall x. (Employee(x) -> WageEarner(x))\nall x. (WageEarner(x) -> Human(x))\n((Employee(Jack) & -WageEarner(Jack)) | (-Employee(Jack) & WageEarner(Jack))) \n((Human(Jack) & -Phone(Jack)) | (-Human(Jack) & Phone(Jack)))"
        ],
        "conclusion": "Jack is a thing.",
        "conclusion-FOL": "Thing(Jack)",
        "label": "ERROR"
    },
    {
        "premises": "All phones are things.\nAll cell phones are phones. \nAll iPhones are cell phones. \nAll employees are wage earners.\nAll wage earners are human. \nJack is either an employee or a wage earner.\nJack is either a human or a phone.",
        "premises-FOL": [
            "all x. (Phone(x) -> Thing(x))\nall x. (Cellphone(x) -> Phone(x))\nall x. (Iphone(x) -> Cellphone(x))\nall x. (Employee(x) -> WageEarner(x))\nall x. (WageEarner(x) -> Human(x))\n((Employee(Jack) & -WageEarner(Jack)) | (-Employee(Jack) & WageEarner(Jack))) \n((Human(Jack) & -Phone(Jack)) | (-Human(Jack) & Phone(Jack)))"
        ],
        "conclusion": "Jack is not a thing.",
        "conclusion-FOL": "-Thing(Jack)",
        "label": "ERROR"
    },
    {
        "premises": "All phones are things.\nAll cell phones are phones. \nAll iPhones are cell phones. \nAll employees are wage earners.\nAll wage earners are human. \nJack is either an employee or a wage earner.\nJack is either a human or a phone.",
        "premises-FOL": [
            "all x. (Phone(x) -> Thing(x))\nall x. (Cellphone(x) -> Phone(x))\nall x. (Iphone(x) -> Cellphone(x))\nall x. (Employee(x) -> WageEarner(x))\nall x. (WageEarner(x) -> Human(x))\n((Employee(Jack) & -WageEarner(Jack)) | (-Employee(Jack) & WageEarner(Jack))) \n((Human(Jack) & -Phone(Jack)) | (-Human(Jack) & Phone(Jack)))"
        ],
        "conclusion": "Jack is a thing and an iPhone.",
        "conclusion-FOL": "Thing(Jack) & Iphone(Jack)",
        "label": "ERROR"
    },
    {
        "premises": "All phones are things.\nAll cell phones are phones. \nAll iPhones are cell phones. \nAll employees are wage earners.\nAll wage earners are human. \nJack is either an employee or a wage earner.\nJack is either a human or a phone.",
        "premises-FOL": [
            "all x. (Phone(x) -> Thing(x))\nall x. (Cellphone(x) -> Phone(x))\nall x. (Iphone(x) -> Cellphone(x))\nall x. (Employee(x) -> WageEarner(x))\nall x. (WageEarner(x) -> Human(x))\n((Employee(Jack) & -WageEarner(Jack)) | (-Employee(Jack) & WageEarner(Jack))) \n((Human(Jack) & -Phone(Jack)) | (-Human(Jack) & Phone(Jack)))"
        ],
        "conclusion": "Jack is not both a thing and an iPhone.",
        "conclusion-FOL": "-(Thing(Jack) & Iphone(Jack))",
        "label": "ERROR"
    },
    {
        "premises": "All iPhones are electronic.\nSome phones are iPhones.",
        "premises-FOL": [
            "all x. (IPhone(x) -> Electronic(x))\nexists x. exists y. (Phone(x) & Phone(y) & IPhone(x) & IPhone(y) & -(x=y))"
        ],
        "conclusion": "No phones are electronic.",
        "conclusion-FOL": "all x. (Phone(x) -> -Electronic(x))",
        "label": "ERROR"
    },
    {
        "premises": "The Metropolitan Museum of Art is a museum in NYC.\nWhitney Museum of American Art is a museum in NYC.\nThe Museum of Modern Art (MoMA) is a museum in NYC. \nThe Metropolitan Museum of Art includes Byzantine and Islamic Art. \nWhitney Museum of American Art includes American art.",
        "premises-FOL": [
            "Museum(MetropolitanMuseumOfArt) & In(MetropolitanMuseumOfArt, nYC)\nMuseum(WhitneyMuseumOfAmericanArt) & In(MetropolitanMuseumOfArt, nYC)\nMuseum(MuseumOfModernArt) & In(MuseumOfModernArt, nYC)\nInclude(MetropolitanMuseumOfArt, ByzantineArt) & Include(MetropolitanMuseumOfArt, IslamicArt)\nInclude(WhitneyMuseumOfAmericanArt, AmericanArt)"
        ],
        "conclusion": "A museum in NYC includes Byzantine and Islamic Art.",
        "conclusion-FOL": "exists x. (Museum(x) & In(x, nYC) & Include(x, ByzantineArt) & Include(x, IslamicArt))",
        "label": "ERROR"
    },
    {
        "premises": "The Metropolitan Museum of Art is a museum in NYC.\nWhitney Museum of American Art is a museum in NYC.\nThe Museum of Modern Art (MoMA) is a museum in NYC. \nThe Metropolitan Museum of Art includes Byzantine and Islamic Art. \nWhitney Museum of American Art includes American art.",
        "premises-FOL": [
            "Museum(MetropolitanMuseumOfArt) & In(MetropolitanMuseumOfArt, nYC)\nMuseum(WhitneyMuseumOfAmericanArt) & In(MetropolitanMuseumOfArt, nYC)\nMuseum(MuseumOfModernArt) & In(MuseumOfModernArt, nYC)\nInclude(MetropolitanMuseumOfArt, ByzantineArt) & Include(MetropolitanMuseumOfArt, IslamicArt)\nInclude(WhitneyMuseumOfAmericanArt, AmericanArt)"
        ],
        "conclusion": "A museum in NYC includes American art.",
        "conclusion-FOL": "exists x. (Museum(x) & In(x, nYC) & Include(x, AmericanArt))",
        "label": "ERROR"
    },
    {
        "premises": "The Metropolitan Museum of Art is a museum in NYC.\nWhitney Museum of American Art is a museum in NYC.\nThe Museum of Modern Art (MoMA) is a museum in NYC. \nThe Metropolitan Museum of Art includes Byzantine and Islamic Art. \nWhitney Museum of American Art includes American art.",
        "premises-FOL": [
            "Museum(MetropolitanMuseumOfArt) & In(MetropolitanMuseumOfArt, nYC)\nMuseum(WhitneyMuseumOfAmericanArt) & In(MetropolitanMuseumOfArt, nYC)\nMuseum(MuseumOfModernArt) & In(MuseumOfModernArt, nYC)\nInclude(MetropolitanMuseumOfArt, ByzantineArt) & Include(MetropolitanMuseumOfArt, IslamicArt)\nInclude(WhitneyMuseumOfAmericanArt, AmericanArt)"
        ],
        "conclusion": "A museum in NYC includes Greek art.",
        "conclusion-FOL": "exists x. (Museum(x) & In(x, nYC) & Include(x, GreekArt))",
        "label": "ERROR"
    },
    {
        "premises": "There's a person in Benji's family who likes eating cheese or is a francophile.\nThere is no francophile in Benji's family whose favorite country is Spain.\nThere is a person in Benji's family who likes eating cheese or whose favorite country is Spain.\nFabien is in Benji's family and  does not both study Spanish and also like eating cheese.\nFabien studies Spanish.",
        "premises-FOL": [
            "exists x. (InBenjiSFamily(x) -> (LikeEating(x, Cheese) | Francophile(x)))\nall x. ((InBenjiSFamily(x) & Francophile(x)) -> -Favor(x, Spain))\nexists x. (InBenjiSFamily(x) & (Favor(x, Spain) | LikeEating(x, Cheese)))\nInBenjiSFamily(Fabien) & (-(LikeEating(Fabien, Cheese) & Study(Fabien, Spanish)))\nStudy(Fabien, Spanish)"
        ],
        "conclusion": "Fabien is a person who likes eating cheese.",
        "conclusion-FOL": "LikeEating(Fabien, Cheese)",
        "label": "ERROR"
    },
    {
        "premises": "There's a person in Benji's family who likes eating cheese or is a francophile.\nThere is no francophile in Benji's family whose favorite country is Spain.\nThere is a person in Benji's family who likes eating cheese or whose favorite country is Spain.\nFabien is in Benji's family and  does not both study Spanish and also like eating cheese.\nFabien studies Spanish.",
        "premises-FOL": [
            "exists x. (InBenjiSFamily(x) -> (LikeEating(x, Cheese) | Francophile(x)))\nall x. ((InBenjiSFamily(x) & Francophile(x)) -> -Favor(x, Spain))\nexists x. (InBenjiSFamily(x) & (Favor(x, Spain) | LikeEating(x, Cheese)))\nInBenjiSFamily(Fabien) & (-(LikeEating(Fabien, Cheese) & Study(Fabien, Spanish)))\nStudy(Fabien, Spanish)"
        ],
        "conclusion": "If Fabien is either a person who likes eating cheese or a francophile, then Fabien is neither a person who studies Spanish nor a person who is a francophile.",
        "conclusion-FOL": "(((LikeEating(Fabien, Cheese) & -Francophile(Fabien)) | (-LikeEating(Fabien, Cheese) & Francophile(Fabien)))) -> (-(Study(Fabien, Spanish) | Francophile(Fabien)))",
        "label": "ERROR"
    },
    {
        "premises": "There's a person in Benji's family who likes eating cheese or is a francophile.\nThere is no francophile in Benji's family whose favorite country is Spain.\nThere is a person in Benji's family who likes eating cheese or whose favorite country is Spain.\nFabien is in Benji's family and  does not both study Spanish and also like eating cheese.\nFabien studies Spanish.",
        "premises-FOL": [
            "exists x. (InBenjiSFamily(x) -> (LikeEating(x, Cheese) | Francophile(x)))\nall x. ((InBenjiSFamily(x) & Francophile(x)) -> -Favor(x, Spain))\nexists x. (InBenjiSFamily(x) & (Favor(x, Spain) | LikeEating(x, Cheese)))\nInBenjiSFamily(Fabien) & (-(LikeEating(Fabien, Cheese) & Study(Fabien, Spanish)))\nStudy(Fabien, Spanish)"
        ],
        "conclusion": "If Fabien is a person who likes Spain as their favorite country or is a francophile, then Fabien is either a person who studies Spanish or a person who likes Spain as their favorite country.",
        "conclusion-FOL": "(Favor(Fabien, Spain) | Francophile(Fabien)) -> (((Study(Fabien, Spanish) & -Favor(Fabien, Spain)) | (-Study(Fabien, Spanish) & Favor(Fabien, Spain))))",
        "label": "ERROR"
    },
    {
        "premises": "Gasteren is a village located in the province of Drenthe.\nDrenthe is a Dutch province. \nNo cities are villages.\nThe population of a village in Drenthe was 155 people.",
        "premises-FOL": [
            "Village(Gasteren) & Province(Drenthe) & In(Gasteren, Drenthe)\nProvince(Drenthe) & In(Drenthe, Netherlands)\nall x. (City(x) -> -Village(x))\nexists x. (Population(x, NumOneFiveFive) & Village(x) & In(x, Drenthe))"
        ],
        "conclusion": "Gasteren is a Dutch village.",
        "conclusion-FOL": "Village(Gasteren) & In(Gasteren, Netherlands)",
        "label": "ERROR"
    },
    {
        "premises": "Gasteren is a village located in the province of Drenthe.\nDrenthe is a Dutch province. \nNo cities are villages.\nThe population of a village in Drenthe was 155 people.",
        "premises-FOL": [
            "Village(Gasteren) & Province(Drenthe) & In(Gasteren, Drenthe)\nProvince(Drenthe) & In(Drenthe, Netherlands)\nall x. (City(x) -> -Village(x))\nexists x. (Population(x, NumOneFiveFive) & Village(x) & In(x, Drenthe))"
        ],
        "conclusion": "Gasteren is a city.",
        "conclusion-FOL": "City(Gasteren)",
        "label": "ERROR"
    },
    {
        "premises": "Gasteren is a village located in the province of Drenthe.\nDrenthe is a Dutch province. \nNo cities are villages.\nThe population of a village in Drenthe was 155 people.",
        "premises-FOL": [
            "Village(Gasteren) & Province(Drenthe) & In(Gasteren, Drenthe)\nProvince(Drenthe) & In(Drenthe, Netherlands)\nall x. (City(x) -> -Village(x))\nexists x. (Population(x, NumOneFiveFive) & Village(x) & In(x, Drenthe))"
        ],
        "conclusion": "Gasteren has a population of 155.",
        "conclusion-FOL": "Population(Gasteren, NumOneFiveFive)",
        "label": "ERROR"
    },
    {
        "premises": "The only types of mammals that lay eggs are either platypuses or echidnas.\nPlatypuses are not hyrax.\nEchidnas are not hyrax.\nNo mammals are invertebrates.\nAll animals are either vertebrates or invertebrates.\nMammals are animals.\nHyraxes are mammals.\nGrebes lay eggs.\nGrebes are not platypuses and also not echidnas.",
        "premises-FOL": [
            "all x. ((Mammal(x) & LayEgg(x)) -> (((Platypus(x) & -Echidna(x)) | (-Platypus(x) & Echidna(x)))))\nall x. (Platypuses(x) -> -Hyrax(x))\nall x. (Echidnas(x) -> -Hyrax(x))\nall x. (Mammal(x) -> -Invertebrate(x))\nall x. (Animal(x) -> (Vertebrate(x) | Invertebrate(x)))\nall x. (Mammal(x) -> Animal(x))\nall x. (Hyrax(x) -> Mammal(x))\nall x. (Grebes(x) -> LayEgg(x))\nall x. (Grebes(x) -> (-Platypuses(x) & -Echidnas(x)))"
        ],
        "conclusion": "Hyraxes lay eggs.",
        "conclusion-FOL": "exists x. (Hyrax(x) & LayEgg(x))",
        "label": "ERROR"
    },
    {
        "premises": "The only types of mammals that lay eggs are either platypuses or echidnas.\nPlatypuses are not hyrax.\nEchidnas are not hyrax.\nNo mammals are invertebrates.\nAll animals are either vertebrates or invertebrates.\nMammals are animals.\nHyraxes are mammals.\nGrebes lay eggs.\nGrebes are not platypuses and also not echidnas.",
        "premises-FOL": [
            "all x. ((Mammal(x) & LayEgg(x)) -> (((Platypus(x) & -Echidna(x)) | (-Platypus(x) & Echidna(x)))))\nall x. (Platypuses(x) -> -Hyrax(x))\nall x. (Echidnas(x) -> -Hyrax(x))\nall x. (Mammal(x) -> -Invertebrate(x))\nall x. (Animal(x) -> (Vertebrate(x) | Invertebrate(x)))\nall x. (Mammal(x) -> Animal(x))\nall x. (Hyrax(x) -> Mammal(x))\nall x. (Grebes(x) -> LayEgg(x))\nall x. (Grebes(x) -> (-Platypuses(x) & -Echidnas(x)))"
        ],
        "conclusion": "Grebes are not mammals.",
        "conclusion-FOL": "all x. (Grebes(x) -> -Mammal(x))",
        "label": "ERROR"
    },
    {
        "premises": "The only types of mammals that lay eggs are either platypuses or echidnas.\nPlatypuses are not hyrax.\nEchidnas are not hyrax.\nNo mammals are invertebrates.\nAll animals are either vertebrates or invertebrates.\nMammals are animals.\nHyraxes are mammals.\nGrebes lay eggs.\nGrebes are not platypuses and also not echidnas.",
        "premises-FOL": [
            "all x. ((Mammal(x) & LayEgg(x)) -> (((Platypus(x) & -Echidna(x)) | (-Platypus(x) & Echidna(x)))))\nall x. (Platypuses(x) -> -Hyrax(x))\nall x. (Echidnas(x) -> -Hyrax(x))\nall x. (Mammal(x) -> -Invertebrate(x))\nall x. (Animal(x) -> (Vertebrate(x) | Invertebrate(x)))\nall x. (Mammal(x) -> Animal(x))\nall x. (Hyrax(x) -> Mammal(x))\nall x. (Grebes(x) -> LayEgg(x))\nall x. (Grebes(x) -> (-Platypuses(x) & -Echidnas(x)))"
        ],
        "conclusion": "Platypuses are vertebrates.",
        "conclusion-FOL": "all x. (Platypuses(x) -> Vertebrate(x))",
        "label": "ERROR"
    },
    {
        "premises": "Bobby Flynn is a singer-songwriter. \nBobby Flynn finished 7th while competing on Australian Idol.\nAustralian Idol competitors are Australian citizens.\nThe Omega Three band made a nationwide tour in 2007.\nBobby Flynn is a member of The Omega Three band.\nBobby Flynn was born in Queensland.",
        "premises-FOL": [
            "Singer(BobbyFlynn) & SongWriter(BobbyFlynn)\nFinishesIn(BobbyFlynn, NumberSeven) & CompetesOnAustralianIdol(BobbyFlynn)\nall x. (CompetesOnAustralianIdol(x) -> AustralianCitizen(x))\nNationWideTourIn(TheOmegaThreeBand, YearTwoZeroZeroSeven) \nMember(BobbyFlynn, TheOmegaThreeBand)\nBornIn(BobbyFlynn, Queensland)"
        ],
        "conclusion": "Bobby Flynn is an Australian citizen.",
        "conclusion-FOL": "AustralianCitizen(BobbyFlynn)",
        "label": "ERROR"
    },
    {
        "premises": "Bobby Flynn is a singer-songwriter. \nBobby Flynn finished 7th while competing on Australian Idol.\nAustralian Idol competitors are Australian citizens.\nThe Omega Three band made a nationwide tour in 2007.\nBobby Flynn is a member of The Omega Three band.\nBobby Flynn was born in Queensland.",
        "premises-FOL": [
            "Singer(BobbyFlynn) & SongWriter(BobbyFlynn)\nFinishesIn(BobbyFlynn, NumberSeven) & CompetesOnAustralianIdol(BobbyFlynn)\nall x. (CompetesOnAustralianIdol(x) -> AustralianCitizen(x))\nNationWideTourIn(TheOmegaThreeBand, YearTwoZeroZeroSeven) \nMember(BobbyFlynn, TheOmegaThreeBand)\nBornIn(BobbyFlynn, Queensland)"
        ],
        "conclusion": "Bobby Flynn flew to America in 2007.",
        "conclusion-FOL": "FlewToIn(BobbyFlynn, America, YearTwoZeroZeroSeven)",
        "label": "ERROR"
    },
    {
        "premises": "Bobby Flynn is a singer-songwriter. \nBobby Flynn finished 7th while competing on Australian Idol.\nAustralian Idol competitors are Australian citizens.\nThe Omega Three band made a nationwide tour in 2007.\nBobby Flynn is a member of The Omega Three band.\nBobby Flynn was born in Queensland.",
        "premises-FOL": [
            "Singer(BobbyFlynn) & SongWriter(BobbyFlynn)\nFinishesIn(BobbyFlynn, NumberSeven) & CompetesOnAustralianIdol(BobbyFlynn)\nall x. (CompetesOnAustralianIdol(x) -> AustralianCitizen(x))\nNationWideTourIn(TheOmegaThreeBand, YearTwoZeroZeroSeven) \nMember(BobbyFlynn, TheOmegaThreeBand)\nBornIn(BobbyFlynn, Queensland)"
        ],
        "conclusion": "Bobby Flynn was born in Queens.",
        "conclusion-FOL": "BornIn(BobbyFlynn, Queens)",
        "label": "ERROR"
    },
    {
        "premises": "All proteins are organic compounds.\nAll enzymes are organic compounds.",
        "premises-FOL": [
            "all x. (Protein(x) -> OrganicCompound(x))\nall x. (Enzyme(x) -> OrganicCompound(x))"
        ],
        "conclusion": "All enzymes are proteins.",
        "conclusion-FOL": "all x. (Enzyme(x) -> Protein(x))",
        "label": "ERROR"
    },
    {
        "premises": "Maggie Friedman is an American screenwriter and producer.\nMaggie Friedman was the showrunner and executive producer of the lifetime television series Witches of East End.\nWitches of East End is a fantasy-drama series.\nMaggie Friedman produced and developed Eastwick.\nEastwick is a series by ABC.",
        "premises-FOL": [
            "American(MaggieFriedman) & Screenwriter(MaggieFriedman) & Producer(MaggieFriedman)\nShowRunnerOf(MaggieFriedman, WitchesOfEastEnd) & ExecutiveProducerOf(MaggieFriedman, WitchesOfEastEnd) & LifetimeTelevisionSeries(MaggieFriedman)\nFantasyDrama(WitchesOfEastEnd) & Series(WitchesOfEastEnd)\nProduces(MaggieFriedman, Eastwick) & Develops(MaggieFriedman, Eastwick)\nSeries(Eastwick) & AiredOn(Eastwick, aBC)"
        ],
        "conclusion": "There is a series by ABC that was developed by the showrunner of Witches of East End.",
        "conclusion-FOL": "exists x. exists y. (Series(x) & AiredOn(x, aBC) & Develops(y, x) & ShowRunnerOf(y, WitchesOfEastEnd))",
        "label": "ERROR"
    },
    {
        "premises": "Maggie Friedman is an American screenwriter and producer.\nMaggie Friedman was the showrunner and executive producer of the lifetime television series Witches of East End.\nWitches of East End is a fantasy-drama series.\nMaggie Friedman produced and developed Eastwick.\nEastwick is a series by ABC.",
        "premises-FOL": [
            "American(MaggieFriedman) & Screenwriter(MaggieFriedman) & Producer(MaggieFriedman)\nShowRunnerOf(MaggieFriedman, WitchesOfEastEnd) & ExecutiveProducerOf(MaggieFriedman, WitchesOfEastEnd) & LifetimeTelevisionSeries(MaggieFriedman)\nFantasyDrama(WitchesOfEastEnd) & Series(WitchesOfEastEnd)\nProduces(MaggieFriedman, Eastwick) & Develops(MaggieFriedman, Eastwick)\nSeries(Eastwick) & AiredOn(Eastwick, aBC)"
        ],
        "conclusion": "No series by ABC was developed by the showrunner of Witches of East End.",
        "conclusion-FOL": "all x. (Series(x) & AiredOn(x, aBC) & exists y.(ShowRunnerOf(y, WitchesOfEastEnd)) -> -Develops(y, x))",
        "label": "ERROR"
    },
    {
        "premises": "Maggie Friedman is an American screenwriter and producer.\nMaggie Friedman was the showrunner and executive producer of the lifetime television series Witches of East End.\nWitches of East End is a fantasy-drama series.\nMaggie Friedman produced and developed Eastwick.\nEastwick is a series by ABC.",
        "premises-FOL": [
            "American(MaggieFriedman) & Screenwriter(MaggieFriedman) & Producer(MaggieFriedman)\nShowRunnerOf(MaggieFriedman, WitchesOfEastEnd) & ExecutiveProducerOf(MaggieFriedman, WitchesOfEastEnd) & LifetimeTelevisionSeries(MaggieFriedman)\nFantasyDrama(WitchesOfEastEnd) & Series(WitchesOfEastEnd)\nProduces(MaggieFriedman, Eastwick) & Develops(MaggieFriedman, Eastwick)\nSeries(Eastwick) & AiredOn(Eastwick, aBC)"
        ],
        "conclusion": "Maggie Friedman developed Witches of East End.",
        "conclusion-FOL": "Develops(MaggieFriedman, WitchesOfEastEnd)",
        "label": "ERROR"
    },
    {
        "premises": "Evangelos Eleftheriou is a Greek electrical engineer.\nEvangelos Eleftheriou worked for IBM in Zurich.\nIf a company has employees working for them somewhere, then they have an office there.\nIBM is a company.",
        "premises-FOL": [
            "Greek(EvangelosEleftheriou) & ElectricalEngineer(EvangelosEleftheriou)\nWorkForIn(EvangelosEleftheriou, iBM, Zurich)\nall x. all x. all z. (Company(x) & WorkForIn(y, x, z) -> HaveOfficeIn(x, z))\nCompany(Ibm)"
        ],
        "conclusion": "IBM has an office in London or Zurich or both.",
        "conclusion-FOL": "HaveOfficeIn(Ibm, London) | HaveOfficeIn(Ibm, Zurich)",
        "label": "ERROR"
    },
    {
        "premises": "Evangelos Eleftheriou is a Greek electrical engineer.\nEvangelos Eleftheriou worked for IBM in Zurich.\nIf a company has employees working for them somewhere, then they have an office there.\nIBM is a company.",
        "premises-FOL": [
            "Greek(EvangelosEleftheriou) & ElectricalEngineer(EvangelosEleftheriou)\nWorkForIn(EvangelosEleftheriou, iBM, Zurich)\nall x. all x. all z. (Company(x) & WorkForIn(y, x, z) -> HaveOfficeIn(x, z))\nCompany(Ibm)"
        ],
        "conclusion": "No Greeks have worked for IBM.",
        "conclusion-FOL": "all x. (Greek(x) -> -WorkFor(x, Ibm))",
        "label": "ERROR"
    },
    {
        "premises": "Boney M. had several German #1 singles.\n\"Hooray! Hooray! It's a Holi-Holiday!\" was a big hit all over Europe.\n\"Hooray! Hooray! It's a Holi-Holiday!\" was not in German #1 singles.\nA song that peaks below #1 on the german charts is also a song that is not the #1 single in Germany.",
        "premises-FOL": [
            "exists x. (Song(x) & By(x, Boneym,) & NumberOneGermanSingle(x))\nSong(HoorayHoorayItsAHoliHoliday) & HitAllOverEurope(HoorayHoorayItsAHoliHoliday)\nSong(HoorayHoorayItsAHoliHoliday) & -NumberOneGermanSingle(HoorayHoorayItsAHoliHoliday)\nall x. (PeakBelowOn(x, NumberOne, GermanChart) -> -NumberOneGermanSingle(x))"
        ],
        "conclusion": "\"Hooray! Hooray! It's a Holi-Holiday!\" was the #1 hit in Germany.",
        "conclusion-FOL": "Song(HoorayHoorayItsAHoliHoliday) & NumberOneGermanSingle(HoorayHoorayItsAHoliHoliday)",
        "label": "ERROR"
    },
    {
        "premises": "Boney M. had several German #1 singles.\n\"Hooray! Hooray! It's a Holi-Holiday!\" was a big hit all over Europe.\n\"Hooray! Hooray! It's a Holi-Holiday!\" was not in German #1 singles.\nA song that peaks below #1 on the german charts is also a song that is not the #1 single in Germany.",
        "premises-FOL": [
            "exists x. (Song(x) & By(x, Boneym,) & NumberOneGermanSingle(x))\nSong(HoorayHoorayItsAHoliHoliday) & HitAllOverEurope(HoorayHoorayItsAHoliHoliday)\nSong(HoorayHoorayItsAHoliHoliday) & -NumberOneGermanSingle(HoorayHoorayItsAHoliHoliday)\nall x. (PeakBelowOn(x, NumberOne, GermanChart) -> -NumberOneGermanSingle(x))"
        ],
        "conclusion": "\"Hooray! Hooray! It's a Holi-Holiday!\" peaked below #1 on the German charts.",
        "conclusion-FOL": "PeaksBelowOn(HoorayHoorayItsAHoliHoliday, NumberOne, GermanChart)",
        "label": "ERROR"
    },
    {
        "premises": "Boney M. had several German #1 singles.\n\"Hooray! Hooray! It's a Holi-Holiday!\" was a big hit all over Europe.\n\"Hooray! Hooray! It's a Holi-Holiday!\" was not in German #1 singles.\nA song that peaks below #1 on the german charts is also a song that is not the #1 single in Germany.",
        "premises-FOL": [
            "exists x. (Song(x) & By(x, Boneym,) & NumberOneGermanSingle(x))\nSong(HoorayHoorayItsAHoliHoliday) & HitAllOverEurope(HoorayHoorayItsAHoliHoliday)\nSong(HoorayHoorayItsAHoliHoliday) & -NumberOneGermanSingle(HoorayHoorayItsAHoliHoliday)\nall x. (PeakBelowOn(x, NumberOne, GermanChart) -> -NumberOneGermanSingle(x))"
        ],
        "conclusion": "\"Hooray! Hooray! It's a Holi-Holiday!\" peaked at #3 on the UK charts.",
        "conclusion-FOL": "PeaksAtOn(HoorayHoorayItsAHoliHoliday, NumberThree, GermanChart)",
        "label": "ERROR"
    },
    {
        "premises": "Every chef can cook.\nSome people who aren\u2019t chefs can cook.\nPeople who cook can make scrambled eggs and pasta.\nIf someone can make cookies and muffins, they are a baker.\nBakers who can also make scrambled eggs can make a good breakfast.\nLuke can make cookies, scrambled eggs, and muffins, but not pasta.",
        "premises-FOL": [
            "all x. (Chef(x) -> Can(x, Cook))\nexists x. (-Chef(x) & Can(x, Cook))\nall x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))\nall x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))\nall x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))\nCanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)"
        ],
        "conclusion": "Luke can make a good breakfast.",
        "conclusion-FOL": "CanMake(Luke, GoodBreakfast)",
        "label": "ERROR"
    },
    {
        "premises": "Every chef can cook.\nSome people who aren\u2019t chefs can cook.\nPeople who cook can make scrambled eggs and pasta.\nIf someone can make cookies and muffins, they are a baker.\nBakers who can also make scrambled eggs can make a good breakfast.\nLuke can make cookies, scrambled eggs, and muffins, but not pasta.",
        "premises-FOL": [
            "all x. (Chef(x) -> Can(x, Cook))\nexists x. (-Chef(x) & Can(x, Cook))\nall x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))\nall x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))\nall x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))\nCanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)"
        ],
        "conclusion": "Luke is a chef.",
        "conclusion-FOL": "Chef(Luke)",
        "label": "ERROR"
    },
    {
        "premises": "ETS develops various standardized tests primarily in the United States for K-12 and higher education. \nETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.\nMany of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions. \nETS also develops K-12 statewide assessments used for accountability testing in many states.",
        "premises-FOL": [
            "exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))\nexists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))\nexists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))\nexists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))"
        ],
        "conclusion": "ETS develops assessments for K-12 statewide as well as entry to US tertiary and quaternary education institutions.",
        "conclusion-FOL": "exists x. exists y. (Develop(eTS, x) & StateWideAssesment(x) & Develop(eTS, y) & AssociatedWith(y, EntryToUSEducationInstitution))",
        "label": "ERROR"
    },
    {
        "premises": "ETS develops various standardized tests primarily in the United States for K-12 and higher education. \nETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.\nMany of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions. \nETS also develops K-12 statewide assessments used for accountability testing in many states.",
        "premises-FOL": [
            "exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))\nexists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))\nexists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))\nexists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))"
        ],
        "conclusion": "ETS doesn't administer tests internationally.",
        "conclusion-FOL": "all x. (Administer(eTS, x) -> -InternationalTest(x))",
        "label": "ERROR"
    },
    {
        "premises": "ETS develops various standardized tests primarily in the United States for K-12 and higher education. \nETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.\nMany of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions. \nETS also develops K-12 statewide assessments used for accountability testing in many states.",
        "premises-FOL": [
            "exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))\nexists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))\nexists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))\nexists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))"
        ],
        "conclusion": "ETS administers international tests including the TOEFL, GRE and subject tests in China.",
        "conclusion-FOL": "exists x. (Administer(eTS, x) & InChina(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))",
        "label": "ERROR"
    },
    {
        "premises": "All hodophiles who enjoy eating gelato ice cream would enjoy a vacation to Italy.\nNo hodophiles can resist the hallmark delectable desserts famous in Italy.\nHodophiles enjoy eating gelato ice cream or love to travel and vacation often, or both.\nNo hodophiles who study abroad in Europe regret their college experiences.\nIf hodophiles love to travel and vacation often, then they study abroad in Europe.\nRobert is a hodophile, and he either enjoys eating gelato ice cream and loves to travel and vacation often, or does not enjoy eating gelato ice cream and does not love to travel and vacation often.",
        "premises-FOL": [
            "all x. (Hodophiles(x) & EnjoyEating(x, Gelato) -> Enjoy(x, VacationToItaly))\nall x. (Hodophiles(x) & -(exists y. (Resist(x, y) & Hallmark(y) & Delectabl(y) & Dessert(y) & FamousIn(y, Italy))))\nall x. (Hodophiles(x) -> (EnjoyEating(x, Gelato) | LoveToTravelOften(x))\nall x. (Hodophiles(x) & TakeIn(x, StudyAbroadSemester, Europe) -> -Regret(x, CollegeExperience))\nall x. (Hodophiles(x) & LoveToTravelOften(x) -> TakeIn(x, StudyAbroadSemester, Europe))\nHodophiles(Robert) & -(((EnjoyEating(Robert, Gelato) & -LoveToTravelOften(Robert)) | (-EnjoyEating(Robert, Gelato) & LoveToTravelOften(Robert))))"
        ],
        "conclusion": "Robert can resist the hallmark delectable desserts that are famous in Italy.",
        "conclusion-FOL": "exists y. (Resist(Robert, y) & Hallmark(y) & Delectabl(y) & Dessert(y) & FamousIn(y, Italy))",
        "label": "ERROR"
    },
    {
        "premises": "All hodophiles who enjoy eating gelato ice cream would enjoy a vacation to Italy.\nNo hodophiles can resist the hallmark delectable desserts famous in Italy.\nHodophiles enjoy eating gelato ice cream or love to travel and vacation often, or both.\nNo hodophiles who study abroad in Europe regret their college experiences.\nIf hodophiles love to travel and vacation often, then they study abroad in Europe.\nRobert is a hodophile, and he either enjoys eating gelato ice cream and loves to travel and vacation often, or does not enjoy eating gelato ice cream and does not love to travel and vacation often.",
        "premises-FOL": [
            "all x. (Hodophiles(x) & EnjoyEating(x, Gelato) -> Enjoy(x, VacationToItaly))\nall x. (Hodophiles(x) & -(exists y. (Resist(x, y) & Hallmark(y) & Delectabl(y) & Dessert(y) & FamousIn(y, Italy))))\nall x. (Hodophiles(x) -> (EnjoyEating(x, Gelato) | LoveToTravelOften(x))\nall x. (Hodophiles(x) & TakeIn(x, StudyAbroadSemester, Europe) -> -Regret(x, CollegeExperience))\nall x. (Hodophiles(x) & LoveToTravelOften(x) -> TakeIn(x, StudyAbroadSemester, Europe))\nHodophiles(Robert) & -(((EnjoyEating(Robert, Gelato) & -LoveToTravelOften(Robert)) | (-EnjoyEating(Robert, Gelato) & LoveToTravelOften(Robert))))"
        ],
        "conclusion": "If Robert either would both enjoy a vacation to Italy and regrets his college experiences or neither would enjoy a vacation to Italy nor regrets his college experiences, then Robert would either enjoy a vacation to Italy or he can resist the hallmark delectable desserts that are famous in Italy.",
        "conclusion-FOL": "-((Enjoy(Robert, Vacation) & In(Vacation, Italy)) \u2295 Regret(x, CollegeExperiences)) -> Enjoy(Robert, Vacation) & In(Vacation, Italy) \u2295 (exists y. (Resist(Robert, y) & Hallmark(y) & Delectabl(y) & Dessert(y) & FamousIn(y, Italy))",
        "label": "ERROR"
    },
    {
        "premises": "All hodophiles who enjoy eating gelato ice cream would enjoy a vacation to Italy.\nNo hodophiles can resist the hallmark delectable desserts famous in Italy.\nHodophiles enjoy eating gelato ice cream or love to travel and vacation often, or both.\nNo hodophiles who study abroad in Europe regret their college experiences.\nIf hodophiles love to travel and vacation often, then they study abroad in Europe.\nRobert is a hodophile, and he either enjoys eating gelato ice cream and loves to travel and vacation often, or does not enjoy eating gelato ice cream and does not love to travel and vacation often.",
        "premises-FOL": [
            "all x. (Hodophiles(x) & EnjoyEating(x, Gelato) -> Enjoy(x, VacationToItaly))\nall x. (Hodophiles(x) & -(exists y. (Resist(x, y) & Hallmark(y) & Delectabl(y) & Dessert(y) & FamousIn(y, Italy))))\nall x. (Hodophiles(x) -> (EnjoyEating(x, Gelato) | LoveToTravelOften(x))\nall x. (Hodophiles(x) & TakeIn(x, StudyAbroadSemester, Europe) -> -Regret(x, CollegeExperience))\nall x. (Hodophiles(x) & LoveToTravelOften(x) -> TakeIn(x, StudyAbroadSemester, Europe))\nHodophiles(Robert) & -(((EnjoyEating(Robert, Gelato) & -LoveToTravelOften(Robert)) | (-EnjoyEating(Robert, Gelato) & LoveToTravelOften(Robert))))"
        ],
        "conclusion": "If Robert is not both a person who can resist the hallmark delectable desserts that are famous in Italy and regrets his college experiences, then Robert either enjoys eating gelato ice cream or would enjoy a vacation to Italy.",
        "conclusion-FOL": "(exists y. (Resist(Robert, y) & Hallmark(y) & Delectabl(y) & Dessert(y) & FamousIn(y, Italy))) & Regret(Robert, CollegeExperience)) -> (EnjoyEating(Robert, Gelato) \u2295 (Enjoy(Robert, Vacation) & In(Vacation, Italy))",
        "label": "ERROR"
    },
    {
        "premises": "To have the authorization to study in the United States as a foreigner, you must be enrolled in an academic program.\nThose who are enrolled in an academic program can not work full-time.\nEvery who studies in the United States as a foreigner has the authorization to study in the U.S.\nAll PhD graduate can work full-time. \nIf Tom does not study in the United States as a foreigner, he is enrolled in an academic program.",
        "premises-FOL": [
            "all x. (Have(x, Authorization, StudyIn, UnitedStates) -> EnrolledIn(x, AcademicProgram))\nall x. (EnrolledIn(x, AcademicProgram) -> -Work(x, FullTime))\nall x. (StudyIn(x, UnitedStates) -> Have(x, Authorization, StudyIn, UnitedStates))\nall x. (PhDGraduate(x) -> Work(x, FullTime))\n-StudyIn(x, UnitedStates) -> EnrolledIn(x, AcademicProgram)"
        ],
        "conclusion": "Tom is a PhD graduate.",
        "conclusion-FOL": "PhdGraduate(Tom)",
        "label": "ERROR"
    },
    {
        "premises": "To have the authorization to study in the United States as a foreigner, you must be enrolled in an academic program.\nThose who are enrolled in an academic program can not work full-time.\nEvery who studies in the United States as a foreigner has the authorization to study in the U.S.\nAll PhD graduate can work full-time. \nIf Tom does not study in the United States as a foreigner, he is enrolled in an academic program.",
        "premises-FOL": [
            "all x. (Have(x, Authorization, StudyIn, UnitedStates) -> EnrolledIn(x, AcademicProgram))\nall x. (EnrolledIn(x, AcademicProgram) -> -Work(x, FullTime))\nall x. (StudyIn(x, UnitedStates) -> Have(x, Authorization, StudyIn, UnitedStates))\nall x. (PhDGraduate(x) -> Work(x, FullTime))\n-StudyIn(x, UnitedStates) -> EnrolledIn(x, AcademicProgram)"
        ],
        "conclusion": "Tom is not a PhD graduate.",
        "conclusion-FOL": "-PhdGraduate(Tom)",
        "label": "ERROR"
    },
    {
        "premises": "To have the authorization to study in the United States as a foreigner, you must be enrolled in an academic program.\nThose who are enrolled in an academic program can not work full-time.\nEvery who studies in the United States as a foreigner has the authorization to study in the U.S.\nAll PhD graduate can work full-time. \nIf Tom does not study in the United States as a foreigner, he is enrolled in an academic program.",
        "premises-FOL": [
            "all x. (Have(x, Authorization, StudyIn, UnitedStates) -> EnrolledIn(x, AcademicProgram))\nall x. (EnrolledIn(x, AcademicProgram) -> -Work(x, FullTime))\nall x. (StudyIn(x, UnitedStates) -> Have(x, Authorization, StudyIn, UnitedStates))\nall x. (PhDGraduate(x) -> Work(x, FullTime))\n-StudyIn(x, UnitedStates) -> EnrolledIn(x, AcademicProgram)"
        ],
        "conclusion": "Tom wants to study abroad.",
        "conclusion-FOL": "StudyIn(Tom, UnitedStates)",
        "label": "ERROR"
    },
    {
        "premises": "Islip Speedway is the smallest race track.\nThere was a demolition derby on the smallest race track.\nIslip is either demolished or still being used.\nSpeedways that are still being used have races held at them.\nIslip doesn't have races held at it.",
        "premises-FOL": [
            "Speedway(Islip) & SmallestRaceTrack(Islip)\nexists x. exists y. (DemolitionDerby(x) & SmallestRaceTrack(y) & On(x, y))\n((Demolished(Islip) & -StillUsed(Islip)) | (-Demolished(Islip) & StillUsed(Islip)))\nall x. (Speedway(x) & StillUsed(x) -> Have(Races, HeldAt, x))\n-Have(Races, HeldAt, Islip)"
        ],
        "conclusion": "There has been a demolition derby somewhere that has since been demolished.",
        "conclusion-FOL": "exists x. exists y. (DemolitionDerby(x) & On(x, y) & Demolished(y))",
        "label": "ERROR"
    },
    {
        "premises": "Islip Speedway is the smallest race track.\nThere was a demolition derby on the smallest race track.\nIslip is either demolished or still being used.\nSpeedways that are still being used have races held at them.\nIslip doesn't have races held at it.",
        "premises-FOL": [
            "Speedway(Islip) & SmallestRaceTrack(Islip)\nexists x. exists y. (DemolitionDerby(x) & SmallestRaceTrack(y) & On(x, y))\n((Demolished(Islip) & -StillUsed(Islip)) | (-Demolished(Islip) & StillUsed(Islip)))\nall x. (Speedway(x) & StillUsed(x) -> Have(Races, HeldAt, x))\n-Have(Races, HeldAt, Islip)"
        ],
        "conclusion": "Islip was demolished.",
        "conclusion-FOL": "Demolished(Islip)",
        "label": "ERROR"
    },
    {
        "premises": "Islip Speedway is the smallest race track.\nThere was a demolition derby on the smallest race track.\nIslip is either demolished or still being used.\nSpeedways that are still being used have races held at them.\nIslip doesn't have races held at it.",
        "premises-FOL": [
            "Speedway(Islip) & SmallestRaceTrack(Islip)\nexists x. exists y. (DemolitionDerby(x) & SmallestRaceTrack(y) & On(x, y))\n((Demolished(Islip) & -StillUsed(Islip)) | (-Demolished(Islip) & StillUsed(Islip)))\nall x. (Speedway(x) & StillUsed(x) -> Have(Races, HeldAt, x))\n-Have(Races, HeldAt, Islip)"
        ],
        "conclusion": "Islip is still being used.",
        "conclusion-FOL": "StillUsed(Islip)",
        "label": "ERROR"
    },
    {
        "premises": "If a person pays their taxes, then they contribute to the country. \nEveryone who works for a government department pays a tax on their salary. \nEveryone in the army is an employee of a government department.\nEveryone convicted of murder goes to prison. \nEveryone who has been to prison has a criminal record.\nJames was either once convicted of murder, or spent time in prison.\nJames either has a criminal record, or pays his taxes. ",
        "premises-FOL": [
            "all x. (Taxpayer(x) -> ContributeTo(x, Country))\nall x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))\nall x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))\nall x. (SentencedForMurder(x) -> Imprisoned(x))\nall x. (Imprisoned((x) -> Has(x, CriminalRecord))\n((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James))) \n((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))"
        ],
        "conclusion": "James contributes to the country.",
        "conclusion-FOL": "ContributeToCountry(James)",
        "label": "ERROR"
    },
    {
        "premises": "If a person pays their taxes, then they contribute to the country. \nEveryone who works for a government department pays a tax on their salary. \nEveryone in the army is an employee of a government department.\nEveryone convicted of murder goes to prison. \nEveryone who has been to prison has a criminal record.\nJames was either once convicted of murder, or spent time in prison.\nJames either has a criminal record, or pays his taxes. ",
        "premises-FOL": [
            "all x. (Taxpayer(x) -> ContributeTo(x, Country))\nall x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))\nall x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))\nall x. (SentencedForMurder(x) -> Imprisoned(x))\nall x. (Imprisoned((x) -> Has(x, CriminalRecord))\n((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James))) \n((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))"
        ],
        "conclusion": "James does not contribute to the country.",
        "conclusion-FOL": "-ContributeTo(James, Country)",
        "label": "ERROR"
    },
    {
        "premises": "If a person pays their taxes, then they contribute to the country. \nEveryone who works for a government department pays a tax on their salary. \nEveryone in the army is an employee of a government department.\nEveryone convicted of murder goes to prison. \nEveryone who has been to prison has a criminal record.\nJames was either once convicted of murder, or spent time in prison.\nJames either has a criminal record, or pays his taxes. ",
        "premises-FOL": [
            "all x. (Taxpayer(x) -> ContributeTo(x, Country))\nall x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))\nall x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))\nall x. (SentencedForMurder(x) -> Imprisoned(x))\nall x. (Imprisoned((x) -> Has(x, CriminalRecord))\n((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James))) \n((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))"
        ],
        "conclusion": "James contributes to the country and he serves in the army.",
        "conclusion-FOL": "ContributeTo(James, Country) & ServesIn(James, Army)",
        "label": "ERROR"
    },
    {
        "premises": "If a person pays their taxes, then they contribute to the country. \nEveryone who works for a government department pays a tax on their salary. \nEveryone in the army is an employee of a government department.\nEveryone convicted of murder goes to prison. \nEveryone who has been to prison has a criminal record.\nJames was either once convicted of murder, or spent time in prison.\nJames either has a criminal record, or pays his taxes. ",
        "premises-FOL": [
            "all x. (Taxpayer(x) -> ContributeTo(x, Country))\nall x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))\nall x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))\nall x. (SentencedForMurder(x) -> Imprisoned(x))\nall x. (Imprisoned((x) -> Has(x, CriminalRecord))\n((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James))) \n((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))"
        ],
        "conclusion": "James does not contribute to the country and does not serve in the army.",
        "conclusion-FOL": "-(ContributeTo(James, Country) & ServesIn(James, Army))",
        "label": "ERROR"
    },
    {
        "premises": "The Croton River watershed is the drainage basin of the Croton River.\nThe Croton River is in southwestern New York.\nWater from the Croton River watershed flows to the Bronx.\nThe Bronx is in New York.",
        "premises-FOL": [
            "DrainageBasinOf(CrotonRiverWatershed, CrotonRiver)\nIn(CrotonRiver, SouthwesternNewYork)\nall x. ((Water(x) & In(x, CrotonRiverWatershed)) -> FlowsTo(x, Bronx))\nIn(Bronx, NewYork)"
        ],
        "conclusion": "Water from the Croton River watershed flows to somewhere in New York.",
        "conclusion-FOL": "all x. ((Water(x) & From(x, CrotonRiverWatershed)) -> exists y.(FlowsTo(x, y) & In(y, NewYork)))",
        "label": "ERROR"
    },
    {
        "premises": "The Croton River watershed is the drainage basin of the Croton River.\nThe Croton River is in southwestern New York.\nWater from the Croton River watershed flows to the Bronx.\nThe Bronx is in New York.",
        "premises-FOL": [
            "DrainageBasinOf(CrotonRiverWatershed, CrotonRiver)\nIn(CrotonRiver, SouthwesternNewYork)\nall x. ((Water(x) & In(x, CrotonRiverWatershed)) -> FlowsTo(x, Bronx))\nIn(Bronx, NewYork)"
        ],
        "conclusion": "The Croton River watershed is in the Bronx.",
        "conclusion-FOL": "In(CrotonRiverWatershed, Bronx)",
        "label": "ERROR"
    },
    {
        "premises": "The Croton River watershed is the drainage basin of the Croton River.\nThe Croton River is in southwestern New York.\nWater from the Croton River watershed flows to the Bronx.\nThe Bronx is in New York.",
        "premises-FOL": [
            "DrainageBasinOf(CrotonRiverWatershed, CrotonRiver)\nIn(CrotonRiver, SouthwesternNewYork)\nall x. ((Water(x) & In(x, CrotonRiverWatershed)) -> FlowsTo(x, Bronx))\nIn(Bronx, NewYork)"
        ],
        "conclusion": "Water from the Croton River flows to the Bronx.",
        "conclusion-FOL": "all x. (Water(x) & From(x, CrotonRiver) -> FlowsTo(x, Bronx))",
        "label": "ERROR"
    },
    {
        "premises": "All nuclear-powered submarines are warships.\nNo nuclear-powered submarines are commercial vessels.",
        "premises-FOL": [
            "all x. (NuclearPoweredSubmarine(x) -> Warship(x))\nall x. (NuclearPoweredSubmarine(x) -> -CommercialVessel(x))"
        ],
        "conclusion": "No warships are commercial vessels.",
        "conclusion-FOL": "all x. (Warship(x) -> -CommercialVessel(x))",
        "label": "ERROR"
    },
    {
        "premises": "If an album is written by a rock band, then the genre of the album is rock.\nIf a band writes an album winning an award, then this band wins this award.\nTrouble at the Henhouse is an album by The Tragically Hip.\nThe Tragically Hip is a Canadian rock band.\nThe song \"Butts Wigglin'\" is in Trouble at the Henhouse.\nTrouble at the Henhouse won the Album of the Year award.\nA song in Trouble at the Henhouse appeared in a film.",
        "premises-FOL": [
            "all x. all y. all z. (AlbumByBand(x, y) & RockBand(y, z) -> Genre(x, Rock))\nall x. all y. all z. (AlbumByBand(x, y) & AlbumAward(x, z) -> RockBandAward(y, z))\nAlbumByBand(Trouble_at_the_Henhouse, The_Tragically_Hip)\nRockBand(The_Tragically_Hip, Canada)\nSongInAlbum(Butts_Wigglin, Trouble_at_the_Henhouse)\nAlbumAward(Trouble_at_the_Henhouse, The_Album_of_the_Year)\nexists x. (SongInFilm(x) & SongInAlbum(x, Trouble_at_the_Henhouse))"
        ],
        "conclusion": "The genre of Trouble at the Henhouse is rock.",
        "conclusion-FOL": "Genre(TroubleAtTheHenhouse, Rock)",
        "label": "ERROR"
    },
    {
        "premises": "If an album is written by a rock band, then the genre of the album is rock.\nIf a band writes an album winning an award, then this band wins this award.\nTrouble at the Henhouse is an album by The Tragically Hip.\nThe Tragically Hip is a Canadian rock band.\nThe song \"Butts Wigglin'\" is in Trouble at the Henhouse.\nTrouble at the Henhouse won the Album of the Year award.\nA song in Trouble at the Henhouse appeared in a film.",
        "premises-FOL": [
            "all x. all y. all z. (AlbumByBand(x, y) & RockBand(y, z) -> Genre(x, Rock))\nall x. all y. all z. (AlbumByBand(x, y) & AlbumAward(x, z) -> RockBandAward(y, z))\nAlbumByBand(Trouble_at_the_Henhouse, The_Tragically_Hip)\nRockBand(The_Tragically_Hip, Canada)\nSongInAlbum(Butts_Wigglin, Trouble_at_the_Henhouse)\nAlbumAward(Trouble_at_the_Henhouse, The_Album_of_the_Year)\nexists x. (SongInFilm(x) & SongInAlbum(x, Trouble_at_the_Henhouse))"
        ],
        "conclusion": "No Canadian rock band has won the Album of the Year award.",
        "conclusion-FOL": "-exists x.(RockBand(x, Canada) & Award(x, TheAlbumOfTheYear))",
        "label": "ERROR"
    },
    {
        "premises": "If an album is written by a rock band, then the genre of the album is rock.\nIf a band writes an album winning an award, then this band wins this award.\nTrouble at the Henhouse is an album by The Tragically Hip.\nThe Tragically Hip is a Canadian rock band.\nThe song \"Butts Wigglin'\" is in Trouble at the Henhouse.\nTrouble at the Henhouse won the Album of the Year award.\nA song in Trouble at the Henhouse appeared in a film.",
        "premises-FOL": [
            "all x. all y. all z. (AlbumByBand(x, y) & RockBand(y, z) -> Genre(x, Rock))\nall x. all y. all z. (AlbumByBand(x, y) & AlbumAward(x, z) -> RockBandAward(y, z))\nAlbumByBand(Trouble_at_the_Henhouse, The_Tragically_Hip)\nRockBand(The_Tragically_Hip, Canada)\nSongInAlbum(Butts_Wigglin, Trouble_at_the_Henhouse)\nAlbumAward(Trouble_at_the_Henhouse, The_Album_of_the_Year)\nexists x. (SongInFilm(x) & SongInAlbum(x, Trouble_at_the_Henhouse))"
        ],
        "conclusion": "\"Butts Wigglin'\" appeared in a film.",
        "conclusion-FOL": "SongInFilm(ButtsWigglin)",
        "label": "ERROR"
    },
    {
        "premises": "Daniel is a software engineer, and he works at Palantir Technologies.\nDaniel studied bioengineering during his undergraduate at Rice University.\nDaniel\u2019s older sister works at Meta as a technical sourcer. \nDaniel\u2019s dad and older sister both graduated from Stanford University.\nDaniel\u2019s dad is a doctor practicing internal medicine at a veteran\u2019s hospital in Minneapolis.",
        "premises-FOL": [
            "SoftwareEngineer(Daniel) & WorksAt(Daniel, PalantirTechnologies)\nStudied(Daniel, Bioengineering) & UndergraduateAt(Daniel, RiceUniversity)\nWorksAtMeta(DanielsOlderSister) & TechnicalSourcer(DanielsOlderSister)\n GraduatedFromStanfordUniversity(DanielsOlderSister) & GraduatedFromStanfordUniversity(DanielsDad)\nDoctor(DanielsDad) & Practicing(DanielsDad, InternalMedicine) & PracticingAt(DanielsDad, VeteransHospital) & In(VeteransHospital, Minneapolis)"
        ],
        "conclusion": "Daniel once applied to Stanford University, but he couldn\u2019t get in even though he has family members who are Stanford alumni.",
        "conclusion-FOL": "AppliedTo(Daniel, StanfordUniversity) & -GotInto(Daniel, StanfordUniversity) & Alumni(DanielsFamilyMembers, StanfordUniversity)",
        "label": "ERROR"
    },
    {
        "premises": "Daniel is a software engineer, and he works at Palantir Technologies.\nDaniel studied bioengineering during his undergraduate at Rice University.\nDaniel\u2019s older sister works at Meta as a technical sourcer. \nDaniel\u2019s dad and older sister both graduated from Stanford University.\nDaniel\u2019s dad is a doctor practicing internal medicine at a veteran\u2019s hospital in Minneapolis.",
        "premises-FOL": [
            "SoftwareEngineer(Daniel) & WorksAt(Daniel, PalantirTechnologies)\nStudied(Daniel, Bioengineering) & UndergraduateAt(Daniel, RiceUniversity)\nWorksAtMeta(DanielsOlderSister) & TechnicalSourcer(DanielsOlderSister)\n GraduatedFromStanfordUniversity(DanielsOlderSister) & GraduatedFromStanfordUniversity(DanielsDad)\nDoctor(DanielsDad) & Practicing(DanielsDad, InternalMedicine) & PracticingAt(DanielsDad, VeteransHospital) & In(VeteransHospital, Minneapolis)"
        ],
        "conclusion": "Daniel studied bioengineering as an undergraduate at Rice University.",
        "conclusion-FOL": "Studied(Daniel, Bioengineering) & UndergraduateAt(Daniel, RiceUniversity)",
        "label": "ERROR"
    },
    {
        "premises": "Daniel is a software engineer, and he works at Palantir Technologies.\nDaniel studied bioengineering during his undergraduate at Rice University.\nDaniel\u2019s older sister works at Meta as a technical sourcer. \nDaniel\u2019s dad and older sister both graduated from Stanford University.\nDaniel\u2019s dad is a doctor practicing internal medicine at a veteran\u2019s hospital in Minneapolis.",
        "premises-FOL": [
            "SoftwareEngineer(Daniel) & WorksAt(Daniel, PalantirTechnologies)\nStudied(Daniel, Bioengineering) & UndergraduateAt(Daniel, RiceUniversity)\nWorksAtMeta(DanielsOlderSister) & TechnicalSourcer(DanielsOlderSister)\n GraduatedFromStanfordUniversity(DanielsOlderSister) & GraduatedFromStanfordUniversity(DanielsDad)\nDoctor(DanielsDad) & Practicing(DanielsDad, InternalMedicine) & PracticingAt(DanielsDad, VeteransHospital) & In(VeteransHospital, Minneapolis)"
        ],
        "conclusion": "Daniel and his sister grew up in Minneapolis, Minnesota.",
        "conclusion-FOL": "GrewUpIn(Daniel, Minneapolis) & GrewUpIn(DanielsOlderSister, Minneapolis)",
        "label": "ERROR"
    },
    {
        "premises": "The world's only major large passenger aircraft manufacturers are Boeing and Airbus.\nAll American Airlines planes are from the world's major large passenger aircraft manufacturers. \nAirbus made more revenue than Boeing last year.",
        "premises-FOL": [
            "all x. (WorldMajorLargePassengerAircraftManufacturer(x) -> x=Boeing \u2295 x=Airbus)\nall x. (AmericanAirlinesAircraft(x) -> WorldMajorLargePassengerAircraftManufacturer(x))\nMoreInRevenue(Airbus, Boeing)"
        ],
        "conclusion": "An American Airlines plane is either a Boeing or Airbus plane.",
        "conclusion-FOL": "all x. (AmericanAirlinesPlane(x) -> x=Boeing \u2295 x=Airbus)",
        "label": "ERROR"
    },
    {
        "premises": "The world's only major large passenger aircraft manufacturers are Boeing and Airbus.\nAll American Airlines planes are from the world's major large passenger aircraft manufacturers. \nAirbus made more revenue than Boeing last year.",
        "premises-FOL": [
            "all x. (WorldMajorLargePassengerAircraftManufacturer(x) -> x=Boeing \u2295 x=Airbus)\nall x. (AmericanAirlinesAircraft(x) -> WorldMajorLargePassengerAircraftManufacturer(x))\nMoreInRevenue(Airbus, Boeing)"
        ],
        "conclusion": "There exists a SpaceX commercial aircraft.",
        "conclusion-FOL": "exists x. (CommercialAircraft(x) & x=SpaceX)",
        "label": "ERROR"
    },
    {
        "premises": "The world's only major large passenger aircraft manufacturers are Boeing and Airbus.\nAll American Airlines planes are from the world's major large passenger aircraft manufacturers. \nAirbus made more revenue than Boeing last year.",
        "premises-FOL": [
            "all x. (WorldMajorLargePassengerAircraftManufacturer(x) -> x=Boeing \u2295 x=Airbus)\nall x. (AmericanAirlinesAircraft(x) -> WorldMajorLargePassengerAircraftManufacturer(x))\nMoreInRevenue(Airbus, Boeing)"
        ],
        "conclusion": "There does not exist a United Airlines plane produced by Boeing.",
        "conclusion-FOL": "all x. (UnitedAirlinesAircraft(x) -> -(x=Boeing))",
        "label": "ERROR"
    },
    {
        "premises": "The world's only major large passenger aircraft manufacturers are Boeing and Airbus.\nAll American Airlines planes are from the world's major large passenger aircraft manufacturers. \nAirbus made more revenue than Boeing last year.",
        "premises-FOL": [
            "all x. (WorldMajorLargePassengerAircraftManufacturer(x) -> x=Boeing \u2295 x=Airbus)\nall x. (AmericanAirlinesAircraft(x) -> WorldMajorLargePassengerAircraftManufacturer(x))\nMoreInRevenue(Airbus, Boeing)"
        ],
        "conclusion": "There is a commercial plane made by both Airbus and Boeing.",
        "conclusion-FOL": "exists x. (WorldMajorLargePassengerAircraftManufacturer(x) & ProducedBy(x, Airbus) & ProducedBy(x, Boeing))",
        "label": "ERROR"
    },
    {
        "premises": "Luzon is an island in the Philippines.\nIn December 1999, an earthquake struck Luzon.\nPeople died in the December 1999 earthquake in Luzon.",
        "premises-FOL": [
            "Island(Luzon) & In(Luzon, Philippines)\nexists x. (Earthquake(x) & StrikeInYr(x, YearOneNineNineNine) & StrikeInMo(x, December) & StrikeInCity(x, Luzon))\nexists x. (Earthquake(x) & StrikeInYr(x, YearOneNineNineNine) & StrikeInMo(x, December) & StrikeInCity(x, Luzon) & Deadly(x))"
        ],
        "conclusion": "Leyte is an island in the Philippines.",
        "conclusion-FOL": "Island(Leyte) & In(Leyte, Philippines)",
        "label": "ERROR"
    },
    {
        "premises": "Luzon is an island in the Philippines.\nIn December 1999, an earthquake struck Luzon.\nPeople died in the December 1999 earthquake in Luzon.",
        "premises-FOL": [
            "Island(Luzon) & In(Luzon, Philippines)\nexists x. (Earthquake(x) & StrikeInYr(x, YearOneNineNineNine) & StrikeInMo(x, December) & StrikeInCity(x, Luzon))\nexists x. (Earthquake(x) & StrikeInYr(x, YearOneNineNineNine) & StrikeInMo(x, December) & StrikeInCity(x, Luzon) & Deadly(x))"
        ],
        "conclusion": "No one has ever died in an earthquake that struck the Philippines.",
        "conclusion-FOL": "all x. all y. ((Earthquake(x) & StrikeInCity(x, y) & In(y, Philippines)) -> -Deadly(x))",
        "label": "ERROR"
    },
    {
        "premises": "Luzon is an island in the Philippines.\nIn December 1999, an earthquake struck Luzon.\nPeople died in the December 1999 earthquake in Luzon.",
        "premises-FOL": [
            "Island(Luzon) & In(Luzon, Philippines)\nexists x. (Earthquake(x) & StrikeInYr(x, YearOneNineNineNine) & StrikeInMo(x, December) & StrikeInCity(x, Luzon))\nexists x. (Earthquake(x) & StrikeInYr(x, YearOneNineNineNine) & StrikeInMo(x, December) & StrikeInCity(x, Luzon) & Deadly(x))"
        ],
        "conclusion": "In 1999, there was at least one earthquake in the Philippines.",
        "conclusion-FOL": "exists x. exists y. (Earthquake(x) & StrikeInYr(x, YearOneNineNineNine) & StrikeInMo(x, December) & StrikeInCity(x, y) & In(y, Philippines))",
        "label": "ERROR"
    },
    {
        "premises": "People who like financial risks invest in the public stock market regularly or enjoy gambling regularly.\nIf people invest in the public stock market regularly, then they read the Wall Street Journal and other newspapers regularly to keep updated on financial metrics.\nAll people who enjoy enjoy gambling regularly spend a lot of money at casinos or other betting games.\nPeople who spend a lot of money at casinos and other betting games would enjoy visiting the Las Vegas Strip.\nPeople who spend a lot of money at casinos and other betting games are at risk of gambling addiction.\nMatt does not invest in the public stock market regularly. \nMatt likes financial risks.",
        "premises-FOL": [
            "all x. (Like(x, FinancialRisk) -> InvestInRegularly(x, PublicStockMarket) | EnjoyRegularly(x, Gambling))\nall x. (InvestInRegularly(x, PublicStockMarket) -> ReadToKeepUpdatedOn(x, TheWallStreetJournal, FinancialMetric) | (exists y. (-(y=TheWallStreetJournal) & NewsPaper(y) & ReadToKeepUpdatedOn(x, y, FinancialMetric))))\nall x. (EnjoyRegularly(x, Gambling) -> SpendAt(x, AlotOfMoney, Casino) | (exists y. (-(y=Casino) & BettingGame(y) & SpendAt(x, aLotOfMoney, y)))\nall x. (SpendAt(x, AlotOfMoney, Casino) | (exists y. (-(y=Casino) & BettingGame(y) & SpendAt(x, aLotOfMoney, y))) -> EnjoyVisiting(x, TheLasVegasStrip))\nall x. (SpendAt(x, AlotOfMoney, Casino) | (exists y. (-(y=Casino) & BettingGame(y) & SpendAt(x, aLotOfMoney, y)) -> AtRiskOf(x, GamblingAddiction))\nInvestInRegularly(Matt, PublicStockMarket)\nLike(Matt, FinancialRisk)"
        ],
        "conclusion": "Matt reads the Wall Street Journal and other newspapers regularly to keep updated on financial metrics.",
        "conclusion-FOL": "Newspapers(Matt)",
        "label": "ERROR"
    },
    {
        "premises": "People who like financial risks invest in the public stock market regularly or enjoy gambling regularly.\nIf people invest in the public stock market regularly, then they read the Wall Street Journal and other newspapers regularly to keep updated on financial metrics.\nAll people who enjoy enjoy gambling regularly spend a lot of money at casinos or other betting games.\nPeople who spend a lot of money at casinos and other betting games would enjoy visiting the Las Vegas Strip.\nPeople who spend a lot of money at casinos and other betting games are at risk of gambling addiction.\nMatt does not invest in the public stock market regularly. \nMatt likes financial risks.",
        "premises-FOL": [
            "all x. (Like(x, FinancialRisk) -> InvestInRegularly(x, PublicStockMarket) | EnjoyRegularly(x, Gambling))\nall x. (InvestInRegularly(x, PublicStockMarket) -> ReadToKeepUpdatedOn(x, TheWallStreetJournal, FinancialMetric) | (exists y. (-(y=TheWallStreetJournal) & NewsPaper(y) & ReadToKeepUpdatedOn(x, y, FinancialMetric))))\nall x. (EnjoyRegularly(x, Gambling) -> SpendAt(x, AlotOfMoney, Casino) | (exists y. (-(y=Casino) & BettingGame(y) & SpendAt(x, aLotOfMoney, y)))\nall x. (SpendAt(x, AlotOfMoney, Casino) | (exists y. (-(y=Casino) & BettingGame(y) & SpendAt(x, aLotOfMoney, y))) -> EnjoyVisiting(x, TheLasVegasStrip))\nall x. (SpendAt(x, AlotOfMoney, Casino) | (exists y. (-(y=Casino) & BettingGame(y) & SpendAt(x, aLotOfMoney, y)) -> AtRiskOf(x, GamblingAddiction))\nInvestInRegularly(Matt, PublicStockMarket)\nLike(Matt, FinancialRisk)"
        ],
        "conclusion": "If Matt is either both a person who is at risk of a gambling addiction and invests in the public stock market regularly, or neither is at risk of a gambling addiction nor invests in the public stock market regularly, then Matt neither visits the Las Vegas Strip regularly nor reads the Wall Street Journal and other newspapers regularly to keep updated on the financial metrics.",
        "conclusion-FOL": "((AtRiskOf(Matt, GamblingAddiction) & -InvestInRegularly(Matt, PublicStockMarket)) | (-AtRiskOf(Matt, GamblingAddiction) & InvestInRegularly(Matt, PublicStockMarket))) -> -EnjoyVisiting(Matt, TheLasVegasStrip) &  -(ReadToKeepUpdatedOn(Matt, TheWallStreetJournal, FinancialMetric) |  (exists y. (-(y=TheWallStreetJournal) & NewsPaper(y) & ReadToKeepUpdatedOn(Matt, y, FinancialMetric))))",
        "label": "ERROR"
    },
    {
        "premises": "People who like financial risks invest in the public stock market regularly or enjoy gambling regularly.\nIf people invest in the public stock market regularly, then they read the Wall Street Journal and other newspapers regularly to keep updated on financial metrics.\nAll people who enjoy enjoy gambling regularly spend a lot of money at casinos or other betting games.\nPeople who spend a lot of money at casinos and other betting games would enjoy visiting the Las Vegas Strip.\nPeople who spend a lot of money at casinos and other betting games are at risk of gambling addiction.\nMatt does not invest in the public stock market regularly. \nMatt likes financial risks.",
        "premises-FOL": [
            "all x. (Like(x, FinancialRisk) -> InvestInRegularly(x, PublicStockMarket) | EnjoyRegularly(x, Gambling))\nall x. (InvestInRegularly(x, PublicStockMarket) -> ReadToKeepUpdatedOn(x, TheWallStreetJournal, FinancialMetric) | (exists y. (-(y=TheWallStreetJournal) & NewsPaper(y) & ReadToKeepUpdatedOn(x, y, FinancialMetric))))\nall x. (EnjoyRegularly(x, Gambling) -> SpendAt(x, AlotOfMoney, Casino) | (exists y. (-(y=Casino) & BettingGame(y) & SpendAt(x, aLotOfMoney, y)))\nall x. (SpendAt(x, AlotOfMoney, Casino) | (exists y. (-(y=Casino) & BettingGame(y) & SpendAt(x, aLotOfMoney, y))) -> EnjoyVisiting(x, TheLasVegasStrip))\nall x. (SpendAt(x, AlotOfMoney, Casino) | (exists y. (-(y=Casino) & BettingGame(y) & SpendAt(x, aLotOfMoney, y)) -> AtRiskOf(x, GamblingAddiction))\nInvestInRegularly(Matt, PublicStockMarket)\nLike(Matt, FinancialRisk)"
        ],
        "conclusion": "Matt is not at risk of a gambling addiction and Mike does not both read the Wall Street Journal and other newspapers regularly and visits the Las Vegas Strip regularly.",
        "conclusion-FOL": "-AtRiskOf(Matt, GamblingAddiction) & -(ReadToKeepUpdatedOn(x, TheWallStreetJournal, FinancialMetric) | (exists y. (-(y=TheWallStreetJournal) & NewsPaper(y) & ReadToKeepUpdatedOn(x, y, FinancialMetric))) & EnjoyVisiting(Matt, TheLasVegasStrip))",
        "label": "ERROR"
    },
    {
        "premises": "All students learning piano can strike the right notes. \nAll students who can strike the right note can get the rhythms right. \nIf a student can get the rhythms right, he will start working on coordination between the left and the right hands. \nSome students who start working on coordination between the left and the right hands become good at it, while other students find it challenging. \nIf John can strike the right notes, get the rhythms right, and is good at coordination between right and left hands, then he puts emotions into his playing. \nJohn is a student learning piano. \nJohn does not find coordination between the left and the right hands challenging. ",
        "premises-FOL": [
            "all x. (Student(x) & LearningPiano(x) -> Can(x, Strike, RightNote))\nall x. (Student(x) &  Can(x, Strike, RightNote) -> Can(x, GetTheRhythmRight))\nall x. (Student(x) & Can(x, GetTheRhythmRight) -> Start(x, WorkingOnCoordinationBetweenTheLeftAndRightHands))\nall x. (Student(x) & Start(x, WorkingOnCoordinationBetweenTheLeftAndRightHands) -> ((Become(x, GoodAtCoordination) & -Find(x, CoordinationChallenging)) | (-Become(x, GoodAtCoordination) & Find(x, CoordinationChallenging))))\n(Can(John, GetTheRhythmRight) & Can(John, GetTheRhythmRight)) &  Become(John, GoodAtCoordination)  -> PutEmotionInto(John, HisPlaying)\nStudent(John) & LearningPiano(John)\n-Find(John, CoordinationChallenging)"
        ],
        "conclusion": "John can get the rhythms right.",
        "conclusion-FOL": "Can(John, GetTheRhythmRight)",
        "label": "ERROR"
    },
    {
        "premises": "All students learning piano can strike the right notes. \nAll students who can strike the right note can get the rhythms right. \nIf a student can get the rhythms right, he will start working on coordination between the left and the right hands. \nSome students who start working on coordination between the left and the right hands become good at it, while other students find it challenging. \nIf John can strike the right notes, get the rhythms right, and is good at coordination between right and left hands, then he puts emotions into his playing. \nJohn is a student learning piano. \nJohn does not find coordination between the left and the right hands challenging. ",
        "premises-FOL": [
            "all x. (Student(x) & LearningPiano(x) -> Can(x, Strike, RightNote))\nall x. (Student(x) &  Can(x, Strike, RightNote) -> Can(x, GetTheRhythmRight))\nall x. (Student(x) & Can(x, GetTheRhythmRight) -> Start(x, WorkingOnCoordinationBetweenTheLeftAndRightHands))\nall x. (Student(x) & Start(x, WorkingOnCoordinationBetweenTheLeftAndRightHands) -> ((Become(x, GoodAtCoordination) & -Find(x, CoordinationChallenging)) | (-Become(x, GoodAtCoordination) & Find(x, CoordinationChallenging))))\n(Can(John, GetTheRhythmRight) & Can(John, GetTheRhythmRight)) &  Become(John, GoodAtCoordination)  -> PutEmotionInto(John, HisPlaying)\nStudent(John) & LearningPiano(John)\n-Find(John, CoordinationChallenging)"
        ],
        "conclusion": "John does not put emotions into his playing.",
        "conclusion-FOL": "PutEmotionInto(John, HisPlaying)",
        "label": "ERROR"
    },
    {
        "premises": "Barbara Ann Marshall is a former swimmer and former world record-holder.\nBarbara Ann Marshall participated in the 1972 Summer Olympics.\nBarbara Ann Marshall's home country is the United States.\nAll people who competed in the 1972 Summer Olympics represented their home country.\nBarbara Ann Marshall participated in the preliminary heat in the freestyle relay.\nBarbara Ann Marshall did not participate in the event final of the 1972 Summer Olympics freestyle relay.\nOnly relay swimmers who participated in the final event at the 1972 Summer Olympics received medals.",
        "premises-FOL": [
            "FormerSwimmer(BarbaraAnnMarshall) & FormerWorldRecordHolder(BarbaraAnnMarshall)\nParticipatedIn(BarbaraAnnMarshall, OneNineSevenTwoSummerOlympics)\nHomeCountry(BarbaraAnnMarshall, UnitedStates)\nall x. exists y. (ParticipatedIn(x, OneNineSevenTwoSummerOlympics) & HomeCountry(x, y) -> Represented(x, y))\nParticipatedIn(BarbaraAnnMarshall, PreliminaryHeatFreestyleRelay)\n-ParticipatedIn(BarbaraAnnMarshall, FinalHeatFreestyleRelay)\nall x. ((ParticipatedIn(x, OneNineSevenTwoSummerOlympics) & RelaySwimmer(x) & -ParticipatedIn(x, FinalHeatFreestyleRelay)) <-> -Recieved(x, Medal)))"
        ],
        "conclusion": "Barbara Ann Marshall did not receive medals.",
        "conclusion-FOL": "-Recieved(BarbaraAnnMarshall, Medal)",
        "label": "ERROR"
    },
    {
        "premises": "Barbara Ann Marshall is a former swimmer and former world record-holder.\nBarbara Ann Marshall participated in the 1972 Summer Olympics.\nBarbara Ann Marshall's home country is the United States.\nAll people who competed in the 1972 Summer Olympics represented their home country.\nBarbara Ann Marshall participated in the preliminary heat in the freestyle relay.\nBarbara Ann Marshall did not participate in the event final of the 1972 Summer Olympics freestyle relay.\nOnly relay swimmers who participated in the final event at the 1972 Summer Olympics received medals.",
        "premises-FOL": [
            "FormerSwimmer(BarbaraAnnMarshall) & FormerWorldRecordHolder(BarbaraAnnMarshall)\nParticipatedIn(BarbaraAnnMarshall, OneNineSevenTwoSummerOlympics)\nHomeCountry(BarbaraAnnMarshall, UnitedStates)\nall x. exists y. (ParticipatedIn(x, OneNineSevenTwoSummerOlympics) & HomeCountry(x, y) -> Represented(x, y))\nParticipatedIn(BarbaraAnnMarshall, PreliminaryHeatFreestyleRelay)\n-ParticipatedIn(BarbaraAnnMarshall, FinalHeatFreestyleRelay)\nall x. ((ParticipatedIn(x, OneNineSevenTwoSummerOlympics) & RelaySwimmer(x) & -ParticipatedIn(x, FinalHeatFreestyleRelay)) <-> -Recieved(x, Medal)))"
        ],
        "conclusion": "Barbara Ann Marshall represented the United States in the 1972 Summer Olympics.",
        "conclusion-FOL": "Represented(BarbaraAnnMarshall, UnitedStates)",
        "label": "ERROR"
    },
    {
        "premises": "A game is played with three stages: red stage, yellow stage, and green stage.\nEach player begins at the red stage.\nAll players must reach the yellow stage before they can reach the green stage.\nThe yellow stage comes after the red stage.\nAll players must proceed one stage at a time.",
        "premises-FOL": [
            "exists x. exists y. exists y. exists w. (Game(x) & StageNumber(x,Three) & Stage(y) & Stage(z) & Stage(w) & -(y=z) & -(z=w) & -(y=w) & Red(y) & Yellow(z) & Green(w))\nall x. (Player(x) -> StartRed(x))\nall x. (Player(x) & -ReachYellow(x) -> -ReachGreen(x))\nall x. (Player(x) & StartRed(x) -> ReachYellow(x))\nall x. (Player(x) & StartRed(x) & -ReachYellow(x) -> -ReachGreen(x))"
        ],
        "conclusion": "It is possible to move to the green stage without ever reaching the yellow stage.",
        "conclusion-FOL": "exists x. (Player(x) & RedToGreen(x))",
        "label": "ERROR"
    },
    {
        "premises": "A game is played with three stages: red stage, yellow stage, and green stage.\nEach player begins at the red stage.\nAll players must reach the yellow stage before they can reach the green stage.\nThe yellow stage comes after the red stage.\nAll players must proceed one stage at a time.",
        "premises-FOL": [
            "exists x. exists y. exists y. exists w. (Game(x) & StageNumber(x,Three) & Stage(y) & Stage(z) & Stage(w) & -(y=z) & -(z=w) & -(y=w) & Red(y) & Yellow(z) & Green(w))\nall x. (Player(x) -> StartRed(x))\nall x. (Player(x) & -ReachYellow(x) -> -ReachGreen(x))\nall x. (Player(x) & StartRed(x) -> ReachYellow(x))\nall x. (Player(x) & StartRed(x) & -ReachYellow(x) -> -ReachGreen(x))"
        ],
        "conclusion": "It is possible to reach the yellow stage without ever reaching the green stage.",
        "conclusion-FOL": "exists x. (Player(x) & RedToYellow(x))",
        "label": "ERROR"
    },
    {
        "premises": "A game is played with three stages: red stage, yellow stage, and green stage.\nEach player begins at the red stage.\nAll players must reach the yellow stage before they can reach the green stage.\nThe yellow stage comes after the red stage.\nAll players must proceed one stage at a time.",
        "premises-FOL": [
            "exists x. exists y. exists y. exists w. (Game(x) & StageNumber(x,Three) & Stage(y) & Stage(z) & Stage(w) & -(y=z) & -(z=w) & -(y=w) & Red(y) & Yellow(z) & Green(w))\nall x. (Player(x) -> StartRed(x))\nall x. (Player(x) & -ReachYellow(x) -> -ReachGreen(x))\nall x. (Player(x) & StartRed(x) -> ReachYellow(x))\nall x. (Player(x) & StartRed(x) & -ReachYellow(x) -> -ReachGreen(x))"
        ],
        "conclusion": "It is possible to complete the game without ever reaching the green stage.",
        "conclusion-FOL": "exists x. (Player(x) & CompleteGame(x))",
        "label": "ERROR"
    },
    {
        "premises": "In Love City, everyone considers physical touch or words of affirmation to be their most important love language.\nIf someone in Love City considers physical touch as their most important love language, then they are good with pets.\nIf someone in Love City is good with pets, then they are not scared of animals.\nIn Love City, everyone is scared of animals, or loves animals, or both.\nAdam, who is in Love City, either values physical touch as his most important love language or loves animals.",
        "premises-FOL": [
            "all x. (In(x, LoveCity) -> (ConsidersMostImportantLoveLanguage(x, PhysicalTouch)  | ConsidersMostImportantLoveLanguage(x, WordOfAffirmation))\nall x. ((ConsidersMostImportantLoveLanguage(x, PhysicalTouch)  & In(x, LoveCity) -> GoodWith(x, Pet))\nall x. ((GoodWith(x, Pet) & In(x, LoveCity)) -> -ScaredOf(x, Animal))\nall x. (In(x, LoveCity) -> (ScaredOf(x, Animal) | Loves(x, Animal)))\n(((ConsidersMostImportantLoveLanguage(Adam, PhysicalTouch) & -Loves(Adam, Animal)) | (-ConsidersMostImportantLoveLanguage(Adam, PhysicalTouch) & Loves(Adam, Animal)))) & In(Adam, LoveCity)"
        ],
        "conclusion": "Adam is scared of animals.",
        "conclusion-FOL": "ScaredOf(Adam, Animal)",
        "label": "ERROR"
    },
    {
        "premises": "In Love City, everyone considers physical touch or words of affirmation to be their most important love language.\nIf someone in Love City considers physical touch as their most important love language, then they are good with pets.\nIf someone in Love City is good with pets, then they are not scared of animals.\nIn Love City, everyone is scared of animals, or loves animals, or both.\nAdam, who is in Love City, either values physical touch as his most important love language or loves animals.",
        "premises-FOL": [
            "all x. (In(x, LoveCity) -> (ConsidersMostImportantLoveLanguage(x, PhysicalTouch)  | ConsidersMostImportantLoveLanguage(x, WordOfAffirmation))\nall x. ((ConsidersMostImportantLoveLanguage(x, PhysicalTouch)  & In(x, LoveCity) -> GoodWith(x, Pet))\nall x. ((GoodWith(x, Pet) & In(x, LoveCity)) -> -ScaredOf(x, Animal))\nall x. (In(x, LoveCity) -> (ScaredOf(x, Animal) | Loves(x, Animal)))\n(((ConsidersMostImportantLoveLanguage(Adam, PhysicalTouch) & -Loves(Adam, Animal)) | (-ConsidersMostImportantLoveLanguage(Adam, PhysicalTouch) & Loves(Adam, Animal)))) & In(Adam, LoveCity)"
        ],
        "conclusion": "Adam considers words of affirmation to be the most important love language.",
        "conclusion-FOL": "ConsidersMostImportantLoveLanguage(Adam, WordOfAffirmation)",
        "label": "ERROR"
    },
    {
        "premises": "In Love City, everyone considers physical touch or words of affirmation to be their most important love language.\nIf someone in Love City considers physical touch as their most important love language, then they are good with pets.\nIf someone in Love City is good with pets, then they are not scared of animals.\nIn Love City, everyone is scared of animals, or loves animals, or both.\nAdam, who is in Love City, either values physical touch as his most important love language or loves animals.",
        "premises-FOL": [
            "all x. (In(x, LoveCity) -> (ConsidersMostImportantLoveLanguage(x, PhysicalTouch)  | ConsidersMostImportantLoveLanguage(x, WordOfAffirmation))\nall x. ((ConsidersMostImportantLoveLanguage(x, PhysicalTouch)  & In(x, LoveCity) -> GoodWith(x, Pet))\nall x. ((GoodWith(x, Pet) & In(x, LoveCity)) -> -ScaredOf(x, Animal))\nall x. (In(x, LoveCity) -> (ScaredOf(x, Animal) | Loves(x, Animal)))\n(((ConsidersMostImportantLoveLanguage(Adam, PhysicalTouch) & -Loves(Adam, Animal)) | (-ConsidersMostImportantLoveLanguage(Adam, PhysicalTouch) & Loves(Adam, Animal)))) & In(Adam, LoveCity)"
        ],
        "conclusion": "Adam considers physical touch as the most important love language and considers words of affirmation as the most important love language.",
        "conclusion-FOL": "ConsidersMostImportantLoveLanguage(Adam, PhysicalTouch) & ConsidersMostImportantLoveLanguage(Adam, WordOfAffirmation)",
        "label": "ERROR"
    },
    {
        "premises": "In Love City, everyone considers physical touch or words of affirmation to be their most important love language.\nIf someone in Love City considers physical touch as their most important love language, then they are good with pets.\nIf someone in Love City is good with pets, then they are not scared of animals.\nIn Love City, everyone is scared of animals, or loves animals, or both.\nAdam, who is in Love City, either values physical touch as his most important love language or loves animals.",
        "premises-FOL": [
            "all x. (In(x, LoveCity) -> (ConsidersMostImportantLoveLanguage(x, PhysicalTouch)  | ConsidersMostImportantLoveLanguage(x, WordOfAffirmation))\nall x. ((ConsidersMostImportantLoveLanguage(x, PhysicalTouch)  & In(x, LoveCity) -> GoodWith(x, Pet))\nall x. ((GoodWith(x, Pet) & In(x, LoveCity)) -> -ScaredOf(x, Animal))\nall x. (In(x, LoveCity) -> (ScaredOf(x, Animal) | Loves(x, Animal)))\n(((ConsidersMostImportantLoveLanguage(Adam, PhysicalTouch) & -Loves(Adam, Animal)) | (-ConsidersMostImportantLoveLanguage(Adam, PhysicalTouch) & Loves(Adam, Animal)))) & In(Adam, LoveCity)"
        ],
        "conclusion": "Adam either values physical touch as an especially important love language or values words of affirmation as an especially important love language.",
        "conclusion-FOL": "((ConsidersMostImportantLoveLanguage(Adam, PhysicalTouch) & -ConsidersMostImportantLoveLanguage(Adam, WordOfAffirmation)) | (-ConsidersMostImportantLoveLanguage(Adam, PhysicalTouch) & ConsidersMostImportantLoveLanguage(Adam, WordOfAffirmation)))",
        "label": "ERROR"
    },
    {
        "premises": "In Love City, everyone considers physical touch or words of affirmation to be their most important love language.\nIf someone in Love City considers physical touch as their most important love language, then they are good with pets.\nIf someone in Love City is good with pets, then they are not scared of animals.\nIn Love City, everyone is scared of animals, or loves animals, or both.\nAdam, who is in Love City, either values physical touch as his most important love language or loves animals.",
        "premises-FOL": [
            "all x. (In(x, LoveCity) -> (ConsidersMostImportantLoveLanguage(x, PhysicalTouch)  | ConsidersMostImportantLoveLanguage(x, WordOfAffirmation))\nall x. ((ConsidersMostImportantLoveLanguage(x, PhysicalTouch)  & In(x, LoveCity) -> GoodWith(x, Pet))\nall x. ((GoodWith(x, Pet) & In(x, LoveCity)) -> -ScaredOf(x, Animal))\nall x. (In(x, LoveCity) -> (ScaredOf(x, Animal) | Loves(x, Animal)))\n(((ConsidersMostImportantLoveLanguage(Adam, PhysicalTouch) & -Loves(Adam, Animal)) | (-ConsidersMostImportantLoveLanguage(Adam, PhysicalTouch) & Loves(Adam, Animal)))) & In(Adam, LoveCity)"
        ],
        "conclusion": "If Adam values physical touch as an especially important love language or is good with pets, then Adam values words of affirmation as an especially important love language.",
        "conclusion-FOL": "(ConsidersMostImportantLoveLanguage(Adam, PhysicalTouch, MostImportantLoveLanguage) | GoodWith(x, Pet)) -> ConsidersMostImportantLoveLanguage(Adam, WordOfAffirmation)",
        "label": "ERROR"
    },
    {
        "premises": "All birds have wings.\nAnimals with wings aren't reptiles.\nSome animals that fly are birds.\nIf something is an iguana, then it is a reptile. Simeng: All iguanas are reptiles. \nJohn is either both an iguana and a bird, or he is neither. \nJohn is an animal. ",
        "premises-FOL": [
            "all x. (Bird(x) -> exists y. exists z. (-(y=z) & Wing(y) & Wing(z) & Have(x, y) & Have(x, z)))\nall x. (Animal(x) & (exists y. exists z. (-(y=z) & Wing(y) & Wing(z) & Have(x, y) & Have(x, z))) -> -Reptile(x))\nexists x. (Animal(x) & Fly(x) & Bird(x))\nall x. (Iguana(x) -> Reptile(x))\n-(((Iguana(John) & -Bird(John)) | (-Iguana(John) & Bird(John))))\nAnimal(John)"
        ],
        "conclusion": "John is a reptile.",
        "conclusion-FOL": "Reptile(John)",
        "label": "ERROR"
    },
    {
        "premises": "All birds have wings.\nAnimals with wings aren't reptiles.\nSome animals that fly are birds.\nIf something is an iguana, then it is a reptile. Simeng: All iguanas are reptiles. \nJohn is either both an iguana and a bird, or he is neither. \nJohn is an animal. ",
        "premises-FOL": [
            "all x. (Bird(x) -> exists y. exists z. (-(y=z) & Wing(y) & Wing(z) & Have(x, y) & Have(x, z)))\nall x. (Animal(x) & (exists y. exists z. (-(y=z) & Wing(y) & Wing(z) & Have(x, y) & Have(x, z))) -> -Reptile(x))\nexists x. (Animal(x) & Fly(x) & Bird(x))\nall x. (Iguana(x) -> Reptile(x))\n-(((Iguana(John) & -Bird(John)) | (-Iguana(John) & Bird(John))))\nAnimal(John)"
        ],
        "conclusion": "John is not both an iguana and an animal that can fly.",
        "conclusion-FOL": "-(Iguana(John) & Fly(John))",
        "label": "ERROR"
    },
    {
        "premises": "All birds have wings.\nAnimals with wings aren't reptiles.\nSome animals that fly are birds.\nIf something is an iguana, then it is a reptile. Simeng: All iguanas are reptiles. \nJohn is either both an iguana and a bird, or he is neither. \nJohn is an animal. ",
        "premises-FOL": [
            "all x. (Bird(x) -> exists y. exists z. (-(y=z) & Wing(y) & Wing(z) & Have(x, y) & Have(x, z)))\nall x. (Animal(x) & (exists y. exists z. (-(y=z) & Wing(y) & Wing(z) & Have(x, y) & Have(x, z))) -> -Reptile(x))\nexists x. (Animal(x) & Fly(x) & Bird(x))\nall x. (Iguana(x) -> Reptile(x))\n-(((Iguana(John) & -Bird(John)) | (-Iguana(John) & Bird(John))))\nAnimal(John)"
        ],
        "conclusion": "John is an animal that can fly and John is a bird.",
        "conclusion-FOL": "Animal(John) & Fly(John) & Bird(John)",
        "label": "ERROR"
    },
    {
        "premises": "EndGame is a movie released in 2006.\nEndGame was set in Washington.\nEndGame was filmed outside of Washington.\nSome movies are filmed in New York.\nAndy Chang directed EndGame.\nAndy Chang is from Hong Kong.",
        "premises-FOL": [
            "Movie(EndGame) & Released(EndGame, YrTwoZeroZeroSix)\nSetIn(EndGame, Washington)\n-(FilmedIn(EndGame, Washington))\nexists xexists y.(FilmedIn(x, NewYork) & (-(x=y)) & FilmedIn(y, NewYork))\nDirected(AndyChang, EndGame)\nFrom(AndyChang, HongKong)"
        ],
        "conclusion": "EndGame was filmed in New York.",
        "conclusion-FOL": "FilmedIn(EndGame, NewYork)",
        "label": "ERROR"
    },
    {
        "premises": "EndGame is a movie released in 2006.\nEndGame was set in Washington.\nEndGame was filmed outside of Washington.\nSome movies are filmed in New York.\nAndy Chang directed EndGame.\nAndy Chang is from Hong Kong.",
        "premises-FOL": [
            "Movie(EndGame) & Released(EndGame, YrTwoZeroZeroSix)\nSetIn(EndGame, Washington)\n-(FilmedIn(EndGame, Washington))\nexists xexists y.(FilmedIn(x, NewYork) & (-(x=y)) & FilmedIn(y, NewYork))\nDirected(AndyChang, EndGame)\nFrom(AndyChang, HongKong)"
        ],
        "conclusion": "EndGame was not directed by someone from Hong Kong.",
        "conclusion-FOL": "all x. (-(Directed(x, EndGame) & From(x, HongKong)))",
        "label": "ERROR"
    },
    {
        "premises": "EndGame is a movie released in 2006.\nEndGame was set in Washington.\nEndGame was filmed outside of Washington.\nSome movies are filmed in New York.\nAndy Chang directed EndGame.\nAndy Chang is from Hong Kong.",
        "premises-FOL": [
            "Movie(EndGame) & Released(EndGame, YrTwoZeroZeroSix)\nSetIn(EndGame, Washington)\n-(FilmedIn(EndGame, Washington))\nexists xexists y.(FilmedIn(x, NewYork) & (-(x=y)) & FilmedIn(y, NewYork))\nDirected(AndyChang, EndGame)\nFrom(AndyChang, HongKong)"
        ],
        "conclusion": "All of Andy Chang's movies are filmed outside of Washington.",
        "conclusion-FOL": "all x. (Directed(AndyChang, x) -> -(FilmedIn(x, Washington)))",
        "label": "ERROR"
    },
    {
        "premises": "Six, seven and eight are real numbers.\nIf a real number equals another real number added by one, the first number is larger.\nIf the number x is larger than the number y, then y is not larger than x.\nSeven equals six plus one.\nEight equals seven plus one.\nTwo is positive.\nIf a number is positive, then the double of it is also positive.\nEight is the double of four.\nFour is the double of two.",
        "premises-FOL": [
            "RealNum(NumSix) & RealNum(NumSeven) & RealNum(NumEight)\nall x. all y. ((RealNum(x) & RealNum(y) & IsSuccessorOf(x, y)) -> Larger(x, y))\nall x. all y. (Larger(x, y) -> -Larger(y, x))\nexists y.(IsSuccessorOf(y, NumSix) & Equals(NumSeven, y))\nexists y.(IsSuccessorOf(y, NumSeven) & Equals(NumEight, y))\nPositive(NumTwo)\nall x. all y. ((Positive(x) & IsDouble(y, x)) -> Positive(y))\nIsDouble(NumEight, NumFour)\nIsDouble(NumFour, NumTwo)"
        ],
        "conclusion": "Eight is larger than seven.",
        "conclusion-FOL": "Larger(Eight, Seven)",
        "label": "ERROR"
    },
    {
        "premises": "Six, seven and eight are real numbers.\nIf a real number equals another real number added by one, the first number is larger.\nIf the number x is larger than the number y, then y is not larger than x.\nSeven equals six plus one.\nEight equals seven plus one.\nTwo is positive.\nIf a number is positive, then the double of it is also positive.\nEight is the double of four.\nFour is the double of two.",
        "premises-FOL": [
            "RealNum(NumSix) & RealNum(NumSeven) & RealNum(NumEight)\nall x. all y. ((RealNum(x) & RealNum(y) & IsSuccessorOf(x, y)) -> Larger(x, y))\nall x. all y. (Larger(x, y) -> -Larger(y, x))\nexists y.(IsSuccessorOf(y, NumSix) & Equals(NumSeven, y))\nexists y.(IsSuccessorOf(y, NumSeven) & Equals(NumEight, y))\nPositive(NumTwo)\nall x. all y. ((Positive(x) & IsDouble(y, x)) -> Positive(y))\nIsDouble(NumEight, NumFour)\nIsDouble(NumFour, NumTwo)"
        ],
        "conclusion": "Eight is positive.",
        "conclusion-FOL": "Positive(Eight)",
        "label": "ERROR"
    },
    {
        "premises": "Six, seven and eight are real numbers.\nIf a real number equals another real number added by one, the first number is larger.\nIf the number x is larger than the number y, then y is not larger than x.\nSeven equals six plus one.\nEight equals seven plus one.\nTwo is positive.\nIf a number is positive, then the double of it is also positive.\nEight is the double of four.\nFour is the double of two.",
        "premises-FOL": [
            "RealNum(NumSix) & RealNum(NumSeven) & RealNum(NumEight)\nall x. all y. ((RealNum(x) & RealNum(y) & IsSuccessorOf(x, y)) -> Larger(x, y))\nall x. all y. (Larger(x, y) -> -Larger(y, x))\nexists y.(IsSuccessorOf(y, NumSix) & Equals(NumSeven, y))\nexists y.(IsSuccessorOf(y, NumSeven) & Equals(NumEight, y))\nPositive(NumTwo)\nall x. all y. ((Positive(x) & IsDouble(y, x)) -> Positive(y))\nIsDouble(NumEight, NumFour)\nIsDouble(NumFour, NumTwo)"
        ],
        "conclusion": "Six is larger than seven.",
        "conclusion-FOL": "Larger(Six, Seven)",
        "label": "ERROR"
    },
    {
        "premises": "All dogs sleep.\nSome four-legged animals are dogs.",
        "premises-FOL": [
            "all x. (Dog(x) -> Sleep(x))\nexists x. exists y. (FourLegged(x) & Animal(x) & Dog(x) & FourLegged(y) & Animal(y) & Dog(y) & -(x=y))"
        ],
        "conclusion": "Some four-legged animals sleep.",
        "conclusion-FOL": "exists x. exists y. (FourLegged(x) & Animal(x) & Sleeps(x) & FourLegged(y) & Animal(y) & Sleeps(y) & -(x=y))",
        "label": "ERROR"
    },
    {
        "premises": "Everyone who is entitled to national social insurance coverage can have their medical bills partially covered. \nAll PRC nationals are entitled to national social insurance coverage.\nEveryone in the Franco-China diplomatic conference is either a PRC national or a French national, but not both. \nAll French nationals are citizens of the European Union. \nAll Spanish nationals are citizens of the European Union. \nNo North Korean nationals are citizens of the European Union. \nMei is at the Franco-China diplomatic conference. \nEither Mei is a North Korean and can have medical bills partially covered, or neither is true.",
        "premises-FOL": [
            "all x. (EntitledTo(x, NationalSocialInsuranceCoverage) -> CanHavePartiallyCovered(x, MedicalBills))\nall x. (PRCNational(x) -> EntitledTo(x, NationalSocialInsuranceCoverage))\nall x. (In(x, Franco-ChinaDiplomaticConference) -> ((PRCNational(x) & -FrenchNational(x)) | (-PRCNational(x) & FrenchNational(x))))\nall x. (FrenchNational(x) -> CitizenOf(x, EuropeanUnion))\nall x. (SpanishNational(x) -> CitizenOf(x, EuropeanUnion))\nall x. (NorthKoreanNational(x) -> -CitizenOf(x, EuropeanUnion))\nIn(Mei, Franco-ChinaDiplomaticConference)\n-(((NorthKoreanNational(Mei) & -CanHavePartiallyCovered(Mei, MedicalBills)) | (-NorthKoreanNational(Mei) & CanHavePartiallyCovered(Mei, MedicalBills))))"
        ],
        "conclusion": "Mei is a PRC national.",
        "conclusion-FOL": "PRCNational(Mei)",
        "label": "ERROR"
    },
    {
        "premises": "Everyone who is entitled to national social insurance coverage can have their medical bills partially covered. \nAll PRC nationals are entitled to national social insurance coverage.\nEveryone in the Franco-China diplomatic conference is either a PRC national or a French national, but not both. \nAll French nationals are citizens of the European Union. \nAll Spanish nationals are citizens of the European Union. \nNo North Korean nationals are citizens of the European Union. \nMei is at the Franco-China diplomatic conference. \nEither Mei is a North Korean and can have medical bills partially covered, or neither is true.",
        "premises-FOL": [
            "all x. (EntitledTo(x, NationalSocialInsuranceCoverage) -> CanHavePartiallyCovered(x, MedicalBills))\nall x. (PRCNational(x) -> EntitledTo(x, NationalSocialInsuranceCoverage))\nall x. (In(x, Franco-ChinaDiplomaticConference) -> ((PRCNational(x) & -FrenchNational(x)) | (-PRCNational(x) & FrenchNational(x))))\nall x. (FrenchNational(x) -> CitizenOf(x, EuropeanUnion))\nall x. (SpanishNational(x) -> CitizenOf(x, EuropeanUnion))\nall x. (NorthKoreanNational(x) -> -CitizenOf(x, EuropeanUnion))\nIn(Mei, Franco-ChinaDiplomaticConference)\n-(((NorthKoreanNational(Mei) & -CanHavePartiallyCovered(Mei, MedicalBills)) | (-NorthKoreanNational(Mei) & CanHavePartiallyCovered(Mei, MedicalBills))))"
        ],
        "conclusion": "Mei is not a PRC national.",
        "conclusion-FOL": "-PRCNational(Mei)",
        "label": "ERROR"
    },
    {
        "premises": "Everyone who is entitled to national social insurance coverage can have their medical bills partially covered. \nAll PRC nationals are entitled to national social insurance coverage.\nEveryone in the Franco-China diplomatic conference is either a PRC national or a French national, but not both. \nAll French nationals are citizens of the European Union. \nAll Spanish nationals are citizens of the European Union. \nNo North Korean nationals are citizens of the European Union. \nMei is at the Franco-China diplomatic conference. \nEither Mei is a North Korean and can have medical bills partially covered, or neither is true.",
        "premises-FOL": [
            "all x. (EntitledTo(x, NationalSocialInsuranceCoverage) -> CanHavePartiallyCovered(x, MedicalBills))\nall x. (PRCNational(x) -> EntitledTo(x, NationalSocialInsuranceCoverage))\nall x. (In(x, Franco-ChinaDiplomaticConference) -> ((PRCNational(x) & -FrenchNational(x)) | (-PRCNational(x) & FrenchNational(x))))\nall x. (FrenchNational(x) -> CitizenOf(x, EuropeanUnion))\nall x. (SpanishNational(x) -> CitizenOf(x, EuropeanUnion))\nall x. (NorthKoreanNational(x) -> -CitizenOf(x, EuropeanUnion))\nIn(Mei, Franco-ChinaDiplomaticConference)\n-(((NorthKoreanNational(Mei) & -CanHavePartiallyCovered(Mei, MedicalBills)) | (-NorthKoreanNational(Mei) & CanHavePartiallyCovered(Mei, MedicalBills))))"
        ],
        "conclusion": "If Mei is either a North Korean or a Spanish national, then Mei is either both a French national and a citizen of the European Union, or neither a French national nor a citizen of the European Union.",
        "conclusion-FOL": "((NorthKoreanNational(Mei) & -SpanishNational(Mei)) | (-NorthKoreanNational(Mei) & SpanishNational(Mei))) -> -(((FrenchNational(Mei) & -European(Mei)) | (-FrenchNational(Mei) & European(Mei))))",
        "label": "ERROR"
    },
    {
        "premises": "No people who do not admit a mistake are good teachers.\nSome well-informed people are people who do not admit a mistake.",
        "premises-FOL": [
            "all x. (-Admit(x, Mistake) -> -GoodTeacher(x))\nexists x. exists y. (WellInformed(x) & WellInformed(y) & -Admit(x, Mistake) & -Admit(y, Mistake) & -(x=y))"
        ],
        "conclusion": "Some good teachers are not well-informed people.",
        "conclusion-FOL": "exists x. exists y. (GoodTeacher(x) & GoodTeacher(y) & -WellInformed(x) & -WellInformed(y) & -(x=y))",
        "label": "ERROR"
    },
    {
        "premises": "Philatelic literature is divided into the following categories: Stamp catalogs, Periodicals, Auction catalogs, Books, Bibliographies, and Background Material.\nMort is not a Stamp catalog.\nMort is not a periodical, auction catalog, bibliography, or background material.\nMort is a piece of Philatelic literature.",
        "premises-FOL": [
            "all x. (PhilatelicLit(x) -> (Stamp(x) | Periodical(x) | Auction(x) | Book(x) | Bibliography(x) | Background(x)))\n-Stamp(Mort)\n-(Periodical(Mort) | Auction(Mort) | Bibliography(Mort) | Background(Mort))\nPhilatelicLit(Mort)"
        ],
        "conclusion": "Mort is background material.",
        "conclusion-FOL": "Background(Mort)",
        "label": "ERROR"
    },
    {
        "premises": "Philatelic literature is divided into the following categories: Stamp catalogs, Periodicals, Auction catalogs, Books, Bibliographies, and Background Material.\nMort is not a Stamp catalog.\nMort is not a periodical, auction catalog, bibliography, or background material.\nMort is a piece of Philatelic literature.",
        "premises-FOL": [
            "all x. (PhilatelicLit(x) -> (Stamp(x) | Periodical(x) | Auction(x) | Book(x) | Bibliography(x) | Background(x)))\n-Stamp(Mort)\n-(Periodical(Mort) | Auction(Mort) | Bibliography(Mort) | Background(Mort))\nPhilatelicLit(Mort)"
        ],
        "conclusion": "Eragon is a piece of Philatelic literature.",
        "conclusion-FOL": "PhilatelicLit(Eragon)",
        "label": "ERROR"
    },
    {
        "premises": "Adventures of Rusty is a drama film and children's film.\nColumbia Pictures produced Adventures of Rusty.\nTintin was produced by Paramount.\nTintin is an adventure film.",
        "premises-FOL": [
            "DramaFilm(AdventuresOfRusty) & ChildrensFilm(AdventuresOfRusty)\nProduces(ColumbiaPictures, AdventuresOfRusty)\nProduces(Paramount, Tintin)\nAdventureFilm(Tintin)"
        ],
        "conclusion": "Columbia pictures produced some drama film.",
        "conclusion-FOL": "exists x. (DramaFilm(x) & Produces(ColumbiaPictures, x))",
        "label": "ERROR"
    },
    {
        "premises": "Adventures of Rusty is a drama film and children's film.\nColumbia Pictures produced Adventures of Rusty.\nTintin was produced by Paramount.\nTintin is an adventure film.",
        "premises-FOL": [
            "DramaFilm(AdventuresOfRusty) & ChildrensFilm(AdventuresOfRusty)\nProduces(ColumbiaPictures, AdventuresOfRusty)\nProduces(Paramount, Tintin)\nAdventureFilm(Tintin)"
        ],
        "conclusion": "Columbia pictures produced some adventure film.",
        "conclusion-FOL": "exists x. (AdventureFilm(x) & Produces(ColumbiaPictures, x))",
        "label": "ERROR"
    },
    {
        "premises": "Adventures of Rusty is a drama film and children's film.\nColumbia Pictures produced Adventures of Rusty.\nTintin was produced by Paramount.\nTintin is an adventure film.",
        "premises-FOL": [
            "DramaFilm(AdventuresOfRusty) & ChildrensFilm(AdventuresOfRusty)\nProduces(ColumbiaPictures, AdventuresOfRusty)\nProduces(Paramount, Tintin)\nAdventureFilm(Tintin)"
        ],
        "conclusion": "Paramount produces children's films.",
        "conclusion-FOL": "exists x. (ChildrensFilm(x) & Produces(Paramount, x))",
        "label": "ERROR"
    },
    {
        "premises": "Adventures of Rusty is a drama film and children's film.\nColumbia Pictures produced Adventures of Rusty.\nTintin was produced by Paramount.\nTintin is an adventure film.",
        "premises-FOL": [
            "DramaFilm(AdventuresOfRusty) & ChildrensFilm(AdventuresOfRusty)\nProduces(ColumbiaPictures, AdventuresOfRusty)\nProduces(Paramount, Tintin)\nAdventureFilm(Tintin)"
        ],
        "conclusion": "Paramount produces adventure films.",
        "conclusion-FOL": "exists x. (AdventureFilm(x) & Produces(Paramount, x))",
        "label": "ERROR"
    },
    {
        "premises": "Deng Xiaoping served as the paramount leader of the People's Republic of China.\nDeng Xiaoping was praised for his reaffirmation of the reform program, as well as the reversion of Hong Kong to Chinese control and the return of Macau.\nAs the party's Secretary-General under Mao and Vice Premier in the 1950s, Deng Xiaoping presided over the Anti-Rightist Campaign launched by Mao.\nDeng Xiaoping became instrumental in China's economic reconstruction following the disastrous Great Leap Forward.\nMao Zedong died in 1976.\nAfter Mao Zedong's death, Deng Xiaoping gradually rose to supreme power.",
        "premises-FOL": [
            "ParamountLeaderOf(DengXiaoping, PeoplesRepublicOfChina)\nPraisedFor(DengXiaoping, ReaffirmationOfReformProgram) & PraisedFor(DengXiaoping, ReversionOfHongKong) & PraisedFor(DengXiaoping, ReturnOfMacau)\nPartysSecretaryGeneral(DengXiaoping) & Under(DengXiaoping, Mao) & VicePremierInTheOneNineFiveZeros(DengXiaoping) & PresidedOver(DengXiaoping, AntiRightistCampaign) & LaunchedBy(AntiRightistCampaign, Mao)\nInstrumentalIn(DengXiaoping, ChinasEconomicReconstruction) & Following(ChinasEconomicReconstruction, GreatLeapForward) & Disastrous(GreatLeapForward)\nDiedIn(Mao, YearOneNineSevenSix)\nGraduallyRoseTo(DengXiaoping, SupremePower)"
        ],
        "conclusion": "The paramount leader of the PRC was also the vice premier.",
        "conclusion-FOL": "exists x. (ParamountLeaderOf(x, Prc) & VicePremier(x))",
        "label": "ERROR"
    },
    {
        "premises": "Deng Xiaoping served as the paramount leader of the People's Republic of China.\nDeng Xiaoping was praised for his reaffirmation of the reform program, as well as the reversion of Hong Kong to Chinese control and the return of Macau.\nAs the party's Secretary-General under Mao and Vice Premier in the 1950s, Deng Xiaoping presided over the Anti-Rightist Campaign launched by Mao.\nDeng Xiaoping became instrumental in China's economic reconstruction following the disastrous Great Leap Forward.\nMao Zedong died in 1976.\nAfter Mao Zedong's death, Deng Xiaoping gradually rose to supreme power.",
        "premises-FOL": [
            "ParamountLeaderOf(DengXiaoping, PeoplesRepublicOfChina)\nPraisedFor(DengXiaoping, ReaffirmationOfReformProgram) & PraisedFor(DengXiaoping, ReversionOfHongKong) & PraisedFor(DengXiaoping, ReturnOfMacau)\nPartysSecretaryGeneral(DengXiaoping) & Under(DengXiaoping, Mao) & VicePremierInTheOneNineFiveZeros(DengXiaoping) & PresidedOver(DengXiaoping, AntiRightistCampaign) & LaunchedBy(AntiRightistCampaign, Mao)\nInstrumentalIn(DengXiaoping, ChinasEconomicReconstruction) & Following(ChinasEconomicReconstruction, GreatLeapForward) & Disastrous(GreatLeapForward)\nDiedIn(Mao, YearOneNineSevenSix)\nGraduallyRoseTo(DengXiaoping, SupremePower)"
        ],
        "conclusion": "Deng Xiaoping presided over something launched by someone he was under.",
        "conclusion-FOL": "exists x. exists y. (PresidedOver(Dengxiaoping, x) & Under(Dengxiaoping, y) & LaunchedBy(x, y))",
        "label": "ERROR"
    },
    {
        "premises": "Deng Xiaoping served as the paramount leader of the People's Republic of China.\nDeng Xiaoping was praised for his reaffirmation of the reform program, as well as the reversion of Hong Kong to Chinese control and the return of Macau.\nAs the party's Secretary-General under Mao and Vice Premier in the 1950s, Deng Xiaoping presided over the Anti-Rightist Campaign launched by Mao.\nDeng Xiaoping became instrumental in China's economic reconstruction following the disastrous Great Leap Forward.\nMao Zedong died in 1976.\nAfter Mao Zedong's death, Deng Xiaoping gradually rose to supreme power.",
        "premises-FOL": [
            "ParamountLeaderOf(DengXiaoping, PeoplesRepublicOfChina)\nPraisedFor(DengXiaoping, ReaffirmationOfReformProgram) & PraisedFor(DengXiaoping, ReversionOfHongKong) & PraisedFor(DengXiaoping, ReturnOfMacau)\nPartysSecretaryGeneral(DengXiaoping) & Under(DengXiaoping, Mao) & VicePremierInTheOneNineFiveZeros(DengXiaoping) & PresidedOver(DengXiaoping, AntiRightistCampaign) & LaunchedBy(AntiRightistCampaign, Mao)\nInstrumentalIn(DengXiaoping, ChinasEconomicReconstruction) & Following(ChinasEconomicReconstruction, GreatLeapForward) & Disastrous(GreatLeapForward)\nDiedIn(Mao, YearOneNineSevenSix)\nGraduallyRoseTo(DengXiaoping, SupremePower)"
        ],
        "conclusion": "The person instrumental in china's economic reconstruction gradually rose to supreme power.",
        "conclusion-FOL": "exists x. (InstrumentalIn(x, Chinaseconomicreconstruction) & GraduallyRoseTo(x, Supremepower))",
        "label": "ERROR"
    },
    {
        "premises": "All imaginative processes that Dan knows are results of creative processes.\nAll science fiction that Dan knows comes from an imaginative process.\nEverthing that Dan knows comes from either science-fiction or realistic fiction.\nNo facts that Dan knows have proven to be false.\nDan knows that Dune is science fiction or has proven to be false.",
        "premises-FOL": [
            "all x. ((Knows(Dan, x) & ImaginativeProcess(x)) -> ResultOf(x, CreativeProcess))\nall x. ((Knows(Dan, x) & ScienceFiction(x)) -> ImaginativeProcess(x)) \nall x. (Knows(Dan, x) -> (((ScienceFiction(x) & -RealisticFiction(x)) | (-ScienceFiction(x) & RealisticFiction(x)))))\nall x. ((Knows(Dan, x) & Fact(x)) -> -ProvedToBe(x, False)) \n(Knows(Dan, Dune) & ScienceFiction(Dune)) | ProvedToBe(Dune, False))"
        ],
        "conclusion": "Dune is realistic fiction.",
        "conclusion-FOL": "RealisticFiction(Dune)",
        "label": "ERROR"
    },
    {
        "premises": "All imaginative processes that Dan knows are results of creative processes.\nAll science fiction that Dan knows comes from an imaginative process.\nEverthing that Dan knows comes from either science-fiction or realistic fiction.\nNo facts that Dan knows have proven to be false.\nDan knows that Dune is science fiction or has proven to be false.",
        "premises-FOL": [
            "all x. ((Knows(Dan, x) & ImaginativeProcess(x)) -> ResultOf(x, CreativeProcess))\nall x. ((Knows(Dan, x) & ScienceFiction(x)) -> ImaginativeProcess(x)) \nall x. (Knows(Dan, x) -> (((ScienceFiction(x) & -RealisticFiction(x)) | (-ScienceFiction(x) & RealisticFiction(x)))))\nall x. ((Knows(Dan, x) & Fact(x)) -> -ProvedToBe(x, False)) \n(Knows(Dan, Dune) & ScienceFiction(Dune)) | ProvedToBe(Dune, False))"
        ],
        "conclusion": "Dune is a result of creative and imaginative process.",
        "conclusion-FOL": "ResultOf(Dune, CreativeProcess) & ImaginativeProcess(Dune)",
        "label": "ERROR"
    },
    {
        "premises": "All imaginative processes that Dan knows are results of creative processes.\nAll science fiction that Dan knows comes from an imaginative process.\nEverthing that Dan knows comes from either science-fiction or realistic fiction.\nNo facts that Dan knows have proven to be false.\nDan knows that Dune is science fiction or has proven to be false.",
        "premises-FOL": [
            "all x. ((Knows(Dan, x) & ImaginativeProcess(x)) -> ResultOf(x, CreativeProcess))\nall x. ((Knows(Dan, x) & ScienceFiction(x)) -> ImaginativeProcess(x)) \nall x. (Knows(Dan, x) -> (((ScienceFiction(x) & -RealisticFiction(x)) | (-ScienceFiction(x) & RealisticFiction(x)))))\nall x. ((Knows(Dan, x) & Fact(x)) -> -ProvedToBe(x, False)) \n(Knows(Dan, Dune) & ScienceFiction(Dune)) | ProvedToBe(Dune, False))"
        ],
        "conclusion": "Dune is either a result of creative processes or came from an imaginative process.",
        "conclusion-FOL": "((ResultOf(Dune, CreativeProcess) & -ImaginativeProcess(Dune)) | (-ResultOf(Dune, CreativeProcess) & ImaginativeProcess(Dune)))",
        "label": "ERROR"
    },
    {
        "premises": "All imaginative processes that Dan knows are results of creative processes.\nAll science fiction that Dan knows comes from an imaginative process.\nEverthing that Dan knows comes from either science-fiction or realistic fiction.\nNo facts that Dan knows have proven to be false.\nDan knows that Dune is science fiction or has proven to be false.",
        "premises-FOL": [
            "all x. ((Knows(Dan, x) & ImaginativeProcess(x)) -> ResultOf(x, CreativeProcess))\nall x. ((Knows(Dan, x) & ScienceFiction(x)) -> ImaginativeProcess(x)) \nall x. (Knows(Dan, x) -> (((ScienceFiction(x) & -RealisticFiction(x)) | (-ScienceFiction(x) & RealisticFiction(x)))))\nall x. ((Knows(Dan, x) & Fact(x)) -> -ProvedToBe(x, False)) \n(Knows(Dan, Dune) & ScienceFiction(Dune)) | ProvedToBe(Dune, False))"
        ],
        "conclusion": "Dune is a result of creative processes and is science fiction.",
        "conclusion-FOL": "ResultOf(Dune, CreativeProcess) & ScienceFiction(Dune))",
        "label": "ERROR"
    },
    {
        "premises": "All imaginative processes that Dan knows are results of creative processes.\nAll science fiction that Dan knows comes from an imaginative process.\nEverthing that Dan knows comes from either science-fiction or realistic fiction.\nNo facts that Dan knows have proven to be false.\nDan knows that Dune is science fiction or has proven to be false.",
        "premises-FOL": [
            "all x. ((Knows(Dan, x) & ImaginativeProcess(x)) -> ResultOf(x, CreativeProcess))\nall x. ((Knows(Dan, x) & ScienceFiction(x)) -> ImaginativeProcess(x)) \nall x. (Knows(Dan, x) -> (((ScienceFiction(x) & -RealisticFiction(x)) | (-ScienceFiction(x) & RealisticFiction(x)))))\nall x. ((Knows(Dan, x) & Fact(x)) -> -ProvedToBe(x, False)) \n(Knows(Dan, Dune) & ScienceFiction(Dune)) | ProvedToBe(Dune, False))"
        ],
        "conclusion": "Dune is either a result of creative processes or is science fiction.",
        "conclusion-FOL": "Knows(Dan, Dune) & (ResultOf(Dune, CreativeProcess)  \u2295 ScienceFiction(Dune))",
        "label": "ERROR"
    },
    {
        "premises": "All imaginative processes that Dan knows are results of creative processes.\nAll science fiction that Dan knows comes from an imaginative process.\nEverthing that Dan knows comes from either science-fiction or realistic fiction.\nNo facts that Dan knows have proven to be false.\nDan knows that Dune is science fiction or has proven to be false.",
        "premises-FOL": [
            "all x. ((Knows(Dan, x) & ImaginativeProcess(x)) -> ResultOf(x, CreativeProcess))\nall x. ((Knows(Dan, x) & ScienceFiction(x)) -> ImaginativeProcess(x)) \nall x. (Knows(Dan, x) -> (((ScienceFiction(x) & -RealisticFiction(x)) | (-ScienceFiction(x) & RealisticFiction(x)))))\nall x. ((Knows(Dan, x) & Fact(x)) -> -ProvedToBe(x, False)) \n(Knows(Dan, Dune) & ScienceFiction(Dune)) | ProvedToBe(Dune, False))"
        ],
        "conclusion": "If Dune is a result of creative and imaginative processes, then Dune is not a result of creative processes and science-fiction.",
        "conclusion-FOL": "(ResultOf(Dune, CreativeProcess)  & ImaginativeProcess(Dune)) -> (-ResultOf(Dune, CreativeProcess) & -ScienceFiction(Dune))",
        "label": "ERROR"
    },
    {
        "premises": "All imaginative processes that Dan knows are results of creative processes.\nAll science fiction that Dan knows comes from an imaginative process.\nEverthing that Dan knows comes from either science-fiction or realistic fiction.\nNo facts that Dan knows have proven to be false.\nDan knows that Dune is science fiction or has proven to be false.",
        "premises-FOL": [
            "all x. ((Knows(Dan, x) & ImaginativeProcess(x)) -> ResultOf(x, CreativeProcess))\nall x. ((Knows(Dan, x) & ScienceFiction(x)) -> ImaginativeProcess(x)) \nall x. (Knows(Dan, x) -> (((ScienceFiction(x) & -RealisticFiction(x)) | (-ScienceFiction(x) & RealisticFiction(x)))))\nall x. ((Knows(Dan, x) & Fact(x)) -> -ProvedToBe(x, False)) \n(Knows(Dan, Dune) & ScienceFiction(Dune)) | ProvedToBe(Dune, False))"
        ],
        "conclusion": "If Dune is either a fact and a result of creative processes, or neither a fact nor a result of creative processes, then Dune is a result of creative processes and science-fiction.",
        "conclusion-FOL": "Knows(Dan, Dune) & (-(((Fact(Dune) & -ResultOf(Dune, CreativeProcess)) | (-Fact(Dune) & ResultOf(Dune, CreativeProcess))))) -> (ResultOf(Dune, CreativeProcess) & ScienceFiction(Dune))",
        "label": "ERROR"
    },
    {
        "premises": "All imaginative processes that Dan knows are results of creative processes.\nAll science fiction that Dan knows comes from an imaginative process.\nEverthing that Dan knows comes from either science-fiction or realistic fiction.\nNo facts that Dan knows have proven to be false.\nDan knows that Dune is science fiction or has proven to be false.",
        "premises-FOL": [
            "all x. ((Knows(Dan, x) & ImaginativeProcess(x)) -> ResultOf(x, CreativeProcess))\nall x. ((Knows(Dan, x) & ScienceFiction(x)) -> ImaginativeProcess(x)) \nall x. (Knows(Dan, x) -> (((ScienceFiction(x) & -RealisticFiction(x)) | (-ScienceFiction(x) & RealisticFiction(x)))))\nall x. ((Knows(Dan, x) & Fact(x)) -> -ProvedToBe(x, False)) \n(Knows(Dan, Dune) & ScienceFiction(Dune)) | ProvedToBe(Dune, False))"
        ],
        "conclusion": "If Dune is science-fiction, then Dune is not a result of creative processes and science-fiction.",
        "conclusion-FOL": "Knows(Dan, Dune) & (ScienceFiction(Dune)) -> (-(ResultOf(Dune, CreativeProcess)  & ScienceFiction(Dune)))",
        "label": "ERROR"
    },
    {
        "premises": "All imaginative processes that Dan knows are results of creative processes.\nAll science fiction that Dan knows comes from an imaginative process.\nEverthing that Dan knows comes from either science-fiction or realistic fiction.\nNo facts that Dan knows have proven to be false.\nDan knows that Dune is science fiction or has proven to be false.",
        "premises-FOL": [
            "all x. ((Knows(Dan, x) & ImaginativeProcess(x)) -> ResultOf(x, CreativeProcess))\nall x. ((Knows(Dan, x) & ScienceFiction(x)) -> ImaginativeProcess(x)) \nall x. (Knows(Dan, x) -> (((ScienceFiction(x) & -RealisticFiction(x)) | (-ScienceFiction(x) & RealisticFiction(x)))))\nall x. ((Knows(Dan, x) & Fact(x)) -> -ProvedToBe(x, False)) \n(Knows(Dan, Dune) & ScienceFiction(Dune)) | ProvedToBe(Dune, False))"
        ],
        "conclusion": "If Dune is not a result of creative processes and science-fiction, then Dune neither came from an imaginative process nor proved to be false.",
        "conclusion-FOL": "Knows(Dan, Dune) & (-(ResultOf(Dune, CreativeProcess)  & ScienceFiction(Dune))) -> (-(ImaginativeProcess(Dune) | ProvedToBe(Dune, False)))",
        "label": "ERROR"
    },
    {
        "premises": "All imaginative processes that Dan knows are results of creative processes.\nAll science fiction that Dan knows comes from an imaginative process.\nEverthing that Dan knows comes from either science-fiction or realistic fiction.\nNo facts that Dan knows have proven to be false.\nDan knows that Dune is science fiction or has proven to be false.",
        "premises-FOL": [
            "all x. ((Knows(Dan, x) & ImaginativeProcess(x)) -> ResultOf(x, CreativeProcess))\nall x. ((Knows(Dan, x) & ScienceFiction(x)) -> ImaginativeProcess(x)) \nall x. (Knows(Dan, x) -> (((ScienceFiction(x) & -RealisticFiction(x)) | (-ScienceFiction(x) & RealisticFiction(x)))))\nall x. ((Knows(Dan, x) & Fact(x)) -> -ProvedToBe(x, False)) \n(Knows(Dan, Dune) & ScienceFiction(Dune)) | ProvedToBe(Dune, False))"
        ],
        "conclusion": "If Dune is did not come from imaginative process and is not science-fiction, then Dune is neither a result of creative processes nor came from an imaginative process.",
        "conclusion-FOL": "Knows(Dan, Dune) & (-(ImaginativeProcess(Dune) & ScienceFiction(Dune))) -> (-(ResultOf(Dune, CreativeProcess)  | ImaginativeProcess(Dune)))",
        "label": "ERROR"
    },
    {
        "premises": "American superheroes come from either the DC Universe or Marvel Universe.\nCaptain America is one of America's top-ten favorite superheroes\nCaptain America does not come from the DC Universe.\nAmerica's top-ten favorite superheroes speak English.\nSome superheroes speak both English and Spanish. ",
        "premises-FOL": [
            "all x. (Superhero(x) & American(x) -> ((ComeFrom(x, dCUniverse) & -ComeFrom(x, MarvelUniverse)) | (-ComeFrom(x, dCUniverse) & ComeFrom(x, MarvelUniverse)))) \nAmerican(CaptainAmerica) & TopTenFavorite(CaptainAmerica) & Superhero(CaptainAmerica) \n-ComeFrom(CaptainAmerica, dCUniverse)\nall x. (American(x) & TopTenFavorite(x) & Superhero(x)  -> Speak(x, English)) \nexists x. (Superhero(x) -> (Speak(x, English) & Speak(x, Spanish)))"
        ],
        "conclusion": "Captain America does not speak English.",
        "conclusion-FOL": "-Speak(CaptainAmerica, English)",
        "label": "ERROR"
    },
    {
        "premises": "American superheroes come from either the DC Universe or Marvel Universe.\nCaptain America is one of America's top-ten favorite superheroes\nCaptain America does not come from the DC Universe.\nAmerica's top-ten favorite superheroes speak English.\nSome superheroes speak both English and Spanish. ",
        "premises-FOL": [
            "all x. (Superhero(x) & American(x) -> ((ComeFrom(x, dCUniverse) & -ComeFrom(x, MarvelUniverse)) | (-ComeFrom(x, dCUniverse) & ComeFrom(x, MarvelUniverse)))) \nAmerican(CaptainAmerica) & TopTenFavorite(CaptainAmerica) & Superhero(CaptainAmerica) \n-ComeFrom(CaptainAmerica, dCUniverse)\nall x. (American(x) & TopTenFavorite(x) & Superhero(x)  -> Speak(x, English)) \nexists x. (Superhero(x) -> (Speak(x, English) & Speak(x, Spanish)))"
        ],
        "conclusion": "Captain America comes from the Marvel universe.",
        "conclusion-FOL": "ComeFrom(CaptainAmerica, MarvelUniverse)",
        "label": "ERROR"
    },
    {
        "premises": "American superheroes come from either the DC Universe or Marvel Universe.\nCaptain America is one of America's top-ten favorite superheroes\nCaptain America does not come from the DC Universe.\nAmerica's top-ten favorite superheroes speak English.\nSome superheroes speak both English and Spanish. ",
        "premises-FOL": [
            "all x. (Superhero(x) & American(x) -> ((ComeFrom(x, dCUniverse) & -ComeFrom(x, MarvelUniverse)) | (-ComeFrom(x, dCUniverse) & ComeFrom(x, MarvelUniverse)))) \nAmerican(CaptainAmerica) & TopTenFavorite(CaptainAmerica) & Superhero(CaptainAmerica) \n-ComeFrom(CaptainAmerica, dCUniverse)\nall x. (American(x) & TopTenFavorite(x) & Superhero(x)  -> Speak(x, English)) \nexists x. (Superhero(x) -> (Speak(x, English) & Speak(x, Spanish)))"
        ],
        "conclusion": "Captain America speaks Spanish.",
        "conclusion-FOL": "Speak(CaptainAmerica, Spanish)",
        "label": "ERROR"
    },
    {
        "premises": "Robert Zimmer was a philosopher born in Germany.\nRobert Zimmer is an essayist.\nRobert Zimmer was born in 1953.\nEvery essayist is a writer.",
        "premises-FOL": [
            "BornIn(RobertZimmer, Germany) & Philosopher(RobertZimmer)\nEssayist(RobertZimmer)\nBornIn(RobertZimmer, YrOneNineFiveThree)\nall x. (Essayist(x) -> Writer(x))"
        ],
        "conclusion": "Robert Zimmer is German.",
        "conclusion-FOL": "BornIn(RobertZimmer, Germany)",
        "label": "ERROR"
    },
    {
        "premises": "Robert Zimmer was a philosopher born in Germany.\nRobert Zimmer is an essayist.\nRobert Zimmer was born in 1953.\nEvery essayist is a writer.",
        "premises-FOL": [
            "BornIn(RobertZimmer, Germany) & Philosopher(RobertZimmer)\nEssayist(RobertZimmer)\nBornIn(RobertZimmer, YrOneNineFiveThree)\nall x. (Essayist(x) -> Writer(x))"
        ],
        "conclusion": "Robert Zimmer is not a writer.",
        "conclusion-FOL": "-Writer(RobertZimmer)",
        "label": "ERROR"
    },
    {
        "premises": "Robert Zimmer was a philosopher born in Germany.\nRobert Zimmer is an essayist.\nRobert Zimmer was born in 1953.\nEvery essayist is a writer.",
        "premises-FOL": [
            "BornIn(RobertZimmer, Germany) & Philosopher(RobertZimmer)\nEssayist(RobertZimmer)\nBornIn(RobertZimmer, YrOneNineFiveThree)\nall x. (Essayist(x) -> Writer(x))"
        ],
        "conclusion": "Robert Zimmer is a biographer.",
        "conclusion-FOL": "Biographer(RobertZimmer)",
        "label": "ERROR"
    },
    {
        "premises": "All people who repay their loans on time have a high credit score.\nSome people with high credit scores and high salaries are approved for mortgages.\nJohn has a high salary.",
        "premises-FOL": [
            "all x. (RepayOnTime(x) -> Has(x, HighCreditScore))\nexists x. ((Has(x, HighCreditScore) & Has(x, HighSalary)) -> ApprovedFor(x, Mortgage))\nHas(John, HighSalary)"
        ],
        "conclusion": "If John repays his loans on time, he will be approved for a mortgage.",
        "conclusion-FOL": "RepayOnTime(John) -> ApprovedFor(John, Mortgage)",
        "label": "ERROR"
    },
    {
        "premises": "All students are members of the university.\nAll graduate students are students.\nAll PhD students are graduate students.\nSome PhD students are Teaching Fellows.\nIf John is not a PhD student, then he is not a member of the university.\nIf John is a Teaching Fellow, then he is a PhD student or a graduate student.",
        "premises-FOL": [
            "all x. (Student(x) -> MemberOf(x, University))\nall x. (GraduateStudent(x) -> Student(x))\nall x. (PhDStudent(x) -> GraduateStudent(x))\nexists x. (PhDStudent(x) & TeachingFellow(x))\n-PhDStudent(John) -> -MemberOf(John, University)\nTeachingFellow(John) -> ((PhDStudent(John) & -GraduateStudent(John)) | (-PhDStudent(John) & GraduateStudent(John)))"
        ],
        "conclusion": "John is a Teaching Fellow",
        "conclusion-FOL": "TF(John)",
        "label": "ERROR"
    },
    {
        "premises": "All students are members of the university.\nAll graduate students are students.\nAll PhD students are graduate students.\nSome PhD students are Teaching Fellows.\nIf John is not a PhD student, then he is not a member of the university.\nIf John is a Teaching Fellow, then he is a PhD student or a graduate student.",
        "premises-FOL": [
            "all x. (Student(x) -> MemberOf(x, University))\nall x. (GraduateStudent(x) -> Student(x))\nall x. (PhDStudent(x) -> GraduateStudent(x))\nexists x. (PhDStudent(x) & TeachingFellow(x))\n-PhDStudent(John) -> -MemberOf(John, University)\nTeachingFellow(John) -> ((PhDStudent(John) & -GraduateStudent(John)) | (-PhDStudent(John) & GraduateStudent(John)))"
        ],
        "conclusion": "John is not a Teaching Fellow.",
        "conclusion-FOL": "-TF(John)",
        "label": "ERROR"
    },
    {
        "premises": "All students are members of the university.\nAll graduate students are students.\nAll PhD students are graduate students.\nSome PhD students are Teaching Fellows.\nIf John is not a PhD student, then he is not a member of the university.\nIf John is a Teaching Fellow, then he is a PhD student or a graduate student.",
        "premises-FOL": [
            "all x. (Student(x) -> MemberOf(x, University))\nall x. (GraduateStudent(x) -> Student(x))\nall x. (PhDStudent(x) -> GraduateStudent(x))\nexists x. (PhDStudent(x) & TeachingFellow(x))\n-PhDStudent(John) -> -MemberOf(John, University)\nTeachingFellow(John) -> ((PhDStudent(John) & -GraduateStudent(John)) | (-PhDStudent(John) & GraduateStudent(John)))"
        ],
        "conclusion": "John is a PhD student.",
        "conclusion-FOL": "PhDStudent(John)",
        "label": "ERROR"
    },
    {
        "premises": "Belgium, France, and Germany are European countries.\nParis is the capital of France.\nThe Eiffel Tower is one of the main tourist attractions located in Paris.\nSome people who live in Belgium speak French.\nIf John goes to Europe, he will see some tourist attractions.\nJohn speaks French.",
        "premises-FOL": [
            "EuropeanCountry(Belgium) & EuropeanCountry(France) & EuropeanCountry(Germany)\nCapitalOf(Paris, France)\nTouristAttraction(EiffelTower) & LocatedIn(EiffelTower, Paris)\nexists x. (LiveIn(x, Belgium) -> Speak(x, French))\nexists x. (GoTo(John, Europe) -> (See(John, x) & TouristAttraction(x)))\nSpeak(John, French)"
        ],
        "conclusion": "If John goes to Europe, he will see the Eiffel Tower.",
        "conclusion-FOL": "GoTo(John, Europe) -> See(John, EiffelTower)",
        "label": "ERROR"
    },
    {
        "premises": "Belgium, France, and Germany are European countries.\nParis is the capital of France.\nThe Eiffel Tower is one of the main tourist attractions located in Paris.\nSome people who live in Belgium speak French.\nIf John goes to Europe, he will see some tourist attractions.\nJohn speaks French.",
        "premises-FOL": [
            "EuropeanCountry(Belgium) & EuropeanCountry(France) & EuropeanCountry(Germany)\nCapitalOf(Paris, France)\nTouristAttraction(EiffelTower) & LocatedIn(EiffelTower, Paris)\nexists x. (LiveIn(x, Belgium) -> Speak(x, French))\nexists x. (GoTo(John, Europe) -> (See(John, x) & TouristAttraction(x)))\nSpeak(John, French)"
        ],
        "conclusion": "The Eiffel Tower is located in the capital of France.",
        "conclusion-FOL": "exists x. (CapitalOf(x, France) & LocatedIn(EiffelTower, x))",
        "label": "ERROR"
    },
    {
        "premises": "Belgium, France, and Germany are European countries.\nParis is the capital of France.\nThe Eiffel Tower is one of the main tourist attractions located in Paris.\nSome people who live in Belgium speak French.\nIf John goes to Europe, he will see some tourist attractions.\nJohn speaks French.",
        "premises-FOL": [
            "EuropeanCountry(Belgium) & EuropeanCountry(France) & EuropeanCountry(Germany)\nCapitalOf(Paris, France)\nTouristAttraction(EiffelTower) & LocatedIn(EiffelTower, Paris)\nexists x. (LiveIn(x, Belgium) -> Speak(x, French))\nexists x. (GoTo(John, Europe) -> (See(John, x) & TouristAttraction(x)))\nSpeak(John, French)"
        ],
        "conclusion": "John lives in Belgium.",
        "conclusion-FOL": "LiveIn(John, Belgium)",
        "label": "ERROR"
    },
    {
        "premises": "All sports cars are loud.\nNo loud cars are electric.\nIf a car is a Ferrari, then it is a sports car.\nAll cars made in Maranello are Ferraris.\nThe Toyota Prius is made in Maranello or is a loud car, or both.",
        "premises-FOL": [
            "all x. (SportsCar(x) -> LoudCar(x))\nall x. (LoudCar(x) -> -ElectricCar(x))\nall x. (Ferrari(x) -> SportsCar(x))\nall x. ((Car(x) & MadeIn(x, Maranello)) -> Ferrari(x))\n(Car(ToyotaPrius) & MadeIn(ToyotaPrius, Maranello)) | LoudCar(ToyotaPrius)"
        ],
        "conclusion": "Prius is an electric car.",
        "conclusion-FOL": "ElectricCar(ToyotaPrius)",
        "label": "ERROR"
    },
    {
        "premises": "All sports cars are loud.\nNo loud cars are electric.\nIf a car is a Ferrari, then it is a sports car.\nAll cars made in Maranello are Ferraris.\nThe Toyota Prius is made in Maranello or is a loud car, or both.",
        "premises-FOL": [
            "all x. (SportsCar(x) -> LoudCar(x))\nall x. (LoudCar(x) -> -ElectricCar(x))\nall x. (Ferrari(x) -> SportsCar(x))\nall x. ((Car(x) & MadeIn(x, Maranello)) -> Ferrari(x))\n(Car(ToyotaPrius) & MadeIn(ToyotaPrius, Maranello)) | LoudCar(ToyotaPrius)"
        ],
        "conclusion": "The Toyota Prius is not an electric car.",
        "conclusion-FOL": "-ElectricCar(ToyotaPrius)",
        "label": "ERROR"
    },
    {
        "premises": "All sports cars are loud.\nNo loud cars are electric.\nIf a car is a Ferrari, then it is a sports car.\nAll cars made in Maranello are Ferraris.\nThe Toyota Prius is made in Maranello or is a loud car, or both.",
        "premises-FOL": [
            "all x. (SportsCar(x) -> LoudCar(x))\nall x. (LoudCar(x) -> -ElectricCar(x))\nall x. (Ferrari(x) -> SportsCar(x))\nall x. ((Car(x) & MadeIn(x, Maranello)) -> Ferrari(x))\n(Car(ToyotaPrius) & MadeIn(ToyotaPrius, Maranello)) | LoudCar(ToyotaPrius)"
        ],
        "conclusion": "The Toyota Prius is a equipped with a Ferrari V12 engine.",
        "conclusion-FOL": "MadeIn(ToyotaPrius, Maranello)",
        "label": "ERROR"
    },
    {
        "premises": "All sports cars are loud.\nNo loud cars are electric.\nIf a car is a Ferrari, then it is a sports car.\nAll cars made in Maranello are Ferraris.\nThe Toyota Prius is made in Maranello or is a loud car, or both.",
        "premises-FOL": [
            "all x. (SportsCar(x) -> LoudCar(x))\nall x. (LoudCar(x) -> -ElectricCar(x))\nall x. (Ferrari(x) -> SportsCar(x))\nall x. ((Car(x) & MadeIn(x, Maranello)) -> Ferrari(x))\n(Car(ToyotaPrius) & MadeIn(ToyotaPrius, Maranello)) | LoudCar(ToyotaPrius)"
        ],
        "conclusion": "If The Toyota Prius is a Ferrari or a loud car, then The Toyota Prius is an electric car.",
        "conclusion-FOL": "Ferrari(ToyotaPrius) | LoudCar(ToyotaPrius) -> ElectricCar(ToyotaPrius)",
        "label": "ERROR"
    },
    {
        "premises": "If something is a plant, then it is not a cute animal. Simeng: All plants are not cute animals. \nAll flowers are plants.\nEvery kitten is a cute animal.\nIf something is grown in a garden, then it is a flower.\nPiper is a kitten or a cute animal.",
        "premises-FOL": [
            "all x. (Plant(x) -> -CuteAnimal(x))\nall x. (Flower(x) -> Plant(x))\nall x. (Kitten(x) -> CuteAnimal(x))\nall x. (GrownIn(x, Garden) -> Flower(x))\nKitten(Piper) | CuteAnimal(Piper)"
        ],
        "conclusion": "Piper was grown in a garden.",
        "conclusion-FOL": "GrownIn(Piper, Garden)",
        "label": "ERROR"
    },
    {
        "premises": "If something is a plant, then it is not a cute animal. Simeng: All plants are not cute animals. \nAll flowers are plants.\nEvery kitten is a cute animal.\nIf something is grown in a garden, then it is a flower.\nPiper is a kitten or a cute animal.",
        "premises-FOL": [
            "all x. (Plant(x) -> -CuteAnimal(x))\nall x. (Flower(x) -> Plant(x))\nall x. (Kitten(x) -> CuteAnimal(x))\nall x. (GrownIn(x, Garden) -> Flower(x))\nKitten(Piper) | CuteAnimal(Piper)"
        ],
        "conclusion": "Piper was not grown in a garden.",
        "conclusion-FOL": "-GrownIn(Piper, Garden)",
        "label": "ERROR"
    },
    {
        "premises": "If something is a plant, then it is not a cute animal. Simeng: All plants are not cute animals. \nAll flowers are plants.\nEvery kitten is a cute animal.\nIf something is grown in a garden, then it is a flower.\nPiper is a kitten or a cute animal.",
        "premises-FOL": [
            "all x. (Plant(x) -> -CuteAnimal(x))\nall x. (Flower(x) -> Plant(x))\nall x. (Kitten(x) -> CuteAnimal(x))\nall x. (GrownIn(x, Garden) -> Flower(x))\nKitten(Piper) | CuteAnimal(Piper)"
        ],
        "conclusion": "Piper is a kitten.",
        "conclusion-FOL": "Kitten(Piper)",
        "label": "ERROR"
    },
    {
        "premises": "\nGuam sent an athlete to the Calgary Winter Olympics.\nIf Guan sent an athlete to the Calgary Winter Olympics, then the athelete participated in the Olympics in 1988.\nJudd Bankert is the only athlete from Guam who has ever competed in the Winter Olympics.",
        "premises-FOL": [
            "\nexists x. (Send(Guam, Athlete, CalgaryWinterOlympics))\nall x. (Athlete(x) & SendTo(Guam, x, CalgaryWinterOlympics) -> ParticipatedIn(x, WinterOlympics, YearOneNineEightEight))\nall x. all y. (Athlete(x) & From(x, Guam) & ParticipatedIn(x, WinterOlympics, y) -> x=JuddBankert)"
        ],
        "conclusion": "Judd Bankert competed in the 1988 Winter Olympics.",
        "conclusion-FOL": "ParticipatedIn(JuddBankert, WinterOlympics, YearOneNineEightEight)",
        "label": "ERROR"
    },
    {
        "premises": "\nGuam sent an athlete to the Calgary Winter Olympics.\nIf Guan sent an athlete to the Calgary Winter Olympics, then the athelete participated in the Olympics in 1988.\nJudd Bankert is the only athlete from Guam who has ever competed in the Winter Olympics.",
        "premises-FOL": [
            "\nexists x. (Send(Guam, Athlete, CalgaryWinterOlympics))\nall x. (Athlete(x) & SendTo(Guam, x, CalgaryWinterOlympics) -> ParticipatedIn(x, WinterOlympics, YearOneNineEightEight))\nall x. all y. (Athlete(x) & From(x, Guam) & ParticipatedIn(x, WinterOlympics, y) -> x=JuddBankert)"
        ],
        "conclusion": "Guam has participated in the Summer Olympics at least once.",
        "conclusion-FOL": "exists x. (ParticipatedIn(Guam, SummerOlympics, x))",
        "label": "ERROR"
    },
    {
        "premises": "Michael O'Donnell is a British physician, journalist, author, and broadcaster.\nOne of the word-setters of My Word! was Michael O'Donnell.\nThe magazine World Medicine was edited by Michael O'Donnell.\nMichael O'Donnell was born in Yorkshire as the son of a general practitioner.",
        "premises-FOL": [
            "British(Michael) & Physician(Michael) & Journalist(Michael) & Author(Michael) & Broadcaster(Michael)\nWordSetter(Michael)\nMagazine(WorldMedicine) & EditedBy(WorldMedicine, Michael)\nBornIn(Michael, Yorkshire) & exists x.(SonOf(Michael, x) & GeneralPractitioner(x))"
        ],
        "conclusion": "The son of a general practitioner was a word-setter of My Word!.",
        "conclusion-FOL": "exists x. exists y. (SonOf(x, y) & GeneralPractitioner(y) & WordSetter(x))",
        "label": "ERROR"
    },
    {
        "premises": "Michael O'Donnell is a British physician, journalist, author, and broadcaster.\nOne of the word-setters of My Word! was Michael O'Donnell.\nThe magazine World Medicine was edited by Michael O'Donnell.\nMichael O'Donnell was born in Yorkshire as the son of a general practitioner.",
        "premises-FOL": [
            "British(Michael) & Physician(Michael) & Journalist(Michael) & Author(Michael) & Broadcaster(Michael)\nWordSetter(Michael)\nMagazine(WorldMedicine) & EditedBy(WorldMedicine, Michael)\nBornIn(Michael, Yorkshire) & exists x.(SonOf(Michael, x) & GeneralPractitioner(x))"
        ],
        "conclusion": "World Medicine is not a magazine.",
        "conclusion-FOL": "-Magazine(Worldmedicine)",
        "label": "ERROR"
    },
    {
        "premises": "Michael O'Donnell is a British physician, journalist, author, and broadcaster.\nOne of the word-setters of My Word! was Michael O'Donnell.\nThe magazine World Medicine was edited by Michael O'Donnell.\nMichael O'Donnell was born in Yorkshire as the son of a general practitioner.",
        "premises-FOL": [
            "British(Michael) & Physician(Michael) & Journalist(Michael) & Author(Michael) & Broadcaster(Michael)\nWordSetter(Michael)\nMagazine(WorldMedicine) & EditedBy(WorldMedicine, Michael)\nBornIn(Michael, Yorkshire) & exists x.(SonOf(Michael, x) & GeneralPractitioner(x))"
        ],
        "conclusion": "There are no British authors.",
        "conclusion-FOL": "all x. (British(x) -> -Author(x))",
        "label": "ERROR"
    },
    {
        "premises": "Michael O'Donnell is a British physician, journalist, author, and broadcaster.\nOne of the word-setters of My Word! was Michael O'Donnell.\nThe magazine World Medicine was edited by Michael O'Donnell.\nMichael O'Donnell was born in Yorkshire as the son of a general practitioner.",
        "premises-FOL": [
            "British(Michael) & Physician(Michael) & Journalist(Michael) & Author(Michael) & Broadcaster(Michael)\nWordSetter(Michael)\nMagazine(WorldMedicine) & EditedBy(WorldMedicine, Michael)\nBornIn(Michael, Yorkshire) & exists x.(SonOf(Michael, x) & GeneralPractitioner(x))"
        ],
        "conclusion": "There are no journalists that were born in Yorkshire.",
        "conclusion-FOL": "all x. (Journalist(x) -> -BornIn(x, Yorkshire))",
        "label": "ERROR"
    },
    {
        "premises": "Michael O'Donnell is a British physician, journalist, author, and broadcaster.\nOne of the word-setters of My Word! was Michael O'Donnell.\nThe magazine World Medicine was edited by Michael O'Donnell.\nMichael O'Donnell was born in Yorkshire as the son of a general practitioner.",
        "premises-FOL": [
            "British(Michael) & Physician(Michael) & Journalist(Michael) & Author(Michael) & Broadcaster(Michael)\nWordSetter(Michael)\nMagazine(WorldMedicine) & EditedBy(WorldMedicine, Michael)\nBornIn(Michael, Yorkshire) & exists x.(SonOf(Michael, x) & GeneralPractitioner(x))"
        ],
        "conclusion": "There is a son of a general practitioner that is not an author.",
        "conclusion-FOL": "exists x. exists y. (Son(x, y) & GeneralPractitioner(y) & -Author(x))",
        "label": "ERROR"
    },
    {
        "premises": "No homework is fun.\nSome reading is homework.",
        "premises-FOL": [
            "all x. (Homework(x) -> -Fun(x))\nexists x. (Reading(x) & Homework(x))"
        ],
        "conclusion": "Some reading is fun.",
        "conclusion-FOL": "exists x. (Reading(x) & Fun(x))",
        "label": "ERROR"
    },
    {
        "premises": "The handbrake of a car is either up or down.\nThe handbrake is down when a car is parked.",
        "premises-FOL": [
            "all x. all y. (HandbrakeOf(x, y) & Car(y) -> ((Up(x) & -Down(x)) | (-Up(x) & Down(x))))\nall x. all y. (HandbrakeOf(x, y) & Parked(y) & Car(y) -> Down(x))"
        ],
        "conclusion": "The handbrake is up when some cars are parked.",
        "conclusion-FOL": "exists x. exists y. (HandbrakeOf(x, y) & Parked(y) & Car(y) & Up(x))",
        "label": "ERROR"
    },
    {
        "premises": "All people in this midwest town who own horse ranches regularly ride horses for pleasure and sport.\nAll people in this midwest town with a lot of disposable income have a horse ranch.\nIf people in this midwest town compete in horse dressage shows, then they have a lot of disposable income.\nIf people in this midwest town compete in horse dressage shows, then they have invested in high-quality equestrian gear and equipment.\nIf people in this midwest town regularly ride horses for pleasure and sport, then they do not live in cramped residential buildings.\nManny is in this midwest town, and she either has a horse ranch and lives in a cramped residential building, or she does neither.",
        "premises-FOL": [
            "all x. (InThisMidwestTown(x) & Have(x, HorseRanch) -> RegularlyRideHorseForPleasure(x))\nall x. (InThisMidwestTown(x) & Have(x, DisposableIncome) -> Have(x, HorseRank))\nall x. (InThisMidwestTown(x) & CompeteIn(x, HorseDressageShow) -> Have(x, DisposableIncome))\nall x. (InThisMidwestTown(x) & CompeteIn(x, HorseDressageShow) -> InvestedIn(x, EquestrianGearAndEquipment))\nall x. (InThisMidwestTown(x) & RegularlyRideHorseForPleasure(x) -> -LiveIn(x, CrampedBuilding))\nInThisMidwestTown(Manny) & -(((Have(Manny, HorseRanch) & -LiveIn(Manny, CrampedBuilding)) | (-Have(Manny, HorseRanch) & LiveIn(Manny, CrampedBuilding))))"
        ],
        "conclusion": "Manny regularly rides horses for pleasure and sport.",
        "conclusion-FOL": "RegularlyRideHorsesForPleasure(Manny)",
        "label": "ERROR"
    },
    {
        "premises": "All people in this midwest town who own horse ranches regularly ride horses for pleasure and sport.\nAll people in this midwest town with a lot of disposable income have a horse ranch.\nIf people in this midwest town compete in horse dressage shows, then they have a lot of disposable income.\nIf people in this midwest town compete in horse dressage shows, then they have invested in high-quality equestrian gear and equipment.\nIf people in this midwest town regularly ride horses for pleasure and sport, then they do not live in cramped residential buildings.\nManny is in this midwest town, and she either has a horse ranch and lives in a cramped residential building, or she does neither.",
        "premises-FOL": [
            "all x. (InThisMidwestTown(x) & Have(x, HorseRanch) -> RegularlyRideHorseForPleasure(x))\nall x. (InThisMidwestTown(x) & Have(x, DisposableIncome) -> Have(x, HorseRank))\nall x. (InThisMidwestTown(x) & CompeteIn(x, HorseDressageShow) -> Have(x, DisposableIncome))\nall x. (InThisMidwestTown(x) & CompeteIn(x, HorseDressageShow) -> InvestedIn(x, EquestrianGearAndEquipment))\nall x. (InThisMidwestTown(x) & RegularlyRideHorseForPleasure(x) -> -LiveIn(x, CrampedBuilding))\nInThisMidwestTown(Manny) & -(((Have(Manny, HorseRanch) & -LiveIn(Manny, CrampedBuilding)) | (-Have(Manny, HorseRanch) & LiveIn(Manny, CrampedBuilding))))"
        ],
        "conclusion": "Manny competes in horse dressage shows and has invested in high-quality equestrian equipment and gear.",
        "conclusion-FOL": "CompeteIn(Manny, HorseDressageShow) & InvestedIn(Manny, EquestrianGearAndEquipment)",
        "label": "ERROR"
    },
    {
        "premises": "All people in this midwest town who own horse ranches regularly ride horses for pleasure and sport.\nAll people in this midwest town with a lot of disposable income have a horse ranch.\nIf people in this midwest town compete in horse dressage shows, then they have a lot of disposable income.\nIf people in this midwest town compete in horse dressage shows, then they have invested in high-quality equestrian gear and equipment.\nIf people in this midwest town regularly ride horses for pleasure and sport, then they do not live in cramped residential buildings.\nManny is in this midwest town, and she either has a horse ranch and lives in a cramped residential building, or she does neither.",
        "premises-FOL": [
            "all x. (InThisMidwestTown(x) & Have(x, HorseRanch) -> RegularlyRideHorseForPleasure(x))\nall x. (InThisMidwestTown(x) & Have(x, DisposableIncome) -> Have(x, HorseRank))\nall x. (InThisMidwestTown(x) & CompeteIn(x, HorseDressageShow) -> Have(x, DisposableIncome))\nall x. (InThisMidwestTown(x) & CompeteIn(x, HorseDressageShow) -> InvestedIn(x, EquestrianGearAndEquipment))\nall x. (InThisMidwestTown(x) & RegularlyRideHorseForPleasure(x) -> -LiveIn(x, CrampedBuilding))\nInThisMidwestTown(Manny) & -(((Have(Manny, HorseRanch) & -LiveIn(Manny, CrampedBuilding)) | (-Have(Manny, HorseRanch) & LiveIn(Manny, CrampedBuilding))))"
        ],
        "conclusion": "If Manny either has a horse ranch or competes in horse dressage shows, then Manny has not invested in high-quality equestrian equipment and gear.",
        "conclusion-FOL": "-(((HaveAHorseRanch(Manny) & -CompeteIn(Manny, HorseDressageShow)) | (-HaveAHorseRanch(Manny) & CompeteIn(Manny, HorseDressageShow)))) -> -InvestedIn(Manny, EquestrianGearAndEquipment)",
        "label": "ERROR"
    },
    {
        "premises": "A roundel is a rounded artillery fortification.\nA roundel is not higher than adjacent walls. \nCannons can be deployed on artillery fortifications. \nRoundels are the oldest artillery fortifications.\nBattery towers are artillery fortifications.",
        "premises-FOL": [
            "all x. (Roundel(x) -> (Rounded(x) & ArtilleryFortification(x)))\nall x. all y. ((Roundel(x) & AdjacentWalls(x,y)) -> -Higher(x, y))\nall x. (ArtilleryFortification(x) -> DeployCannons(x))\nall x. all y. ((Roundel(x) & ArtilleryFortification(y)) -> Older(x, y))\nall x. (BatteryTower(x) -> ArtilleryFortification(x))"
        ],
        "conclusion": "Cannons can be deployed on battery towers.",
        "conclusion-FOL": "all x. (BatteryTower(x) -> DeployCannons(x))",
        "label": "ERROR"
    },
    {
        "premises": "A roundel is a rounded artillery fortification.\nA roundel is not higher than adjacent walls. \nCannons can be deployed on artillery fortifications. \nRoundels are the oldest artillery fortifications.\nBattery towers are artillery fortifications.",
        "premises-FOL": [
            "all x. (Roundel(x) -> (Rounded(x) & ArtilleryFortification(x)))\nall x. all y. ((Roundel(x) & AdjacentWalls(x,y)) -> -Higher(x, y))\nall x. (ArtilleryFortification(x) -> DeployCannons(x))\nall x. all y. ((Roundel(x) & ArtilleryFortification(y)) -> Older(x, y))\nall x. (BatteryTower(x) -> ArtilleryFortification(x))"
        ],
        "conclusion": "Roundels are older than battery towers.",
        "conclusion-FOL": "all x. all y. ((Roundel(x) & BatteryTower(y)) -> Older(x, y))",
        "label": "ERROR"
    },
    {
        "premises": "A roundel is a rounded artillery fortification.\nA roundel is not higher than adjacent walls. \nCannons can be deployed on artillery fortifications. \nRoundels are the oldest artillery fortifications.\nBattery towers are artillery fortifications.",
        "premises-FOL": [
            "all x. (Roundel(x) -> (Rounded(x) & ArtilleryFortification(x)))\nall x. all y. ((Roundel(x) & AdjacentWalls(x,y)) -> -Higher(x, y))\nall x. (ArtilleryFortification(x) -> DeployCannons(x))\nall x. all y. ((Roundel(x) & ArtilleryFortification(y)) -> Older(x, y))\nall x. (BatteryTower(x) -> ArtilleryFortification(x))"
        ],
        "conclusion": "Battery towers are higher than adjacent walls.",
        "conclusion-FOL": "all x. all y. ((BatteryTower(x) & AdjacentWall(x,y)) -> Higher(x, y))",
        "label": "ERROR"
    },
    {
        "premises": "A roundel is a rounded artillery fortification.\nA roundel is not higher than adjacent walls. \nCannons can be deployed on artillery fortifications. \nRoundels are the oldest artillery fortifications.\nBattery towers are artillery fortifications.",
        "premises-FOL": [
            "all x. (Roundel(x) -> (Rounded(x) & ArtilleryFortification(x)))\nall x. all y. ((Roundel(x) & AdjacentWalls(x,y)) -> -Higher(x, y))\nall x. (ArtilleryFortification(x) -> DeployCannons(x))\nall x. all y. ((Roundel(x) & ArtilleryFortification(y)) -> Older(x, y))\nall x. (BatteryTower(x) -> ArtilleryFortification(x))"
        ],
        "conclusion": "Cannons can be deployed on roundels.",
        "conclusion-FOL": "all x. (Roundel(x) -> DeployCannons(x))",
        "label": "ERROR"
    },
    {
        "premises": "Tissues are soft.\nSome papers are tissues.",
        "premises-FOL": [
            "all x. (Tissue(x) -> Soft(x))\nexists x. exists y. (Paper(x) & Paper(x) & Tissue(x) & Tissue(y) & -(x=y))"
        ],
        "conclusion": "Some papers are hard.",
        "conclusion-FOL": "exists x. exists y. (Paper(x) & Paper(y) & Hard(x) & Hard(y) & -(x=y))",
        "label": "ERROR"
    },
    {
        "premises": "All volunteers receive intangible benefits for their work.\nVolunteers work regularly or on an as-needed basis.\nSome volunteers are trained.\nVolunteers work in groups or individually.\nEnvironmental volunteers contribute toward environmental management or conservation.\nParticipating in natural disaster response is an example of volunteers working in groups on an as-needed basis.",
        "premises-FOL": [
            "all x. (Volunteer(x) -> Receive(x, IntangibleBenefit))\nall x. (Volunteer(x) -> ((WorkRegularly(x) & -WorkAsNeeded(x)) | (-WorkRegularly(x) & WorkAsNeeded(x))))\nexists x. (Volunteer(x) -> Trained(x))\nall x. (Volunteer(x) -> (WorkInGroup(x) | WorkIndividually(x)))\nall x. (Volunteer(x) & Environmental(x) -> (ContributeTo(x, EnvironmentalManagement) | ContributeTo(x, EnvironmentalConservation)))\nexists x. (Volunteer(x) & ContributeTo(x, NaturalDisasterResponse) -> WorkInGroup(x) & WorkAsNeeded(x))"
        ],
        "conclusion": "Volunteers who participate in natural disaster response receive intangible benefits for their work.",
        "conclusion-FOL": "all x. (Volunteer(x) & ContributeTo(x, NaturalDisasterResponse) -> Receive(x, IntangibleBenefit))",
        "label": "ERROR"
    },
    {
        "premises": "All volunteers receive intangible benefits for their work.\nVolunteers work regularly or on an as-needed basis.\nSome volunteers are trained.\nVolunteers work in groups or individually.\nEnvironmental volunteers contribute toward environmental management or conservation.\nParticipating in natural disaster response is an example of volunteers working in groups on an as-needed basis.",
        "premises-FOL": [
            "all x. (Volunteer(x) -> Receive(x, IntangibleBenefit))\nall x. (Volunteer(x) -> ((WorkRegularly(x) & -WorkAsNeeded(x)) | (-WorkRegularly(x) & WorkAsNeeded(x))))\nexists x. (Volunteer(x) -> Trained(x))\nall x. (Volunteer(x) -> (WorkInGroup(x) | WorkIndividually(x)))\nall x. (Volunteer(x) & Environmental(x) -> (ContributeTo(x, EnvironmentalManagement) | ContributeTo(x, EnvironmentalConservation)))\nexists x. (Volunteer(x) & ContributeTo(x, NaturalDisasterResponse) -> WorkInGroup(x) & WorkAsNeeded(x))"
        ],
        "conclusion": "Environmental volunteers work in groups.",
        "conclusion-FOL": "all x. (Volunteer(x) & Environmental(x) -> WorkInGroup(x))",
        "label": "ERROR"
    },
    {
        "premises": "All volunteers receive intangible benefits for their work.\nVolunteers work regularly or on an as-needed basis.\nSome volunteers are trained.\nVolunteers work in groups or individually.\nEnvironmental volunteers contribute toward environmental management or conservation.\nParticipating in natural disaster response is an example of volunteers working in groups on an as-needed basis.",
        "premises-FOL": [
            "all x. (Volunteer(x) -> Receive(x, IntangibleBenefit))\nall x. (Volunteer(x) -> ((WorkRegularly(x) & -WorkAsNeeded(x)) | (-WorkRegularly(x) & WorkAsNeeded(x))))\nexists x. (Volunteer(x) -> Trained(x))\nall x. (Volunteer(x) -> (WorkInGroup(x) | WorkIndividually(x)))\nall x. (Volunteer(x) & Environmental(x) -> (ContributeTo(x, EnvironmentalManagement) | ContributeTo(x, EnvironmentalConservation)))\nexists x. (Volunteer(x) & ContributeTo(x, NaturalDisasterResponse) -> WorkInGroup(x) & WorkAsNeeded(x))"
        ],
        "conclusion": "To be a volunteer, you must be trained.",
        "conclusion-FOL": "all x. (Volunteer(x) -> Trained(x))",
        "label": "ERROR"
    },
    {
        "premises": "All people in this tech company who are consistent and enjoy sticking to their regular routines do not like surprises.\nPeople in this tech company who wear the same flannel shirts every day are consistent and enjoy sticking to their regular routines.\nPeople in this tech company who do not like shopping for clothes wear the same flannel shirts every day.\nOld people living in stable homes do not like surprises.\nPeople in this tech company who have very high energy and are impulsive like surprises.\nMike works in this tech company.\nIf Mike is not a person who wears the same flannel shirts every day, has very high energy, and is impulsive, then Mike either is very consistent and enjoys sticking to his regular routines or does not like surprises.",
        "premises-FOL": [
            "all x. (InThisTechCompany(x) & Consistent(x) & StickTo(x, TheirRegularRoutine) -> -Like(x, Surprise))\nall x. (InThisTechCompany(x) & exists y. (FlannelShirt(y) & WearEveryday(x, y)) -> Consistent(x) & StickTo(x, TheirRegularRoutine))\nall x. (InThisTechCompany(x) & -LikeShoppingFor(x, Clothes) -> exists y. (FlannelShirt(y) & WearEveryday(x, y)))\nall x. (InThisTechCompany(x) & Old(x) & LiveIn(x, StableHome) -> -Like(x, Surprise))\nall x. (InThisTechCompany(x) & Have(x, HighEnergy) & Impulsive(x) -> -Like(x, Surprise))\nInThisTechCompany(Mike)\n-(exists y. (FlannelShirt(y) & WearEveryday(x, y)) & Have(Mike, HighEnergy) & Impulsive(Mike)) -> (Consistent(Mike) & StickTo(Mike, TheirRegularRoutine)) \u2295 -Like(Mike, Surprise)"
        ],
        "conclusion": "Mike is an old person living in a stable home.",
        "conclusion-FOL": "Old(Mike) & LiveIn(Mike, StableHome)",
        "label": "ERROR"
    },
    {
        "premises": "All people in this tech company who are consistent and enjoy sticking to their regular routines do not like surprises.\nPeople in this tech company who wear the same flannel shirts every day are consistent and enjoy sticking to their regular routines.\nPeople in this tech company who do not like shopping for clothes wear the same flannel shirts every day.\nOld people living in stable homes do not like surprises.\nPeople in this tech company who have very high energy and are impulsive like surprises.\nMike works in this tech company.\nIf Mike is not a person who wears the same flannel shirts every day, has very high energy, and is impulsive, then Mike either is very consistent and enjoys sticking to his regular routines or does not like surprises.",
        "premises-FOL": [
            "all x. (InThisTechCompany(x) & Consistent(x) & StickTo(x, TheirRegularRoutine) -> -Like(x, Surprise))\nall x. (InThisTechCompany(x) & exists y. (FlannelShirt(y) & WearEveryday(x, y)) -> Consistent(x) & StickTo(x, TheirRegularRoutine))\nall x. (InThisTechCompany(x) & -LikeShoppingFor(x, Clothes) -> exists y. (FlannelShirt(y) & WearEveryday(x, y)))\nall x. (InThisTechCompany(x) & Old(x) & LiveIn(x, StableHome) -> -Like(x, Surprise))\nall x. (InThisTechCompany(x) & Have(x, HighEnergy) & Impulsive(x) -> -Like(x, Surprise))\nInThisTechCompany(Mike)\n-(exists y. (FlannelShirt(y) & WearEveryday(x, y)) & Have(Mike, HighEnergy) & Impulsive(Mike)) -> (Consistent(Mike) & StickTo(Mike, TheirRegularRoutine)) \u2295 -Like(Mike, Surprise)"
        ],
        "conclusion": "If Mike wears the same flannel shirts every day or does not like shopping for clothes, then Mike is neither an old person living in a stable home nor does he like shopping for clothes.",
        "conclusion-FOL": "(exists y. (FlannelShirt(y) & WearEveryday(Mike, y)) | -LikeShoppingFor(Mike, Clothes)) -> -(Old(Mike) & LiveIn(Mike, StableHome)) & -LikeShoppingFor(Mike, Clothes)",
        "label": "ERROR"
    },
    {
        "premises": "All people in this tech company who are consistent and enjoy sticking to their regular routines do not like surprises.\nPeople in this tech company who wear the same flannel shirts every day are consistent and enjoy sticking to their regular routines.\nPeople in this tech company who do not like shopping for clothes wear the same flannel shirts every day.\nOld people living in stable homes do not like surprises.\nPeople in this tech company who have very high energy and are impulsive like surprises.\nMike works in this tech company.\nIf Mike is not a person who wears the same flannel shirts every day, has very high energy, and is impulsive, then Mike either is very consistent and enjoys sticking to his regular routines or does not like surprises.",
        "premises-FOL": [
            "all x. (InThisTechCompany(x) & Consistent(x) & StickTo(x, TheirRegularRoutine) -> -Like(x, Surprise))\nall x. (InThisTechCompany(x) & exists y. (FlannelShirt(y) & WearEveryday(x, y)) -> Consistent(x) & StickTo(x, TheirRegularRoutine))\nall x. (InThisTechCompany(x) & -LikeShoppingFor(x, Clothes) -> exists y. (FlannelShirt(y) & WearEveryday(x, y)))\nall x. (InThisTechCompany(x) & Old(x) & LiveIn(x, StableHome) -> -Like(x, Surprise))\nall x. (InThisTechCompany(x) & Have(x, HighEnergy) & Impulsive(x) -> -Like(x, Surprise))\nInThisTechCompany(Mike)\n-(exists y. (FlannelShirt(y) & WearEveryday(x, y)) & Have(Mike, HighEnergy) & Impulsive(Mike)) -> (Consistent(Mike) & StickTo(Mike, TheirRegularRoutine)) \u2295 -Like(Mike, Surprise)"
        ],
        "conclusion": "If Mike is not an old person living in a stable home and does not like shopping for clothes, then Mike does not like shopping for clothes.",
        "conclusion-FOL": "-(Old(Mike) & LiveIn(Mike, StableHome)) & -LikeShoppingFor(Mike, Clothes)) -> -LikeShoppingFor(Mike, Clothes)",
        "label": "ERROR"
    },
    {
        "premises": "Adam owns cars.\nAdam has a favorite car.\nAmong the cars he owns, Adam's favorite car is European.\nAdam broke his favorite car.",
        "premises-FOL": [
            "exists xexists y. (Car(x) & Car(y) & (x\u2260y) & Owns(Adam, x)) \nexists x. (Car(x) & Favorite(Adam, x))\nall x. ((Car(x) & Owns(Adam, x) & Favorite(Adam, x)) -> European(x))\nall x. ((Car(x) & Owns(Adam, x) & Favorite(Adam, x)) -> Broke(Adam, x))"
        ],
        "conclusion": "Adam owns a Japanese car.",
        "conclusion-FOL": "exists x. (Japanese(x) & Owns(Adam, x))",
        "label": "ERROR"
    },
    {
        "premises": "Adam owns cars.\nAdam has a favorite car.\nAmong the cars he owns, Adam's favorite car is European.\nAdam broke his favorite car.",
        "premises-FOL": [
            "exists xexists y. (Car(x) & Car(y) & (x\u2260y) & Owns(Adam, x)) \nexists x. (Car(x) & Favorite(Adam, x))\nall x. ((Car(x) & Owns(Adam, x) & Favorite(Adam, x)) -> European(x))\nall x. ((Car(x) & Owns(Adam, x) & Favorite(Adam, x)) -> Broke(Adam, x))"
        ],
        "conclusion": "Adam broke a European car.",
        "conclusion-FOL": "exists x. (European(x) & Broke(Adam, x))",
        "label": "ERROR"
    },
    {
        "premises": "There are no buildings in New Haven higher than 400 meters. \nAll buildings managed by Yale Housing are in New Haven. \nAll Manhattan skyscrapers are higher than 400 meters. \nAll buildings owned by Bloomberg are in Manhattan. \nAll buildings with the Bloomberg logo are buildings owned by Bloomberg. \nTower A is neither a building in New Haven nor a skyscraper in Manhattan.\nTower B is a skyscraper building in Manhattan with a Bloomberg logo. ",
        "premises-FOL": [
            "all x. ((Buildings(x) & In(x, NewHaven)) -> -HigherThan(x, NumFourZeroZero))\nall x. ((Buildings(x) & ManagedBy(x, YaleHousing)) -> In(x, NewHaven))\nall x. ((Buildings(x) & Skyscraper(x) & In(x, Manhattan)) -> HigherThan(x, NumFourZeroZero))\nall x. ((Buildings(x) & OwnedBy(x, Bloomberg)) -> Skyscraper(x) & In(x, Manhattan))\nall x. ((Buildings(x) & HasLogo(x, Bloomberg)) -> OwnedBy(x, Bloomberg))\nBuildings(TowerA) & (-InNewHaven(TowerA)) & (-ManhattanSkyscraper(TowerA))\nBuildings(TowerB) & HasLogo(TowerB, Bloomberg) & Skyscraper(TowerB) & In(TowerB, Manhattan)"
        ],
        "conclusion": "Tower A is higher than 400 meters.",
        "conclusion-FOL": "HigherThan(TowerA, NumFourZeroZero)",
        "label": "ERROR"
    },
    {
        "premises": "There are no buildings in New Haven higher than 400 meters. \nAll buildings managed by Yale Housing are in New Haven. \nAll Manhattan skyscrapers are higher than 400 meters. \nAll buildings owned by Bloomberg are in Manhattan. \nAll buildings with the Bloomberg logo are buildings owned by Bloomberg. \nTower A is neither a building in New Haven nor a skyscraper in Manhattan.\nTower B is a skyscraper building in Manhattan with a Bloomberg logo. ",
        "premises-FOL": [
            "all x. ((Buildings(x) & In(x, NewHaven)) -> -HigherThan(x, NumFourZeroZero))\nall x. ((Buildings(x) & ManagedBy(x, YaleHousing)) -> In(x, NewHaven))\nall x. ((Buildings(x) & Skyscraper(x) & In(x, Manhattan)) -> HigherThan(x, NumFourZeroZero))\nall x. ((Buildings(x) & OwnedBy(x, Bloomberg)) -> Skyscraper(x) & In(x, Manhattan))\nall x. ((Buildings(x) & HasLogo(x, Bloomberg)) -> OwnedBy(x, Bloomberg))\nBuildings(TowerA) & (-InNewHaven(TowerA)) & (-ManhattanSkyscraper(TowerA))\nBuildings(TowerB) & HasLogo(TowerB, Bloomberg) & Skyscraper(TowerB) & In(TowerB, Manhattan)"
        ],
        "conclusion": "Tower A is not higher than 400 meters.",
        "conclusion-FOL": "-HigherThan(TowerA, NumFourZeroZero)",
        "label": "ERROR"
    },
    {
        "premises": "There are no buildings in New Haven higher than 400 meters. \nAll buildings managed by Yale Housing are in New Haven. \nAll Manhattan skyscrapers are higher than 400 meters. \nAll buildings owned by Bloomberg are in Manhattan. \nAll buildings with the Bloomberg logo are buildings owned by Bloomberg. \nTower A is neither a building in New Haven nor a skyscraper in Manhattan.\nTower B is a skyscraper building in Manhattan with a Bloomberg logo. ",
        "premises-FOL": [
            "all x. ((Buildings(x) & In(x, NewHaven)) -> -HigherThan(x, NumFourZeroZero))\nall x. ((Buildings(x) & ManagedBy(x, YaleHousing)) -> In(x, NewHaven))\nall x. ((Buildings(x) & Skyscraper(x) & In(x, Manhattan)) -> HigherThan(x, NumFourZeroZero))\nall x. ((Buildings(x) & OwnedBy(x, Bloomberg)) -> Skyscraper(x) & In(x, Manhattan))\nall x. ((Buildings(x) & HasLogo(x, Bloomberg)) -> OwnedBy(x, Bloomberg))\nBuildings(TowerA) & (-InNewHaven(TowerA)) & (-ManhattanSkyscraper(TowerA))\nBuildings(TowerB) & HasLogo(TowerB, Bloomberg) & Skyscraper(TowerB) & In(TowerB, Manhattan)"
        ],
        "conclusion": "Tower A is a building with the Bloomberg logo or it is managed by Yale Housing.",
        "conclusion-FOL": "HasLogo(TowerB, Bloomberg) | ManagedBy(x, YaleHousing)",
        "label": "ERROR"
    },
    {
        "premises": "There are no buildings in New Haven higher than 400 meters. \nAll buildings managed by Yale Housing are in New Haven. \nAll Manhattan skyscrapers are higher than 400 meters. \nAll buildings owned by Bloomberg are in Manhattan. \nAll buildings with the Bloomberg logo are buildings owned by Bloomberg. \nTower A is neither a building in New Haven nor a skyscraper in Manhattan.\nTower B is a skyscraper building in Manhattan with a Bloomberg logo. ",
        "premises-FOL": [
            "all x. ((Buildings(x) & In(x, NewHaven)) -> -HigherThan(x, NumFourZeroZero))\nall x. ((Buildings(x) & ManagedBy(x, YaleHousing)) -> In(x, NewHaven))\nall x. ((Buildings(x) & Skyscraper(x) & In(x, Manhattan)) -> HigherThan(x, NumFourZeroZero))\nall x. ((Buildings(x) & OwnedBy(x, Bloomberg)) -> Skyscraper(x) & In(x, Manhattan))\nall x. ((Buildings(x) & HasLogo(x, Bloomberg)) -> OwnedBy(x, Bloomberg))\nBuildings(TowerA) & (-InNewHaven(TowerA)) & (-ManhattanSkyscraper(TowerA))\nBuildings(TowerB) & HasLogo(TowerB, Bloomberg) & Skyscraper(TowerB) & In(TowerB, Manhattan)"
        ],
        "conclusion": "Tower A is neither a building with the Bloomberg logo nor managed by Yale Housing.",
        "conclusion-FOL": "-HasLogo(TowerB, Bloomberg) & (-ManagedBy(x, YaleHousing))",
        "label": "ERROR"
    },
    {
        "premises": "No fish are birds.\nAn osprey is a bird.\nA carp is a fish.\nAll goldfish are carp.\nIf Bubbles is either an osprey or a goldfish, then Bubbles is not also a fish.",
        "premises-FOL": [
            "all x. (Fish(x) -> -Bird(x))\nall x. (Osprey(x) -> Bird(x))\nall x. (Carp(x) -> Fish(x))\nall x. (Goldfish(x) -> Carp(x))\n((Osprey(Bubbles) & -Goldfish(Bubbles)) | (-Osprey(Bubbles) & Goldfish(Bubbles))) -> -Fish(Bubbles)"
        ],
        "conclusion": "Bubbles is an Osprey.",
        "conclusion-FOL": "Osprey(Bubbles)",
        "label": "ERROR"
    },
    {
        "premises": "No fish are birds.\nAn osprey is a bird.\nA carp is a fish.\nAll goldfish are carp.\nIf Bubbles is either an osprey or a goldfish, then Bubbles is not also a fish.",
        "premises-FOL": [
            "all x. (Fish(x) -> -Bird(x))\nall x. (Osprey(x) -> Bird(x))\nall x. (Carp(x) -> Fish(x))\nall x. (Goldfish(x) -> Carp(x))\n((Osprey(Bubbles) & -Goldfish(Bubbles)) | (-Osprey(Bubbles) & Goldfish(Bubbles))) -> -Fish(Bubbles)"
        ],
        "conclusion": "Bubbles is a goldfish.",
        "conclusion-FOL": "Goldfish(Bubbles)",
        "label": "ERROR"
    },
    {
        "premises": "No fish are birds.\nAn osprey is a bird.\nA carp is a fish.\nAll goldfish are carp.\nIf Bubbles is either an osprey or a goldfish, then Bubbles is not also a fish.",
        "premises-FOL": [
            "all x. (Fish(x) -> -Bird(x))\nall x. (Osprey(x) -> Bird(x))\nall x. (Carp(x) -> Fish(x))\nall x. (Goldfish(x) -> Carp(x))\n((Osprey(Bubbles) & -Goldfish(Bubbles)) | (-Osprey(Bubbles) & Goldfish(Bubbles))) -> -Fish(Bubbles)"
        ],
        "conclusion": "Bubbles is not a goldfish.",
        "conclusion-FOL": "-Goldfish(Bubbles)",
        "label": "ERROR"
    },
    {
        "premises": "Mr. and Mrs. Smith make a travel plan: they want to go to a city in California or Florida where neither of them has ever been.\nThe cities in California that they are interested in are San Francisco, Los Angeles, and San Diego.\nCities in Florida that they are interested in are Orlando and Miami.\nMr. Smith has been to two cities in California.\nMrs. Smith has been to one city in Florida.",
        "premises-FOL": [
            "all x. (WantToGoTo(MrDotAndMrsDotSmith, x) & City(x) -> (California(x) | Florida(x)) & NeverGo(x))\nCity(SanFrancisco) & California(SanFrancisco) & WantToGoTo(MrDotAndMrsDotSmith, SanFrancisco) & City(LosAngeles) & California(LosAngeles) & WantToGoTo(MrDotAndMrsDotSmith, LosAngeles) & City(SanDiego) & California(SanDiego) & WantToGoTo(MrDotAndMrsDotSmith, SanDiego)\nCity(Orlando) & Florida(Orlando) & WantToGo(MrDotAndMrsDotSmith, Orlando) & City(Miami) & Florida(Miami) & WantToGo(MrDotAndMrsDotSmith, Miami)\nexists x. exists y. all z. (-(x=z) & -(y=z) & -(x=y) & City(x) & City(y) & City(z) & California(x) & California(y) & California(z) -> Visit(MrDotSmith, x) & Visit(MrDotSmith, y) & -Visit(MrDotSmith, z))\nexists x. all y. (-(x=y) & City(x) & City(y) & Florida(x) & Florida(y) -> Visit(MrsDotSmith, x) & -Visit(MrsDotSmith, y))"
        ],
        "conclusion": "Mr. Smith has been to San Francisco.",
        "conclusion-FOL": "exists x. (City(x) & Visit(MrDotSmith, SanFrancisco))",
        "label": "ERROR"
    },
    {
        "premises": "Mr. and Mrs. Smith make a travel plan: they want to go to a city in California or Florida where neither of them has ever been.\nThe cities in California that they are interested in are San Francisco, Los Angeles, and San Diego.\nCities in Florida that they are interested in are Orlando and Miami.\nMr. Smith has been to two cities in California.\nMrs. Smith has been to one city in Florida.",
        "premises-FOL": [
            "all x. (WantToGoTo(MrDotAndMrsDotSmith, x) & City(x) -> (California(x) | Florida(x)) & NeverGo(x))\nCity(SanFrancisco) & California(SanFrancisco) & WantToGoTo(MrDotAndMrsDotSmith, SanFrancisco) & City(LosAngeles) & California(LosAngeles) & WantToGoTo(MrDotAndMrsDotSmith, LosAngeles) & City(SanDiego) & California(SanDiego) & WantToGoTo(MrDotAndMrsDotSmith, SanDiego)\nCity(Orlando) & Florida(Orlando) & WantToGo(MrDotAndMrsDotSmith, Orlando) & City(Miami) & Florida(Miami) & WantToGo(MrDotAndMrsDotSmith, Miami)\nexists x. exists y. all z. (-(x=z) & -(y=z) & -(x=y) & City(x) & City(y) & City(z) & California(x) & California(y) & California(z) -> Visit(MrDotSmith, x) & Visit(MrDotSmith, y) & -Visit(MrDotSmith, z))\nexists x. all y. (-(x=y) & City(x) & City(y) & Florida(x) & Florida(y) -> Visit(MrsDotSmith, x) & -Visit(MrsDotSmith, y))"
        ],
        "conclusion": "They have at leat one candidate city in Florida to visit.",
        "conclusion-FOL": "exists x. (WantToGoTo(x) & City(x) & Florida(x))",
        "label": "ERROR"
    },
    {
        "premises": "Mr. and Mrs. Smith make a travel plan: they want to go to a city in California or Florida where neither of them has ever been.\nThe cities in California that they are interested in are San Francisco, Los Angeles, and San Diego.\nCities in Florida that they are interested in are Orlando and Miami.\nMr. Smith has been to two cities in California.\nMrs. Smith has been to one city in Florida.",
        "premises-FOL": [
            "all x. (WantToGoTo(MrDotAndMrsDotSmith, x) & City(x) -> (California(x) | Florida(x)) & NeverGo(x))\nCity(SanFrancisco) & California(SanFrancisco) & WantToGoTo(MrDotAndMrsDotSmith, SanFrancisco) & City(LosAngeles) & California(LosAngeles) & WantToGoTo(MrDotAndMrsDotSmith, LosAngeles) & City(SanDiego) & California(SanDiego) & WantToGoTo(MrDotAndMrsDotSmith, SanDiego)\nCity(Orlando) & Florida(Orlando) & WantToGo(MrDotAndMrsDotSmith, Orlando) & City(Miami) & Florida(Miami) & WantToGo(MrDotAndMrsDotSmith, Miami)\nexists x. exists y. all z. (-(x=z) & -(y=z) & -(x=y) & City(x) & City(y) & City(z) & California(x) & California(y) & California(z) -> Visit(MrDotSmith, x) & Visit(MrDotSmith, y) & -Visit(MrDotSmith, z))\nexists x. all y. (-(x=y) & City(x) & City(y) & Florida(x) & Florida(y) -> Visit(MrsDotSmith, x) & -Visit(MrsDotSmith, y))"
        ],
        "conclusion": "They have at least two candidate cities in California to visit.",
        "conclusion-FOL": "exists x. exists y. (-(x=y) & City(x) & City(y) & WantToGoTo(MrDotAndMrsDotSmith, x) & California(x) & WantToGoTo(MrDotAndMrsDotSmith, y) & California(y))",
        "label": "ERROR"
    },
    {
        "premises": "Everything in Size Town is big or small.\nAll big things in Size Town are heavy.\nAll small things in Size Town are light.\nAll heavy things in Size Town are still.\nAll light things in Size Town are unstable.\nAll unstable things in Size Town are changing.\nAll unstable things in Size Town are unpredictable.\nThe bird is in Size Town and it is not both heavy and still.",
        "premises-FOL": [
            "all x. (In(x, SizeTown) -> (Big(x) | Small(x)))\nall x. (Big(x) & In(x, SizeTown) -> Heavy(x))\nall x. (Small(x) & In(x, SizeTown) -> Light(x))\nall x. (Heavy(x) & In(x, SizeTown) -> Still(x))\nall x. (Light(x) & In(x, SizeTown) -> Unstable(x))\nall x. (Unstable(x) & In(x, SizeTown) -> Changing(x))\nall x. (Unstable(x) & In(x, SizeTown) -> Unpredictable(x))\nIn(Bird, SizeTown) & -(Heavy(Bird) & Still(Bird))"
        ],
        "conclusion": "The bird is still.",
        "conclusion-FOL": "Still(Bird)",
        "label": "ERROR"
    },
    {
        "premises": "Everything in Size Town is big or small.\nAll big things in Size Town are heavy.\nAll small things in Size Town are light.\nAll heavy things in Size Town are still.\nAll light things in Size Town are unstable.\nAll unstable things in Size Town are changing.\nAll unstable things in Size Town are unpredictable.\nThe bird is in Size Town and it is not both heavy and still.",
        "premises-FOL": [
            "all x. (In(x, SizeTown) -> (Big(x) | Small(x)))\nall x. (Big(x) & In(x, SizeTown) -> Heavy(x))\nall x. (Small(x) & In(x, SizeTown) -> Light(x))\nall x. (Heavy(x) & In(x, SizeTown) -> Still(x))\nall x. (Light(x) & In(x, SizeTown) -> Unstable(x))\nall x. (Unstable(x) & In(x, SizeTown) -> Changing(x))\nall x. (Unstable(x) & In(x, SizeTown) -> Unpredictable(x))\nIn(Bird, SizeTown) & -(Heavy(Bird) & Still(Bird))"
        ],
        "conclusion": "The bird is not still.",
        "conclusion-FOL": "-Still(Bird)",
        "label": "ERROR"
    },
    {
        "premises": "Everything in Size Town is big or small.\nAll big things in Size Town are heavy.\nAll small things in Size Town are light.\nAll heavy things in Size Town are still.\nAll light things in Size Town are unstable.\nAll unstable things in Size Town are changing.\nAll unstable things in Size Town are unpredictable.\nThe bird is in Size Town and it is not both heavy and still.",
        "premises-FOL": [
            "all x. (In(x, SizeTown) -> (Big(x) | Small(x)))\nall x. (Big(x) & In(x, SizeTown) -> Heavy(x))\nall x. (Small(x) & In(x, SizeTown) -> Light(x))\nall x. (Heavy(x) & In(x, SizeTown) -> Still(x))\nall x. (Light(x) & In(x, SizeTown) -> Unstable(x))\nall x. (Unstable(x) & In(x, SizeTown) -> Changing(x))\nall x. (Unstable(x) & In(x, SizeTown) -> Unpredictable(x))\nIn(Bird, SizeTown) & -(Heavy(Bird) & Still(Bird))"
        ],
        "conclusion": "The bird is unpredictable and changing.",
        "conclusion-FOL": "Unpredictable(Bird) & Changing(Bird)",
        "label": "ERROR"
    },
    {
        "premises": "Everything in Size Town is big or small.\nAll big things in Size Town are heavy.\nAll small things in Size Town are light.\nAll heavy things in Size Town are still.\nAll light things in Size Town are unstable.\nAll unstable things in Size Town are changing.\nAll unstable things in Size Town are unpredictable.\nThe bird is in Size Town and it is not both heavy and still.",
        "premises-FOL": [
            "all x. (In(x, SizeTown) -> (Big(x) | Small(x)))\nall x. (Big(x) & In(x, SizeTown) -> Heavy(x))\nall x. (Small(x) & In(x, SizeTown) -> Light(x))\nall x. (Heavy(x) & In(x, SizeTown) -> Still(x))\nall x. (Light(x) & In(x, SizeTown) -> Unstable(x))\nall x. (Unstable(x) & In(x, SizeTown) -> Changing(x))\nall x. (Unstable(x) & In(x, SizeTown) -> Unpredictable(x))\nIn(Bird, SizeTown) & -(Heavy(Bird) & Still(Bird))"
        ],
        "conclusion": "The bird is unpredictable or changing.",
        "conclusion-FOL": "Unpredictable(Bird) | Changing(Bird)",
        "label": "ERROR"
    },
    {
        "premises": "Everything in Size Town is big or small.\nAll big things in Size Town are heavy.\nAll small things in Size Town are light.\nAll heavy things in Size Town are still.\nAll light things in Size Town are unstable.\nAll unstable things in Size Town are changing.\nAll unstable things in Size Town are unpredictable.\nThe bird is in Size Town and it is not both heavy and still.",
        "premises-FOL": [
            "all x. (In(x, SizeTown) -> (Big(x) | Small(x)))\nall x. (Big(x) & In(x, SizeTown) -> Heavy(x))\nall x. (Small(x) & In(x, SizeTown) -> Light(x))\nall x. (Heavy(x) & In(x, SizeTown) -> Still(x))\nall x. (Light(x) & In(x, SizeTown) -> Unstable(x))\nall x. (Unstable(x) & In(x, SizeTown) -> Changing(x))\nall x. (Unstable(x) & In(x, SizeTown) -> Unpredictable(x))\nIn(Bird, SizeTown) & -(Heavy(Bird) & Still(Bird))"
        ],
        "conclusion": "The bird is either unpredictable or changing.",
        "conclusion-FOL": "((Unpredictable(Bird) & -Changing(Bird)) | (-Unpredictable(Bird) & Changing(Bird)))",
        "label": "ERROR"
    },
    {
        "premises": "Everything in Size Town is big or small.\nAll big things in Size Town are heavy.\nAll small things in Size Town are light.\nAll heavy things in Size Town are still.\nAll light things in Size Town are unstable.\nAll unstable things in Size Town are changing.\nAll unstable things in Size Town are unpredictable.\nThe bird is in Size Town and it is not both heavy and still.",
        "premises-FOL": [
            "all x. (In(x, SizeTown) -> (Big(x) | Small(x)))\nall x. (Big(x) & In(x, SizeTown) -> Heavy(x))\nall x. (Small(x) & In(x, SizeTown) -> Light(x))\nall x. (Heavy(x) & In(x, SizeTown) -> Still(x))\nall x. (Light(x) & In(x, SizeTown) -> Unstable(x))\nall x. (Unstable(x) & In(x, SizeTown) -> Changing(x))\nall x. (Unstable(x) & In(x, SizeTown) -> Unpredictable(x))\nIn(Bird, SizeTown) & -(Heavy(Bird) & Still(Bird))"
        ],
        "conclusion": "If the bird is small or still, then it is either unpredictable or changing.",
        "conclusion-FOL": "Small(Bird) | Still(Bird) -> ((Unpredictable(Bird) & -Changing(Bird)) | (-Unpredictable(Bird) & Changing(Bird)))",
        "label": "ERROR"
    },
    {
        "premises": "DI Ray is a police procedural television series.\nDI Ray was created and written by Maya Sondhi.\nDI Ray was produced by Jed Mercurio.\nMaya Sondhi and Jed Mercurio are both British.",
        "premises-FOL": [
            "TelevisionSeries(dIRay) & PoliceProcedural(dIRay)\nCreates(Maya, dIRay) & Writes(Maya, dIRay)\nProduces(Jed, dIRay)\nBritish(Maya) & British(Jed) "
        ],
        "conclusion": "DI Ray was created by a Brit.",
        "conclusion-FOL": "exists x. (British(x) & Creates(x, dIRay))",
        "label": "ERROR"
    },
    {
        "premises": "DI Ray is a police procedural television series.\nDI Ray was created and written by Maya Sondhi.\nDI Ray was produced by Jed Mercurio.\nMaya Sondhi and Jed Mercurio are both British.",
        "premises-FOL": [
            "TelevisionSeries(dIRay) & PoliceProcedural(dIRay)\nCreates(Maya, dIRay) & Writes(Maya, dIRay)\nProduces(Jed, dIRay)\nBritish(Maya) & British(Jed) "
        ],
        "conclusion": "Some Brit produced a television series.",
        "conclusion-FOL": "exists x. exists y.(British(x) & TelevisionSeries(y) & Produces(x, y))",
        "label": "ERROR"
    },
    {
        "premises": "Everyone who took the bar exam can read. \nAll lawyers took the bar exam. \nEveryone who took the bar exam is knowledgeable about criminal procedures. \nAll people who got a score of 180 on the LSAT can read. \nNo elephants can read. \nIf Mike can not read or is not an elephant, then Mike either took the bar exam or can read. ",
        "premises-FOL": [
            "all x. (Take(x, BarExam) -> CanRead(x))\nall x. (Lawyer(x) -> Take(x, BarExam))\nall x. (Take(x, BarExam) -> KnowledgeableAbout(x, CriminalProceeder))\nall x. (GetOn(x, ScoreOfOneEightZero, lSAT) -> CanRead(x))\nall x. (Elephant(x) -> -CanRead(x))\n-(CanRead(Mike) & Elephant(Mike)) -> ((Take(Mike, BarExam) & -CanRead(Mike)) | (-Take(Mike, BarExam) & CanRead(Mike)))"
        ],
        "conclusion": "Mike got 180 on the LSAT.",
        "conclusion-FOL": "GetOn(Mike, OneEightZero, lSAT)",
        "label": "ERROR"
    },
    {
        "premises": "Everyone who took the bar exam can read. \nAll lawyers took the bar exam. \nEveryone who took the bar exam is knowledgeable about criminal procedures. \nAll people who got a score of 180 on the LSAT can read. \nNo elephants can read. \nIf Mike can not read or is not an elephant, then Mike either took the bar exam or can read. ",
        "premises-FOL": [
            "all x. (Take(x, BarExam) -> CanRead(x))\nall x. (Lawyer(x) -> Take(x, BarExam))\nall x. (Take(x, BarExam) -> KnowledgeableAbout(x, CriminalProceeder))\nall x. (GetOn(x, ScoreOfOneEightZero, lSAT) -> CanRead(x))\nall x. (Elephant(x) -> -CanRead(x))\n-(CanRead(Mike) & Elephant(Mike)) -> ((Take(Mike, BarExam) & -CanRead(Mike)) | (-Take(Mike, BarExam) & CanRead(Mike)))"
        ],
        "conclusion": "Mike did not take the bar exam and is not both knowledgeable about criminal procedures and someone who got 180 on the LSAT.",
        "conclusion-FOL": "-Take(Mike, BarExam) & -(KnowledgeableAbout(Mike, CriminalProcedures)& GetOn(Mike, OneEightZero, lSAT))",
        "label": "ERROR"
    },
    {
        "premises": "Everyone who took the bar exam can read. \nAll lawyers took the bar exam. \nEveryone who took the bar exam is knowledgeable about criminal procedures. \nAll people who got a score of 180 on the LSAT can read. \nNo elephants can read. \nIf Mike can not read or is not an elephant, then Mike either took the bar exam or can read. ",
        "premises-FOL": [
            "all x. (Take(x, BarExam) -> CanRead(x))\nall x. (Lawyer(x) -> Take(x, BarExam))\nall x. (Take(x, BarExam) -> KnowledgeableAbout(x, CriminalProceeder))\nall x. (GetOn(x, ScoreOfOneEightZero, lSAT) -> CanRead(x))\nall x. (Elephant(x) -> -CanRead(x))\n-(CanRead(Mike) & Elephant(Mike)) -> ((Take(Mike, BarExam) & -CanRead(Mike)) | (-Take(Mike, BarExam) & CanRead(Mike)))"
        ],
        "conclusion": "Mike took the bar exam.",
        "conclusion-FOL": "Take(Mike, BarExam)",
        "label": "ERROR"
    },
    {
        "premises": "Some soccer defenders are center-backs.\nAll soccer defenders are soccer players.\nNo soccer players are professional basketball players.\nAll NBA players are professional basketball players.\nStephen Curry is an NBA player.",
        "premises-FOL": [
            "exists x. (ProfessionalSoccerDefender(x) & ProfessionalCenterback(x))\nall x. (ProfessionalSoccerDefender(x) -> ProfessionalSoccerPlayer(x))\nall x. (ProfessionalSoccerPlayer(x) -> -ProfessionalBasketballPlayer(x)))\nall x. (NBAPlayer(x) -> ProfessionalBasketballPlayer(x))\nNBAPlayer(Stephencurry)"
        ],
        "conclusion": "Stephen Curry is a center-back.",
        "conclusion-FOL": "ProfessionalCenterback(StephenCurry)",
        "label": "ERROR"
    },
    {
        "premises": "Some soccer defenders are center-backs.\nAll soccer defenders are soccer players.\nNo soccer players are professional basketball players.\nAll NBA players are professional basketball players.\nStephen Curry is an NBA player.",
        "premises-FOL": [
            "exists x. (ProfessionalSoccerDefender(x) & ProfessionalCenterback(x))\nall x. (ProfessionalSoccerDefender(x) -> ProfessionalSoccerPlayer(x))\nall x. (ProfessionalSoccerPlayer(x) -> -ProfessionalBasketballPlayer(x)))\nall x. (NBAPlayer(x) -> ProfessionalBasketballPlayer(x))\nNBAPlayer(Stephencurry)"
        ],
        "conclusion": "Stephen Curry is not both a centerback and a soccer defender.",
        "conclusion-FOL": "-(ProfessionalCenterback(StephenCurry) & ProfessionalSoccerDefender(StephenCurry))",
        "label": "ERROR"
    },
    {
        "premises": "Some soccer defenders are center-backs.\nAll soccer defenders are soccer players.\nNo soccer players are professional basketball players.\nAll NBA players are professional basketball players.\nStephen Curry is an NBA player.",
        "premises-FOL": [
            "exists x. (ProfessionalSoccerDefender(x) & ProfessionalCenterback(x))\nall x. (ProfessionalSoccerDefender(x) -> ProfessionalSoccerPlayer(x))\nall x. (ProfessionalSoccerPlayer(x) -> -ProfessionalBasketballPlayer(x)))\nall x. (NBAPlayer(x) -> ProfessionalBasketballPlayer(x))\nNBAPlayer(Stephencurry)"
        ],
        "conclusion": "If Stephen Curry is not both a centerback and a soccer defender, then Stephen Curry is neither a soccer player nor a professional basketball player.",
        "conclusion-FOL": "-(Centerback(StephenCurry) & SoccerDefender(StephenCurry)) -> -(SoccerPlayer(StephenCurry) | ProfessionalBasketballPlayer(StephenCurry))",
        "label": "ERROR"
    },
    {
        "premises": "If a person doesn't have enough money to buy a product, then that person can't buy it.\nMonitors are products.\n4k monitors are more expensive than 1080 monitors and 2k monitors.\nJohn is a person.\nJohn doesn't have enough money to buy a 2k monitor.",
        "premises-FOL": [
            "all x. all y. (Person(x) & Product(y) & -HaveEnoughMoneyFor(x, y) -> -Buy(x, y))\nall x. (Monitor(x) -> Product(x))\nall x. all y. all z. (Monitor(x) & Monitor(y) & Monitor(z) & FourK(x) & OneOEightO(y) & TwoK(z) -> MoreExpensive(x, y) & MoreExpensive(x, z))\nPerson(John)\nall x. (Monitor(x) & TwoK(x) -> -HaveEnoughMoneyFor(John, x))"
        ],
        "conclusion": "John can't buy a 1080 monitor.",
        "conclusion-FOL": "all x. (Monitor(x) & OneOEightO(x) -> -Buy(John, x))",
        "label": "ERROR"
    },
    {
        "premises": "If a person doesn't have enough money to buy a product, then that person can't buy it.\nMonitors are products.\n4k monitors are more expensive than 1080 monitors and 2k monitors.\nJohn is a person.\nJohn doesn't have enough money to buy a 2k monitor.",
        "premises-FOL": [
            "all x. all y. (Person(x) & Product(y) & -HaveEnoughMoneyFor(x, y) -> -Buy(x, y))\nall x. (Monitor(x) -> Product(x))\nall x. all y. all z. (Monitor(x) & Monitor(y) & Monitor(z) & FourK(x) & OneOEightO(y) & TwoK(z) -> MoreExpensive(x, y) & MoreExpensive(x, z))\nPerson(John)\nall x. (Monitor(x) & TwoK(x) -> -HaveEnoughMoneyFor(John, x))"
        ],
        "conclusion": "John can't buy a 2k monitor.",
        "conclusion-FOL": "all x. (Monitor(x) & TwoK(x) -> -Buy(John, x))",
        "label": "ERROR"
    },
    {
        "premises": "All artificial satellites are important scientific achievements.\nSome artificial satellites are not U.S. inventions.",
        "premises-FOL": [
            "all x. (ArtificialSatellite(x) -> ImportantScientificAchievement(x))\nexists x. (ArtificialSatellite(x) & -USInvention(x))"
        ],
        "conclusion": "All important scientific achievements are U.S. inventions.",
        "conclusion-FOL": "all x. (ImportantScientificAchievement(x) & USInvention(x))",
        "label": "ERROR"
    },
    {
        "premises": "Some cats are not pets.\nAll cats are mammals.",
        "premises-FOL": [
            "exists x. (Cat(x) & -Pet(x))\nall x. (Cat(x) -> Mammal(x))"
        ],
        "conclusion": "Some mammals are not pets.",
        "conclusion-FOL": "exists x. exists y. (Mammal(x) & Mammal(y) & -Pet(x) & -Pet(y))",
        "label": "ERROR"
    },
    {
        "premises": "If people in this neighborhood visit a coffee shop regularly, then they are addicted to coffee. \nPeople in this neighborhood visit a coffee shop regularly or order takeout at least once a day.\nIf people in this neighborhood make a lot of their own food at home using recipes and online guides, then they order takeout at least once a day.\nIf people in this neighborhood own at least one coffeemaker and one blender in their home, then they do not order takeout at least once a day.\nAll people in this neighborhood who lead very busy lives that include 12-hour work hours make a lot of their own food at home using recipes and online guides.\nSam is living in this neighborhood, and he is either addicted to coffee or other caffeinated drinks and leads a very busy life that include 12-hour work hours, or is not addicted to coffee and does not lead a very busy life that include 12-hour work hours",
        "premises-FOL": [
            "all x. (In(x, ThisNeighborhood) & VisitRegularly(x, CoffeeShop) -> AddictedTo(x, Coffee))\nall x. (In(x, ThisNeighborhood) -> (VisitRegularly(x, CoffeeShop) | (exists y. (TakeOut(y) & Order(x, y, aDay))))\nall x. (In(x, ThisNeighborhood) & MakeAtUsing(x, Home, OwnFood, Recipe) -> exists y. (TakeOut(y) & Order(x, y)))\nall x. (In(x, ThisNeighborhood) & exists y. (CoffeemakerAndBlender(y) & Own(x, y)) -> -OrderAtLeastOnceADay(x, Takeout))\nall x. (In(x, ThisNeighborhood) & BusyWith(x, OneTwoHourWorkHour) -> MakeAtUsing(x, Home, OwnFood, Recipe))\nIn(Sam, ThisNeighborhood) & -(((AddictedTo(Sam, Coffee) & -BusyWith(Sam, OneTwoHourWorkHour)) | (-AddictedTo(Sam, Coffee) & BusyWith(Sam, OneTwoHourWorkHour))))"
        ],
        "conclusion": "Sam is living in this neighborhood and he is addicted to coffee.",
        "conclusion-FOL": "InThisNeighborhood(Sam) & AddictedTo(Sam, Coffee)",
        "label": "ERROR"
    },
    {
        "premises": "If people in this neighborhood visit a coffee shop regularly, then they are addicted to coffee. \nPeople in this neighborhood visit a coffee shop regularly or order takeout at least once a day.\nIf people in this neighborhood make a lot of their own food at home using recipes and online guides, then they order takeout at least once a day.\nIf people in this neighborhood own at least one coffeemaker and one blender in their home, then they do not order takeout at least once a day.\nAll people in this neighborhood who lead very busy lives that include 12-hour work hours make a lot of their own food at home using recipes and online guides.\nSam is living in this neighborhood, and he is either addicted to coffee or other caffeinated drinks and leads a very busy life that include 12-hour work hours, or is not addicted to coffee and does not lead a very busy life that include 12-hour work hours",
        "premises-FOL": [
            "all x. (In(x, ThisNeighborhood) & VisitRegularly(x, CoffeeShop) -> AddictedTo(x, Coffee))\nall x. (In(x, ThisNeighborhood) -> (VisitRegularly(x, CoffeeShop) | (exists y. (TakeOut(y) & Order(x, y, aDay))))\nall x. (In(x, ThisNeighborhood) & MakeAtUsing(x, Home, OwnFood, Recipe) -> exists y. (TakeOut(y) & Order(x, y)))\nall x. (In(x, ThisNeighborhood) & exists y. (CoffeemakerAndBlender(y) & Own(x, y)) -> -OrderAtLeastOnceADay(x, Takeout))\nall x. (In(x, ThisNeighborhood) & BusyWith(x, OneTwoHourWorkHour) -> MakeAtUsing(x, Home, OwnFood, Recipe))\nIn(Sam, ThisNeighborhood) & -(((AddictedTo(Sam, Coffee) & -BusyWith(Sam, OneTwoHourWorkHour)) | (-AddictedTo(Sam, Coffee) & BusyWith(Sam, OneTwoHourWorkHour))))"
        ],
        "conclusion": "Sam is living in this neighborhood and he owns at least one coffeemaker and one blender in his home.",
        "conclusion-FOL": "exists y. (CoffeemakerAndBlender(y) & Own(Sam, y))",
        "label": "ERROR"
    },
    {
        "premises": "If people in this neighborhood visit a coffee shop regularly, then they are addicted to coffee. \nPeople in this neighborhood visit a coffee shop regularly or order takeout at least once a day.\nIf people in this neighborhood make a lot of their own food at home using recipes and online guides, then they order takeout at least once a day.\nIf people in this neighborhood own at least one coffeemaker and one blender in their home, then they do not order takeout at least once a day.\nAll people in this neighborhood who lead very busy lives that include 12-hour work hours make a lot of their own food at home using recipes and online guides.\nSam is living in this neighborhood, and he is either addicted to coffee or other caffeinated drinks and leads a very busy life that include 12-hour work hours, or is not addicted to coffee and does not lead a very busy life that include 12-hour work hours",
        "premises-FOL": [
            "all x. (In(x, ThisNeighborhood) & VisitRegularly(x, CoffeeShop) -> AddictedTo(x, Coffee))\nall x. (In(x, ThisNeighborhood) -> (VisitRegularly(x, CoffeeShop) | (exists y. (TakeOut(y) & Order(x, y, aDay))))\nall x. (In(x, ThisNeighborhood) & MakeAtUsing(x, Home, OwnFood, Recipe) -> exists y. (TakeOut(y) & Order(x, y)))\nall x. (In(x, ThisNeighborhood) & exists y. (CoffeemakerAndBlender(y) & Own(x, y)) -> -OrderAtLeastOnceADay(x, Takeout))\nall x. (In(x, ThisNeighborhood) & BusyWith(x, OneTwoHourWorkHour) -> MakeAtUsing(x, Home, OwnFood, Recipe))\nIn(Sam, ThisNeighborhood) & -(((AddictedTo(Sam, Coffee) & -BusyWith(Sam, OneTwoHourWorkHour)) | (-AddictedTo(Sam, Coffee) & BusyWith(Sam, OneTwoHourWorkHour))))"
        ],
        "conclusion": "Sam is living in this neighborhood and he owns at least one coffeemaker and one blender in his home or orders takeout at least once a day.",
        "conclusion-FOL": "(exists y. (CoffeemakerAndBlender(y) & Own(Sam, y)) | (exists y. (TakeOut(y) & Order(Sam, y, aDay)))",
        "label": "ERROR"
    },
    {
        "premises": "No professional basketball players are soccer players.\nAll NBA players are professional basketball players.\nAll soccer defenders are soccer players.\nAll centerbacks are soccer defenders.\nRoger Federer is either both an NBA player and a soccer defender, or neither.",
        "premises-FOL": [
            "all x. (ProfessionalBasketballPlayer(x) -> -ProfessionalSoccerPlayer(x))\nall x. (NBAPlayer(x) -> ProfessionalBasketballPlayer(x))\nall x. (ProfessionalSoccerDefender(x) -> ProfessionalSoccerPlayer(x))\nall x. (ProfessionalCenterback(x) -> ProfessionalSoccerDefender(x))\n-(((NBAPlayer(Rogerfederer) & -ProfessionalSoccerDefender(Rogerfederer)) | (-NBAPlayer(Rogerfederer) & ProfessionalSoccerDefender(Rogerfederer))))"
        ],
        "conclusion": "Roger Federer is a centerback.",
        "conclusion-FOL": "ProfessionalCenterback(RogerFederer)",
        "label": "ERROR"
    },
    {
        "premises": "No professional basketball players are soccer players.\nAll NBA players are professional basketball players.\nAll soccer defenders are soccer players.\nAll centerbacks are soccer defenders.\nRoger Federer is either both an NBA player and a soccer defender, or neither.",
        "premises-FOL": [
            "all x. (ProfessionalBasketballPlayer(x) -> -ProfessionalSoccerPlayer(x))\nall x. (NBAPlayer(x) -> ProfessionalBasketballPlayer(x))\nall x. (ProfessionalSoccerDefender(x) -> ProfessionalSoccerPlayer(x))\nall x. (ProfessionalCenterback(x) -> ProfessionalSoccerDefender(x))\n-(((NBAPlayer(Rogerfederer) & -ProfessionalSoccerDefender(Rogerfederer)) | (-NBAPlayer(Rogerfederer) & ProfessionalSoccerDefender(Rogerfederer))))"
        ],
        "conclusion": "Roger Federer is not a centerback.",
        "conclusion-FOL": "-ProfessionalCenterback(RogerFederer)",
        "label": "ERROR"
    },
    {
        "premises": "No professional basketball players are soccer players.\nAll NBA players are professional basketball players.\nAll soccer defenders are soccer players.\nAll centerbacks are soccer defenders.\nRoger Federer is either both an NBA player and a soccer defender, or neither.",
        "premises-FOL": [
            "all x. (ProfessionalBasketballPlayer(x) -> -ProfessionalSoccerPlayer(x))\nall x. (NBAPlayer(x) -> ProfessionalBasketballPlayer(x))\nall x. (ProfessionalSoccerDefender(x) -> ProfessionalSoccerPlayer(x))\nall x. (ProfessionalCenterback(x) -> ProfessionalSoccerDefender(x))\n-(((NBAPlayer(Rogerfederer) & -ProfessionalSoccerDefender(Rogerfederer)) | (-NBAPlayer(Rogerfederer) & ProfessionalSoccerDefender(Rogerfederer))))"
        ],
        "conclusion": "Roger Federer is a soccer player.",
        "conclusion-FOL": "ProfessionalSoccerPlayer(RogerFederer)",
        "label": "ERROR"
    },
    {
        "premises": "Some teachers who work at pools are not nice.\nAll teachers working at pools are pool managers.\nAll pool managers are lifeguards.\nIf someone is a lifeguard, then they work at a pool.\nMary does not work at a pool.",
        "premises-FOL": [
            "exists x. (Teacher(x) & WorkAt(x, Pool) & -Nice(x))\nall x. (Teacher(x) & WorkAt(x, Pool) -> PoolManager(x))\nall x. (PoolManager(x) -> Lifeguard(x))\nall x. (Lifeguard(x) -> WorkAt(x, Pool))\n-WorkAt(Mary, Pool)"
        ],
        "conclusion": "Mary is nice.",
        "conclusion-FOL": "Nice(Mary)",
        "label": "ERROR"
    },
    {
        "premises": "Some teachers who work at pools are not nice.\nAll teachers working at pools are pool managers.\nAll pool managers are lifeguards.\nIf someone is a lifeguard, then they work at a pool.\nMary does not work at a pool.",
        "premises-FOL": [
            "exists x. (Teacher(x) & WorkAt(x, Pool) & -Nice(x))\nall x. (Teacher(x) & WorkAt(x, Pool) -> PoolManager(x))\nall x. (PoolManager(x) -> Lifeguard(x))\nall x. (Lifeguard(x) -> WorkAt(x, Pool))\n-WorkAt(Mary, Pool)"
        ],
        "conclusion": "Mary is not a nice teacher working at a pool.",
        "conclusion-FOL": "-(Nice(Mary) & Teacher(Mary) & WorkAt(Mary, Pool))",
        "label": "ERROR"
    },
    {
        "premises": "Some teachers who work at pools are not nice.\nAll teachers working at pools are pool managers.\nAll pool managers are lifeguards.\nIf someone is a lifeguard, then they work at a pool.\nMary does not work at a pool.",
        "premises-FOL": [
            "exists x. (Teacher(x) & WorkAt(x, Pool) & -Nice(x))\nall x. (Teacher(x) & WorkAt(x, Pool) -> PoolManager(x))\nall x. (PoolManager(x) -> Lifeguard(x))\nall x. (Lifeguard(x) -> WorkAt(x, Pool))\n-WorkAt(Mary, Pool)"
        ],
        "conclusion": "Mary is is a nice teacher working at a pool.",
        "conclusion-FOL": "Nice(Mary) & Teacher(Mary) & WorkAt(Mary, Pool)",
        "label": "ERROR"
    },
    {
        "premises": "Not all art pieces require talent.\nEverything that requires talent requires practice.",
        "premises-FOL": [
            "exists x. (ArtPiece(x) & -Require(x, Talent))\nall x. (Require(x, Talent) -> Require(x, Practice))"
        ],
        "conclusion": "There exist art pieces that do not require practice.",
        "conclusion-FOL": "exists x. exists y. (ArtPiece(x) & -Require(x, Practice) & ArtPiece(y) & -Require(y, Practice) & -(x=y))",
        "label": "ERROR"
    },
    {
        "premises": "Bernarda Bryson Shahn was a painter and lithographer.\nBernarda Bryson Shahn was born in Athens, Ohio. \nBernarda Bryson Shahn was married to Ben Shahn.\nPeople born in Athens, Ohio, are Americans.",
        "premises-FOL": [
            "Painter(BernardaBrysonShahn) & Lithographer(BernardaBrysonShahn) \nBornIn(BernardaBrysonShahn, AthensOhio)\nMarriedTo(BernardaBrysonShahn, BenShahn)\nall x. (BornIn(x, AthensOhio) -> American(x))"
        ],
        "conclusion": "Bernarda Bryson Shahn was born in Greece.",
        "conclusion-FOL": "BornIn(BernardaBrysonShahn, Greece)",
        "label": "ERROR"
    },
    {
        "premises": "Bernarda Bryson Shahn was a painter and lithographer.\nBernarda Bryson Shahn was born in Athens, Ohio. \nBernarda Bryson Shahn was married to Ben Shahn.\nPeople born in Athens, Ohio, are Americans.",
        "premises-FOL": [
            "Painter(BernardaBrysonShahn) & Lithographer(BernardaBrysonShahn) \nBornIn(BernardaBrysonShahn, AthensOhio)\nMarriedTo(BernardaBrysonShahn, BenShahn)\nall x. (BornIn(x, AthensOhio) -> American(x))"
        ],
        "conclusion": "Bernarda Bryson Shahn was American.",
        "conclusion-FOL": "American(BernardaBrysonShahn)",
        "label": "ERROR"
    },
    {
        "premises": "Bernarda Bryson Shahn was a painter and lithographer.\nBernarda Bryson Shahn was born in Athens, Ohio. \nBernarda Bryson Shahn was married to Ben Shahn.\nPeople born in Athens, Ohio, are Americans.",
        "premises-FOL": [
            "Painter(BernardaBrysonShahn) & Lithographer(BernardaBrysonShahn) \nBornIn(BernardaBrysonShahn, AthensOhio)\nMarriedTo(BernardaBrysonShahn, BenShahn)\nall x. (BornIn(x, AthensOhio) -> American(x))"
        ],
        "conclusion": "Bernarda Bryson Shahn had been divorced once.",
        "conclusion-FOL": "Divorced(BernardaBrysonShahn)",
        "label": "ERROR"
    },
    {
        "premises": "Everybody in Emma's family who upgrade to the newest iPhone model every year, are not saving money for a down payment on a new house.\nEverybody in Emma's family who enjoy reading about tech specs and keeping up to date on the latest technology upgrade to the newest iPhone model every year.\nEverybody in Emma's family is saving money for a down payment on a new house, or lives in an apartment in a big metropolitan cities.\nEverybody in Emma's family live with at least one roommate, does not own any pets.\nEverybody in Emma's family who owns at least one pet lives with at least one roommate.\nEmily is in Emma's family.\nIf Emily does not both own at least one pet and lives in apartments in big metropolitan cities, then Emily either owns at least one pet and lives in an apartment in big metropolitan cities, or she neither owns a pet nor lives in an apartment in big metropolitan cities. ",
        "premises-FOL": [
            "all x. (InEmmasFamily(x) & UpgradeToEveryYear(x, NewestIphoneModel) -> -SavingMoneyForOn(x, DownPayment, NewHouse))\nall x. (InEmmasFamily(x) & EnjoyReading(x, TechSpec) & KeepUpdatedOn(x, LatestTechnology) -> UpgradeToEveryYear(x, NewestIphoneModel))\nall x. (InEmmasFamily(x) & (SavingMoneyForOn(x, DownPayment, NewHouse) | LiveIn(x, Apartment, BigMetropolitanCity)))\nall x. (InEmmasFamily(x) & (exists y. (LiveWith(x, y) & Roommate(y))) -> -(exists y. (Own(x, y) & Pet(y))))\nall x. (InEmmasFamily(x) & (exists y. (Own(x, y) & Pet(y))) -> (exists y. (LiveWith(x, y) & Roommate(y))))\nInEmmasFamily(Emily)\n((exists y. (Own(Emily, y) & Roommate(y))) & LiveIn(Emily, Apartment, BigMetropolitanCity)) -> ((exists y. (Own(Emily, y) & Pet(y))) & LiveIn(Emily, Apartment, BigMetropolitanCity)) \u2295 -((exists y. (Own(Emily, y) & Roommate(y))) | LiveIn(Emily, Apartment, BigMetropolitanCity))"
        ],
        "conclusion": "Emily is in Emma's family and she lives with at least one roommate.",
        "conclusion-FOL": "exists y. (LiveWith(Emily, y) & Roommate(y))",
        "label": "ERROR"
    },
    {
        "premises": "Everybody in Emma's family who upgrade to the newest iPhone model every year, are not saving money for a down payment on a new house.\nEverybody in Emma's family who enjoy reading about tech specs and keeping up to date on the latest technology upgrade to the newest iPhone model every year.\nEverybody in Emma's family is saving money for a down payment on a new house, or lives in an apartment in a big metropolitan cities.\nEverybody in Emma's family live with at least one roommate, does not own any pets.\nEverybody in Emma's family who owns at least one pet lives with at least one roommate.\nEmily is in Emma's family.\nIf Emily does not both own at least one pet and lives in apartments in big metropolitan cities, then Emily either owns at least one pet and lives in an apartment in big metropolitan cities, or she neither owns a pet nor lives in an apartment in big metropolitan cities. ",
        "premises-FOL": [
            "all x. (InEmmasFamily(x) & UpgradeToEveryYear(x, NewestIphoneModel) -> -SavingMoneyForOn(x, DownPayment, NewHouse))\nall x. (InEmmasFamily(x) & EnjoyReading(x, TechSpec) & KeepUpdatedOn(x, LatestTechnology) -> UpgradeToEveryYear(x, NewestIphoneModel))\nall x. (InEmmasFamily(x) & (SavingMoneyForOn(x, DownPayment, NewHouse) | LiveIn(x, Apartment, BigMetropolitanCity)))\nall x. (InEmmasFamily(x) & (exists y. (LiveWith(x, y) & Roommate(y))) -> -(exists y. (Own(x, y) & Pet(y))))\nall x. (InEmmasFamily(x) & (exists y. (Own(x, y) & Pet(y))) -> (exists y. (LiveWith(x, y) & Roommate(y))))\nInEmmasFamily(Emily)\n((exists y. (Own(Emily, y) & Roommate(y))) & LiveIn(Emily, Apartment, BigMetropolitanCity)) -> ((exists y. (Own(Emily, y) & Pet(y))) & LiveIn(Emily, Apartment, BigMetropolitanCity)) \u2295 -((exists y. (Own(Emily, y) & Roommate(y))) | LiveIn(Emily, Apartment, BigMetropolitanCity))"
        ],
        "conclusion": "Emily enjoys reading about tech specs and keeping up to date on the latest technology.",
        "conclusion-FOL": "EnjoyReading(Emily, TechSpec) & KeepUpdatedOn(Emily, LatestTechnology)",
        "label": "ERROR"
    },
    {
        "premises": "People on the payroll are being paid by the school.\nIf someone has a job at a school, then they are on the payroll.\nAll faculty members have a job at a school.\nIf someone teaches students, they are a faculty member or a teacher.\nEvery teacher has students.\nIf Nancy is a teacher, then they are on the payroll.\nIf Nancy is not a teacher, then they are not paid by the school.\nNancy teaches students.",
        "premises-FOL": [
            "all x. (OnPayroll(x) -> PaidBy(x, School))\nall x. (HaveJobAt(x, School) -> OnPayroll(x))\nall x. (FacultyMember(x) -> HaveJobAt(x, School))\nall x. (Teach(x, Student) -> FacultyMember(x) | Teacher(x))\nall x. (Teacher(x) -> Have(x, Student))\nTeacher(Nancy) -> OnPayroll(Nancy)\n-Teacher(Nancy) -> -OnPayroll(Nancy)\nTeach(Nancy, Student)"
        ],
        "conclusion": "Nancy is a faculty member.",
        "conclusion-FOL": "FacultyMember(Nancy)",
        "label": "ERROR"
    },
    {
        "premises": "People on the payroll are being paid by the school.\nIf someone has a job at a school, then they are on the payroll.\nAll faculty members have a job at a school.\nIf someone teaches students, they are a faculty member or a teacher.\nEvery teacher has students.\nIf Nancy is a teacher, then they are on the payroll.\nIf Nancy is not a teacher, then they are not paid by the school.\nNancy teaches students.",
        "premises-FOL": [
            "all x. (OnPayroll(x) -> PaidBy(x, School))\nall x. (HaveJobAt(x, School) -> OnPayroll(x))\nall x. (FacultyMember(x) -> HaveJobAt(x, School))\nall x. (Teach(x, Student) -> FacultyMember(x) | Teacher(x))\nall x. (Teacher(x) -> Have(x, Student))\nTeacher(Nancy) -> OnPayroll(Nancy)\n-Teacher(Nancy) -> -OnPayroll(Nancy)\nTeach(Nancy, Student)"
        ],
        "conclusion": "Nancy is paid by the school and has students.",
        "conclusion-FOL": "PaidBy(Nancy, School) & Have(Nancy, Student)",
        "label": "ERROR"
    },
    {
        "premises": "People on the payroll are being paid by the school.\nIf someone has a job at a school, then they are on the payroll.\nAll faculty members have a job at a school.\nIf someone teaches students, they are a faculty member or a teacher.\nEvery teacher has students.\nIf Nancy is a teacher, then they are on the payroll.\nIf Nancy is not a teacher, then they are not paid by the school.\nNancy teaches students.",
        "premises-FOL": [
            "all x. (OnPayroll(x) -> PaidBy(x, School))\nall x. (HaveJobAt(x, School) -> OnPayroll(x))\nall x. (FacultyMember(x) -> HaveJobAt(x, School))\nall x. (Teach(x, Student) -> FacultyMember(x) | Teacher(x))\nall x. (Teacher(x) -> Have(x, Student))\nTeacher(Nancy) -> OnPayroll(Nancy)\n-Teacher(Nancy) -> -OnPayroll(Nancy)\nTeach(Nancy, Student)"
        ],
        "conclusion": "Nancy is not paid by the school or does not have students.",
        "conclusion-FOL": "-PaidBy(Nancy, School) | -Have(Nancy, Student))",
        "label": "ERROR"
    },
    {
        "premises": "Kangaroos are an animal.\nNo Kangaroos live in Germany.\nJane will fly to Germany if she saves enough money for the summer.\nIf Jane flies to Germany, she will go to the Berlin Zoo.\nIf someone goes to the Berlin Zoo, they will see some of the animals in Germany.",
        "premises-FOL": [
            "all x. (Kangaroo(x) -> Animal(x))\nall x. (Kangaroo(x) -> -LiveIn(x, Germany))\nSavesFor(Jane, EnoughMoney, TheSummer) -> FlyTo(Jane, Germany)\nFlyTo(Jane, Germany) -> GoTo(Jane, Berlinzoo) \nall x. exists y. (GoTo(x, Berlinzoo) & LiveIn(x, Germany) & Animal(y) -> WillSee(y, x, Berlinzoo))"
        ],
        "conclusion": "Jane will see a kangaroo if she saves enough money for the summer.",
        "conclusion-FOL": "exists x. (SavesFor(Jane, EnoughMoney, TheSummer)  & Kangaroo(x) -> WillSee(x, Jane, Berlinzoo))",
        "label": "ERROR"
    },
    {
        "premises": "If a class has prerequisites, the student must take the prerequisites to take the class.\nIf a class has no prerequisites, then the student can take the class\nCPSC 201 and CPSC 223 are prerequisites for CPSC 323.\nIntro Microeconomics is the only prerequisite for Intermediate Microeconomics.\nIntro Geology has no prerequisites.",
        "premises-FOL": [
            "all x. all y. all z. (Class(x) & Student(y) & Prereq(z,x) & -Take(y, z) -> -CanTake(y, x))\nall x. all y. ((Class(x) & Student(y) & -exists z. Prereq(z,x)) -> CanTake(y, x))\nPrereq(CpscTwoZeroOne, CpscThreeTwoThree) & Prereq(CpscTwoTwoThree, CpscThreeTwoThree)\nall x. (Prereq(x,IntermediateMicro) -> x=IntroMicroeconomics)\n-(exists x. (Prereq(x, IntroGeology)))"
        ],
        "conclusion": "CPSC 201 has no prerequisites.",
        "conclusion-FOL": "all x. (-Prereq(x, CpscTwoZeroOne))",
        "label": "ERROR"
    },
    {
        "premises": "If a class has prerequisites, the student must take the prerequisites to take the class.\nIf a class has no prerequisites, then the student can take the class\nCPSC 201 and CPSC 223 are prerequisites for CPSC 323.\nIntro Microeconomics is the only prerequisite for Intermediate Microeconomics.\nIntro Geology has no prerequisites.",
        "premises-FOL": [
            "all x. all y. all z. (Class(x) & Student(y) & Prereq(z,x) & -Take(y, z) -> -CanTake(y, x))\nall x. all y. ((Class(x) & Student(y) & -exists z. Prereq(z,x)) -> CanTake(y, x))\nPrereq(CpscTwoZeroOne, CpscThreeTwoThree) & Prereq(CpscTwoTwoThree, CpscThreeTwoThree)\nall x. (Prereq(x,IntermediateMicro) -> x=IntroMicroeconomics)\n-(exists x. (Prereq(x, IntroGeology)))"
        ],
        "conclusion": "If a student took CPSC 201 but did not take CPSC 223, they can take CPSC 323.",
        "conclusion-FOL": "Taken(CpscTwoZeroOne) & -Taken(CpscTwoTwoThree) & CanTake(CpscThreeTwoThree)",
        "label": "ERROR"
    },
    {
        "premises": "If a class has prerequisites, the student must take the prerequisites to take the class.\nIf a class has no prerequisites, then the student can take the class\nCPSC 201 and CPSC 223 are prerequisites for CPSC 323.\nIntro Microeconomics is the only prerequisite for Intermediate Microeconomics.\nIntro Geology has no prerequisites.",
        "premises-FOL": [
            "all x. all y. all z. (Class(x) & Student(y) & Prereq(z,x) & -Take(y, z) -> -CanTake(y, x))\nall x. all y. ((Class(x) & Student(y) & -exists z. Prereq(z,x)) -> CanTake(y, x))\nPrereq(CpscTwoZeroOne, CpscThreeTwoThree) & Prereq(CpscTwoTwoThree, CpscThreeTwoThree)\nall x. (Prereq(x,IntermediateMicro) -> x=IntroMicroeconomics)\n-(exists x. (Prereq(x, IntroGeology)))"
        ],
        "conclusion": "A student cannot take Intro Geology.",
        "conclusion-FOL": "-CanTake(Introgeology)",
        "label": "ERROR"
    },
    {
        "premises": "If a class has prerequisites, the student must take the prerequisites to take the class.\nIf a class has no prerequisites, then the student can take the class\nCPSC 201 and CPSC 223 are prerequisites for CPSC 323.\nIntro Microeconomics is the only prerequisite for Intermediate Microeconomics.\nIntro Geology has no prerequisites.",
        "premises-FOL": [
            "all x. all y. all z. (Class(x) & Student(y) & Prereq(z,x) & -Take(y, z) -> -CanTake(y, x))\nall x. all y. ((Class(x) & Student(y) & -exists z. Prereq(z,x)) -> CanTake(y, x))\nPrereq(CpscTwoZeroOne, CpscThreeTwoThree) & Prereq(CpscTwoTwoThree, CpscThreeTwoThree)\nall x. (Prereq(x,IntermediateMicro) -> x=IntroMicroeconomics)\n-(exists x. (Prereq(x, IntroGeology)))"
        ],
        "conclusion": "Intermediate Microeconomics has one prerequisite.",
        "conclusion-FOL": "exists x. (Taken(x) -> CanTake(Intermediatemicro))",
        "label": "ERROR"
    },
    {
        "premises": "Heptalogyy is a compound literary or narrative work that is made up of seven distinct works.\nThe Harry Potter series consists of 7 distinct works.\nThe Chronicles of Narnia consists of 7 distinct works.",
        "premises-FOL": [
            "all x. (SevenDistinctWorks(x) -> Heptalogy(x))\nSevenDistinctWorks(HarryPotter)\nSevenDistinctWorks(ChroniclesOfNarnia)"
        ],
        "conclusion": "The Harry Potter series of books is Heptalogy.",
        "conclusion-FOL": "Heptalogy(HarryPotter)",
        "label": "ERROR"
    },
    {
        "premises": "Heptalogyy is a compound literary or narrative work that is made up of seven distinct works.\nThe Harry Potter series consists of 7 distinct works.\nThe Chronicles of Narnia consists of 7 distinct works.",
        "premises-FOL": [
            "all x. (SevenDistinctWorks(x) -> Heptalogy(x))\nSevenDistinctWorks(HarryPotter)\nSevenDistinctWorks(ChroniclesOfNarnia)"
        ],
        "conclusion": "The Chronicles of Narnia series of books is not Heptalogy.",
        "conclusion-FOL": "-Heptalogy(ChroniclesOfNarnia)",
        "label": "ERROR"
    },
    {
        "premises": "Heptalogyy is a compound literary or narrative work that is made up of seven distinct works.\nThe Harry Potter series consists of 7 distinct works.\nThe Chronicles of Narnia consists of 7 distinct works.",
        "premises-FOL": [
            "all x. (SevenDistinctWorks(x) -> Heptalogy(x))\nSevenDistinctWorks(HarryPotter)\nSevenDistinctWorks(ChroniclesOfNarnia)"
        ],
        "conclusion": "The Lord of the Rings is Heptalogy.",
        "conclusion-FOL": "Heptalogy(LordOfRings)",
        "label": "ERROR"
    },
    {
        "premises": "All people who attend Renaissance fairs regularly enjoy dressing up in old-fashioned and historical period clothing.\nIf people are fascinated by the history of the Renaissance and other past eras, then they attend Renaissance fairs regularly.\nPeople are fascinated by the history of the Renaissance and other past eras, or they are contemporary academics who enjoy learning.\nPeople who are focused on futuristic and vocational subjects are contemporary academics who enjoy learning.\nIf people are professors who take a historical approach, then they are not contemporary academics who enjoy learning.\nIf Clyde is not focused on futuristic and voctional subjects, then he is neither focused on futuristic and vocational subjects nor enjoys dressing up in old-fashioned and historical period clothing.",
        "premises-FOL": [
            "all x. (AttendRegularly(x, RenaissanceFair) -> Enjoy(x, DressingUp, OldFashionedClothing) & Enjoy(x, DressingUp, HistoricalPeriodClothing))\nall x. (FascinatedBy(x, HistoryOfRenaissance) -> AttendRegularly(x, RenaissanceFair))\nall x. (FascinatedBy(x, HistoryOfRenaissance) \u2295 (ContemporaryAcademic(x) & Enjoy(x, Learning)))\nall x. (FocusedOn(x, FuturisticSubject) & FocusedOn(x, VocationalSubject) -> ContemporaryAcademic(x) & Enjoy(x, Learning))\nall x. (Professor(x) & Take(x, HistoricalApproach) -> -(ContemporaryAcademic(x) & Enjoy(x, Learning)))\n-(FocusedOn(Clyde, FuturisticSubject) & FocusedOn(Clyde, VocationalSubject))-> -(FocusedOn(Clyde, FuturisticSubject) & FocusedOn(Clyde, VocationalSubject) | (Enjoy(Clyde, DressingUp, OldFashionedClothing) & Enjoy(Clyde, DressingUp, HistoricalPeriodClothing)))"
        ],
        "conclusion": "Clyde attends Renaissance fairs regularly.",
        "conclusion-FOL": "AttendRegularly(Clyde, RenaissanceFair)",
        "label": "ERROR"
    },
    {
        "premises": "All people who attend Renaissance fairs regularly enjoy dressing up in old-fashioned and historical period clothing.\nIf people are fascinated by the history of the Renaissance and other past eras, then they attend Renaissance fairs regularly.\nPeople are fascinated by the history of the Renaissance and other past eras, or they are contemporary academics who enjoy learning.\nPeople who are focused on futuristic and vocational subjects are contemporary academics who enjoy learning.\nIf people are professors who take a historical approach, then they are not contemporary academics who enjoy learning.\nIf Clyde is not focused on futuristic and voctional subjects, then he is neither focused on futuristic and vocational subjects nor enjoys dressing up in old-fashioned and historical period clothing.",
        "premises-FOL": [
            "all x. (AttendRegularly(x, RenaissanceFair) -> Enjoy(x, DressingUp, OldFashionedClothing) & Enjoy(x, DressingUp, HistoricalPeriodClothing))\nall x. (FascinatedBy(x, HistoryOfRenaissance) -> AttendRegularly(x, RenaissanceFair))\nall x. (FascinatedBy(x, HistoryOfRenaissance) \u2295 (ContemporaryAcademic(x) & Enjoy(x, Learning)))\nall x. (FocusedOn(x, FuturisticSubject) & FocusedOn(x, VocationalSubject) -> ContemporaryAcademic(x) & Enjoy(x, Learning))\nall x. (Professor(x) & Take(x, HistoricalApproach) -> -(ContemporaryAcademic(x) & Enjoy(x, Learning)))\n-(FocusedOn(Clyde, FuturisticSubject) & FocusedOn(Clyde, VocationalSubject))-> -(FocusedOn(Clyde, FuturisticSubject) & FocusedOn(Clyde, VocationalSubject) | (Enjoy(Clyde, DressingUp, OldFashionedClothing) & Enjoy(Clyde, DressingUp, HistoricalPeriodClothing)))"
        ],
        "conclusion": "Clyde is a professor who takes a historical approach.",
        "conclusion-FOL": "Professor(Clyde) & Take(Clyde, HistoricalApproach)",
        "label": "ERROR"
    },
    {
        "premises": "All people who attend Renaissance fairs regularly enjoy dressing up in old-fashioned and historical period clothing.\nIf people are fascinated by the history of the Renaissance and other past eras, then they attend Renaissance fairs regularly.\nPeople are fascinated by the history of the Renaissance and other past eras, or they are contemporary academics who enjoy learning.\nPeople who are focused on futuristic and vocational subjects are contemporary academics who enjoy learning.\nIf people are professors who take a historical approach, then they are not contemporary academics who enjoy learning.\nIf Clyde is not focused on futuristic and voctional subjects, then he is neither focused on futuristic and vocational subjects nor enjoys dressing up in old-fashioned and historical period clothing.",
        "premises-FOL": [
            "all x. (AttendRegularly(x, RenaissanceFair) -> Enjoy(x, DressingUp, OldFashionedClothing) & Enjoy(x, DressingUp, HistoricalPeriodClothing))\nall x. (FascinatedBy(x, HistoryOfRenaissance) -> AttendRegularly(x, RenaissanceFair))\nall x. (FascinatedBy(x, HistoryOfRenaissance) \u2295 (ContemporaryAcademic(x) & Enjoy(x, Learning)))\nall x. (FocusedOn(x, FuturisticSubject) & FocusedOn(x, VocationalSubject) -> ContemporaryAcademic(x) & Enjoy(x, Learning))\nall x. (Professor(x) & Take(x, HistoricalApproach) -> -(ContemporaryAcademic(x) & Enjoy(x, Learning)))\n-(FocusedOn(Clyde, FuturisticSubject) & FocusedOn(Clyde, VocationalSubject))-> -(FocusedOn(Clyde, FuturisticSubject) & FocusedOn(Clyde, VocationalSubject) | (Enjoy(Clyde, DressingUp, OldFashionedClothing) & Enjoy(Clyde, DressingUp, HistoricalPeriodClothing)))"
        ],
        "conclusion": "Clyde is a professor who takes a historical approach, or is a contemporary academic.",
        "conclusion-FOL": "(Professor(Clyde) & Take(Clyde, HistoricalApproach)) | (ContemporaryAcademic(Clyde) & Enjoy(Clyde, Learning))",
        "label": "ERROR"
    },
    {
        "premises": "No sports cars are vehicles intended to be driven at moderate speeds.\nAll automobiles designed for family use are vehicles intended to be driven at moderate speeds.",
        "premises-FOL": [
            "all x. (SportsCar(x) -> -IntendedToBeDrivenAt(x, ModerateSpeed))\nall x. (DesignedFor(x, FamilyUse) -> IntendedToBeDrivenAt(x, ModerateSpeed))"
        ],
        "conclusion": "No sports cars are automobiles designed for family use.",
        "conclusion-FOL": "all x. (SportsCar(x) -> -For(x, FamilyUse))",
        "label": "ERROR"
    },
    {
        "premises": "If people work well in teams in the workplace, then they get along with all their colleagues at their work.\nIf people come to work every day with a positive attitude, then they work well in teams in the workplace.\nPeople either come to work every day with a positive attitude or are always tired every morning.\nIf people are always tired in the morning, then they are criticized by their boss.\nIf people are criticized by their boss, then they do not receive positive feedback from teams at work.\nKat either is a person who works well in teams in the workplac and is always tired every morning, or she is neither.",
        "premises-FOL": [
            "all x. (WorkWellInTeamsIn(x, WorkPlace) -> all y. (Colleague(y) & GetAlongWithAtWork(x, y)))\nall x. (ComeToWorkWithEveryDay(x, PositiveAttitude) -> WorkWellInTeamsIn(x, WorkPlace))\nall x. (((ComeToWorkWithEveryDay(x, PositiveAttitude) & -AlwaysTiredInMorning(x)) | (-ComeToWorkWithEveryDay(x, PositiveAttitude) & AlwaysTiredInMorning(x))))\nall x. (AlwaysTiredInMorning(x) -> CriticizedBy(x, Boss))\nall x. (CriticizedBy(x, Boss) -> -ReceiveFromAtWork(x, PositiveFeedback, Team))\n-(((WorkWellInTeamsIn(Kat, WorkPlace) & -Tired(Kat)) | (-WorkWellInTeamsIn(Kat, WorkPlace) & Tired(Kat))))"
        ],
        "conclusion": "Kat is a person who comes to work every day with a positive attitude.",
        "conclusion-FOL": "ComeToWorkWithEveryDay(Kat, PositiveAttitude)",
        "label": "ERROR"
    },
    {
        "premises": "If people work well in teams in the workplace, then they get along with all their colleagues at their work.\nIf people come to work every day with a positive attitude, then they work well in teams in the workplace.\nPeople either come to work every day with a positive attitude or are always tired every morning.\nIf people are always tired in the morning, then they are criticized by their boss.\nIf people are criticized by their boss, then they do not receive positive feedback from teams at work.\nKat either is a person who works well in teams in the workplac and is always tired every morning, or she is neither.",
        "premises-FOL": [
            "all x. (WorkWellInTeamsIn(x, WorkPlace) -> all y. (Colleague(y) & GetAlongWithAtWork(x, y)))\nall x. (ComeToWorkWithEveryDay(x, PositiveAttitude) -> WorkWellInTeamsIn(x, WorkPlace))\nall x. (((ComeToWorkWithEveryDay(x, PositiveAttitude) & -AlwaysTiredInMorning(x)) | (-ComeToWorkWithEveryDay(x, PositiveAttitude) & AlwaysTiredInMorning(x))))\nall x. (AlwaysTiredInMorning(x) -> CriticizedBy(x, Boss))\nall x. (CriticizedBy(x, Boss) -> -ReceiveFromAtWork(x, PositiveFeedback, Team))\n-(((WorkWellInTeamsIn(Kat, WorkPlace) & -Tired(Kat)) | (-WorkWellInTeamsIn(Kat, WorkPlace) & Tired(Kat))))"
        ],
        "conclusion": "Kat gets along with her colleagues at her work and receives positive feedback from teams at her work.",
        "conclusion-FOL": "(all y. (Colleague(y) & GetAlongWithAtWork(Kat, y))) & ReceiveFromAtWork(Kat, PositiveFeedback, Team)",
        "label": "ERROR"
    },
    {
        "premises": "If people work well in teams in the workplace, then they get along with all their colleagues at their work.\nIf people come to work every day with a positive attitude, then they work well in teams in the workplace.\nPeople either come to work every day with a positive attitude or are always tired every morning.\nIf people are always tired in the morning, then they are criticized by their boss.\nIf people are criticized by their boss, then they do not receive positive feedback from teams at work.\nKat either is a person who works well in teams in the workplac and is always tired every morning, or she is neither.",
        "premises-FOL": [
            "all x. (WorkWellInTeamsIn(x, WorkPlace) -> all y. (Colleague(y) & GetAlongWithAtWork(x, y)))\nall x. (ComeToWorkWithEveryDay(x, PositiveAttitude) -> WorkWellInTeamsIn(x, WorkPlace))\nall x. (((ComeToWorkWithEveryDay(x, PositiveAttitude) & -AlwaysTiredInMorning(x)) | (-ComeToWorkWithEveryDay(x, PositiveAttitude) & AlwaysTiredInMorning(x))))\nall x. (AlwaysTiredInMorning(x) -> CriticizedBy(x, Boss))\nall x. (CriticizedBy(x, Boss) -> -ReceiveFromAtWork(x, PositiveFeedback, Team))\n-(((WorkWellInTeamsIn(Kat, WorkPlace) & -Tired(Kat)) | (-WorkWellInTeamsIn(Kat, WorkPlace) & Tired(Kat))))"
        ],
        "conclusion": "Kat either gets along with her colleagues at her work or receives positive feedback from teams at her work.",
        "conclusion-FOL": "(all y. (Colleague(y) & GetAlongWithAtWork(Kat, y))) \u2295 ReceiveFromAtWork(Kat, PositiveFeedback, Team)",
        "label": "ERROR"
    },
    {
        "premises": "Drishti is an open-source software.\nOpen-source software is free to modify.",
        "premises-FOL": [
            "OpenSourceSoftware(Drishti)\nall x. (OpenSourceSoftware(x) -> FreeToModify(x))"
        ],
        "conclusion": "Drishti is free to modify.",
        "conclusion-FOL": "FreeToModify(Drishti)",
        "label": "ERROR"
    },
    {
        "premises": "There are five grades in English class: A+, A, B+, B, and C. \nIf a student gets an A+ in English class, then his score is greater than 95.\nIf a student gets an A in English class, then his score is greater than 90 but lower than 95.\nZhang got an A in English class.\nWang's English class score is better than Zhang's.\nWu's English class score is lower than 90.\nIf a student's English class score is lower than 90, then it is not greater than 95 or 90, and lower than 95.",
        "premises-FOL": [
            "GradeIn(aPlus, EnglishClass) | GradeIn(a, EnglishClass) | GradeIn(bPlus, EnglishClass) | GradeIn(b, EnglishClass) | GradeIn(c, EnglishClass) & (GradeIn(aPlus, EnglishClass) -> -GradeIn(a, EnglishClass) & -GradeIn(bPlus, EnglishClass) & -GradeIn(b, EnglishClass) & -GradeIn(c, EnglishClass)) & (GradeIn(a, EnglishClass) -> -GradeIn(aPlus, EnglishClass) & -GradeIn(bPlus, EnglishClass) & -GradeIn(b, EnglishClass) & -GradeIn(c, EnglishClass)) & (GradeIn(bPlus, EnglishClass) -> -GradeIn(aPlus, EnglishClass) & -GradeIn(a, EnglishClass) & -GradeIn(b, EnglishClass) & -GradeIn(c, EnglishClass)) & (GradeIn(b, EnglishClass) -> -GradeIn(aPlus, EnglishClass) & -GradeIn(a, EnglishClass) & -GradeIn(bPlus, EnglishClass) & -GradeIn(c, EnglishClass)) & (GradeIn(c, EnglishClass) -> -GradeIn(aPlus, EnglishClass) & -GradeIn(a, EnglishClass) & -GradeIn(bPlus, EnglishClass) & -GradeIn(b, EnglishClass)) \nall x. all y. (Student(x) & GetGradeIn(x, aPlus, EnglishClass) -> EnglishClassScore(x, y) & GreaterThanNineFive(y))\nall x. all y. (Student(x) & GetGradeIn(x, a, EnglishClass) -> EnglishClassScore(x, y) & GreaterThanNineZero(y) & LowerThanNineFive(y)) \nStudent(Zhang) & GetGradeIn(Zhang, a, EnglishClass)\nall x. all y. (Student(Zhang) & Student(Wang) & EnglishScore(Zhang, x) & EnglishScore(Wang, y) & Better(y, x))\nall x. (Student(Wu) & EnglishScore(Wu, x) & LowerThanNineZero(x))\nall x. all y. (Student(x) & EnglishScore(x, y) & LowerThanNineZero(y) -> -GreaterThanNineFive(y) & -GreaterThanNineZero(y) & LowerThanNineFive(y))"
        ],
        "conclusion": "Zhang's English class score is lower than 95.",
        "conclusion-FOL": "all x. (EnglishScore(Zhang, x) & LowerThanNineFive(x))",
        "label": "ERROR"
    },
    {
        "premises": "There are five grades in English class: A+, A, B+, B, and C. \nIf a student gets an A+ in English class, then his score is greater than 95.\nIf a student gets an A in English class, then his score is greater than 90 but lower than 95.\nZhang got an A in English class.\nWang's English class score is better than Zhang's.\nWu's English class score is lower than 90.\nIf a student's English class score is lower than 90, then it is not greater than 95 or 90, and lower than 95.",
        "premises-FOL": [
            "GradeIn(aPlus, EnglishClass) | GradeIn(a, EnglishClass) | GradeIn(bPlus, EnglishClass) | GradeIn(b, EnglishClass) | GradeIn(c, EnglishClass) & (GradeIn(aPlus, EnglishClass) -> -GradeIn(a, EnglishClass) & -GradeIn(bPlus, EnglishClass) & -GradeIn(b, EnglishClass) & -GradeIn(c, EnglishClass)) & (GradeIn(a, EnglishClass) -> -GradeIn(aPlus, EnglishClass) & -GradeIn(bPlus, EnglishClass) & -GradeIn(b, EnglishClass) & -GradeIn(c, EnglishClass)) & (GradeIn(bPlus, EnglishClass) -> -GradeIn(aPlus, EnglishClass) & -GradeIn(a, EnglishClass) & -GradeIn(b, EnglishClass) & -GradeIn(c, EnglishClass)) & (GradeIn(b, EnglishClass) -> -GradeIn(aPlus, EnglishClass) & -GradeIn(a, EnglishClass) & -GradeIn(bPlus, EnglishClass) & -GradeIn(c, EnglishClass)) & (GradeIn(c, EnglishClass) -> -GradeIn(aPlus, EnglishClass) & -GradeIn(a, EnglishClass) & -GradeIn(bPlus, EnglishClass) & -GradeIn(b, EnglishClass)) \nall x. all y. (Student(x) & GetGradeIn(x, aPlus, EnglishClass) -> EnglishClassScore(x, y) & GreaterThanNineFive(y))\nall x. all y. (Student(x) & GetGradeIn(x, a, EnglishClass) -> EnglishClassScore(x, y) & GreaterThanNineZero(y) & LowerThanNineFive(y)) \nStudent(Zhang) & GetGradeIn(Zhang, a, EnglishClass)\nall x. all y. (Student(Zhang) & Student(Wang) & EnglishScore(Zhang, x) & EnglishScore(Wang, y) & Better(y, x))\nall x. (Student(Wu) & EnglishScore(Wu, x) & LowerThanNineZero(x))\nall x. all y. (Student(x) & EnglishScore(x, y) & LowerThanNineZero(y) -> -GreaterThanNineFive(y) & -GreaterThanNineZero(y) & LowerThanNineFive(y))"
        ],
        "conclusion": "Wang got an A+ in English class.",
        "conclusion-FOL": "GetGradeIn(Wang, aPlus, EnglishClass)",
        "label": "ERROR"
    },
    {
        "premises": "There are five grades in English class: A+, A, B+, B, and C. \nIf a student gets an A+ in English class, then his score is greater than 95.\nIf a student gets an A in English class, then his score is greater than 90 but lower than 95.\nZhang got an A in English class.\nWang's English class score is better than Zhang's.\nWu's English class score is lower than 90.\nIf a student's English class score is lower than 90, then it is not greater than 95 or 90, and lower than 95.",
        "premises-FOL": [
            "GradeIn(aPlus, EnglishClass) | GradeIn(a, EnglishClass) | GradeIn(bPlus, EnglishClass) | GradeIn(b, EnglishClass) | GradeIn(c, EnglishClass) & (GradeIn(aPlus, EnglishClass) -> -GradeIn(a, EnglishClass) & -GradeIn(bPlus, EnglishClass) & -GradeIn(b, EnglishClass) & -GradeIn(c, EnglishClass)) & (GradeIn(a, EnglishClass) -> -GradeIn(aPlus, EnglishClass) & -GradeIn(bPlus, EnglishClass) & -GradeIn(b, EnglishClass) & -GradeIn(c, EnglishClass)) & (GradeIn(bPlus, EnglishClass) -> -GradeIn(aPlus, EnglishClass) & -GradeIn(a, EnglishClass) & -GradeIn(b, EnglishClass) & -GradeIn(c, EnglishClass)) & (GradeIn(b, EnglishClass) -> -GradeIn(aPlus, EnglishClass) & -GradeIn(a, EnglishClass) & -GradeIn(bPlus, EnglishClass) & -GradeIn(c, EnglishClass)) & (GradeIn(c, EnglishClass) -> -GradeIn(aPlus, EnglishClass) & -GradeIn(a, EnglishClass) & -GradeIn(bPlus, EnglishClass) & -GradeIn(b, EnglishClass)) \nall x. all y. (Student(x) & GetGradeIn(x, aPlus, EnglishClass) -> EnglishClassScore(x, y) & GreaterThanNineFive(y))\nall x. all y. (Student(x) & GetGradeIn(x, a, EnglishClass) -> EnglishClassScore(x, y) & GreaterThanNineZero(y) & LowerThanNineFive(y)) \nStudent(Zhang) & GetGradeIn(Zhang, a, EnglishClass)\nall x. all y. (Student(Zhang) & Student(Wang) & EnglishScore(Zhang, x) & EnglishScore(Wang, y) & Better(y, x))\nall x. (Student(Wu) & EnglishScore(Wu, x) & LowerThanNineZero(x))\nall x. all y. (Student(x) & EnglishScore(x, y) & LowerThanNineZero(y) -> -GreaterThanNineFive(y) & -GreaterThanNineZero(y) & LowerThanNineFive(y))"
        ],
        "conclusion": "Wu does not get an A or A+ in English class.",
        "conclusion-FOL": "-GetGradeIn(Wu, aPlus, EnglishClass) &-GetGradeIn(Wu, a, EnglishClass)",
        "label": "ERROR"
    },
    {
        "premises": "Olivia doesn't prefer warm temperatures during the day.\nWhen Olivia sleeps, she prefers a cool temperature.\nOlivia sleeps during the night.\nOlivia works during the day.\nOlivia either works or sleeps.\nIt is either the day or the night.\nOlivia either prefers warm temperatures or prefers cool temperatures.",
        "premises-FOL": [
            "all x. (Day(x) -> -Prefer(Olivia, WarmTemperature, x))\nall x. (Sleep(Olivia, x) -> Prefer(Olivia, CoolTemperature, x))\nall x. (Night(x) -> Sleep(Olivia, x))\nall x. (Day(x) -> Work(Olivia, x))\n((Work(Olivia) & -Sleep(Olivia)) | (-Work(Olivia) & Sleep(Olivia)))\nall x. (((Day(x) & -Night(x)) | (-Day(x) & Night(x))))\nall x. (((Prefer(Olivia, WarmTemperature, x) & -Prefer(Olivia, CoolTemperature, x)) | (-Prefer(Olivia, WarmTemperature, x) & Prefer(Olivia, CoolTemperature, x))))"
        ],
        "conclusion": "At all times, Olivia prefers a cool temperature.",
        "conclusion-FOL": "all x. (Prefer(Olivia, CoolTemperature, x))",
        "label": "ERROR"
    },
    {
        "premises": "TOra is a GUI.\nGUIs are software.\nSoftware can be free or paid.\nPaid Software is not under the GNU General Public License.\nTOra is under the GNU General Public License.",
        "premises-FOL": [
            "GUI(Tora)\nall x. (GUI(x) -> Software(x))\nall x. (Software(x) -> ((Free(x) & -Paid(x)) | (-Free(x) & Paid(x))))\nall x. (Paid(x) & Software(x) -> -UnderGNULicense(x))\nUnderGNULicense(Tora)"
        ],
        "conclusion": "TOra is a paid software.",
        "conclusion-FOL": "Paid(Tora) & Software(Tora)",
        "label": "ERROR"
    },
    {
        "premises": "TOra is a GUI.\nGUIs are software.\nSoftware can be free or paid.\nPaid Software is not under the GNU General Public License.\nTOra is under the GNU General Public License.",
        "premises-FOL": [
            "GUI(Tora)\nall x. (GUI(x) -> Software(x))\nall x. (Software(x) -> ((Free(x) & -Paid(x)) | (-Free(x) & Paid(x))))\nall x. (Paid(x) & Software(x) -> -UnderGNULicense(x))\nUnderGNULicense(Tora)"
        ],
        "conclusion": "TOra is a free software.",
        "conclusion-FOL": "Free(Tora) & Software(Tora)",
        "label": "ERROR"
    },
    {
        "premises": "Customers choose a Prime Video plan or an HBO Max Plan, or both. \nAll customers who choose a Prime Video Plan are rewarded with a $30 gift card. \nThere are no customers who do not choose any plan. \nNone of the customers who are rewarded with a $30 gift card are older than 80.\nAll the customers are either older than 80 or between the ages of 60 and 80.\nJames is a customer who is not between the ages of 60 and 80. ",
        "premises-FOL": [
            "all x. (Customer(x) -> (Choose(x, PrimeVideoPlan) | Choose(x, hBOMaxPlan)))\nall x. ((Customer(x) & Choose(x, hBOMaxPlan)) -> RewardWith(x, GiftCard))\nall x. (Customer(x) -> (exists y.(Plan(y) & Choose(x, y))))\nall x. ((Customer(x) & RewardWith(x, GiftCard)) -> (-OlderThan(x, NumEightZero)))\nall x. (((Customer(x) -> (exists y.(GreaterThan(y, NumEightZero) & Age(James,y)) & -(exists y.(Between(y, NumSixZero, NumEightZero) & Age(James, y))) | (-(Customer(x) -> (exists y.(GreaterThan(y, NumEightZero) & Age(James,y)) & (exists y.(Between(y, NumSixZero, NumEightZero) & Age(James, y)))))))\nCustomer(James) & (-exists y.(Between(y, NumSixZero, NumEightZero) & Age(James, y)))"
        ],
        "conclusion": "James is a customer who does not choose any plans.",
        "conclusion-FOL": "Choose(James, NoPlan)",
        "label": "ERROR"
    },
    {
        "premises": "Customers choose a Prime Video plan or an HBO Max Plan, or both. \nAll customers who choose a Prime Video Plan are rewarded with a $30 gift card. \nThere are no customers who do not choose any plan. \nNone of the customers who are rewarded with a $30 gift card are older than 80.\nAll the customers are either older than 80 or between the ages of 60 and 80.\nJames is a customer who is not between the ages of 60 and 80. ",
        "premises-FOL": [
            "all x. (Customer(x) -> (Choose(x, PrimeVideoPlan) | Choose(x, hBOMaxPlan)))\nall x. ((Customer(x) & Choose(x, hBOMaxPlan)) -> RewardWith(x, GiftCard))\nall x. (Customer(x) -> (exists y.(Plan(y) & Choose(x, y))))\nall x. ((Customer(x) & RewardWith(x, GiftCard)) -> (-OlderThan(x, NumEightZero)))\nall x. (((Customer(x) -> (exists y.(GreaterThan(y, NumEightZero) & Age(James,y)) & -(exists y.(Between(y, NumSixZero, NumEightZero) & Age(James, y))) | (-(Customer(x) -> (exists y.(GreaterThan(y, NumEightZero) & Age(James,y)) & (exists y.(Between(y, NumSixZero, NumEightZero) & Age(James, y)))))))\nCustomer(James) & (-exists y.(Between(y, NumSixZero, NumEightZero) & Age(James, y)))"
        ],
        "conclusion": "James is a customer who chooses a Prime Video plan or does not choose any plans.",
        "conclusion-FOL": "Choose(James, PlanA) | Choose(James, NoPlan)",
        "label": "ERROR"
    },
    {
        "premises": "Customers choose a Prime Video plan or an HBO Max Plan, or both. \nAll customers who choose a Prime Video Plan are rewarded with a $30 gift card. \nThere are no customers who do not choose any plan. \nNone of the customers who are rewarded with a $30 gift card are older than 80.\nAll the customers are either older than 80 or between the ages of 60 and 80.\nJames is a customer who is not between the ages of 60 and 80. ",
        "premises-FOL": [
            "all x. (Customer(x) -> (Choose(x, PrimeVideoPlan) | Choose(x, hBOMaxPlan)))\nall x. ((Customer(x) & Choose(x, hBOMaxPlan)) -> RewardWith(x, GiftCard))\nall x. (Customer(x) -> (exists y.(Plan(y) & Choose(x, y))))\nall x. ((Customer(x) & RewardWith(x, GiftCard)) -> (-OlderThan(x, NumEightZero)))\nall x. (((Customer(x) -> (exists y.(GreaterThan(y, NumEightZero) & Age(James,y)) & -(exists y.(Between(y, NumSixZero, NumEightZero) & Age(James, y))) | (-(Customer(x) -> (exists y.(GreaterThan(y, NumEightZero) & Age(James,y)) & (exists y.(Between(y, NumSixZero, NumEightZero) & Age(James, y)))))))\nCustomer(James) & (-exists y.(Between(y, NumSixZero, NumEightZero) & Age(James, y)))"
        ],
        "conclusion": "Suppose James is a customer who chooses the Prime Video plan or does not choose any plans, then he is either rewarded a $30 gift card or chooses the HBO Max plan.",
        "conclusion-FOL": "Choose(James, PlanA) | Choose(James, NoPlan) -> ((RewardWith(James, GiftCard) & -Choose(James, PlanB)) | (-RewardWith(James, GiftCard) & Choose(James, PlanB)))",
        "label": "ERROR"
    },
    {
        "premises": "Detroit City is a horse.\nSome horses are racehorses.\nIf a horse falls in a race, it poses risks to its rider.\nDetroit City fell in a race.\nA horse is a racehorse if it is in a race.",
        "premises-FOL": [
            "Horse(Detroitcity)\nexists x. (Horse(x) & Racehorse(x))\nall x. (Horse(x) & InRace(x) & Falls(x) -> PoseRiskTo(x, Rider))\nInRace(Detroitcity) & Fall(Detroitcity)\nall x. (Horse(x) & InRace(x) -> Racehorse(x))"
        ],
        "conclusion": "Detroit City has been in multiple races.",
        "conclusion-FOL": "MultipleRace(Detroitcity)",
        "label": "ERROR"
    },
    {
        "premises": "Detroit City is a horse.\nSome horses are racehorses.\nIf a horse falls in a race, it poses risks to its rider.\nDetroit City fell in a race.\nA horse is a racehorse if it is in a race.",
        "premises-FOL": [
            "Horse(Detroitcity)\nexists x. (Horse(x) & Racehorse(x))\nall x. (Horse(x) & InRace(x) & Falls(x) -> PoseRiskTo(x, Rider))\nInRace(Detroitcity) & Fall(Detroitcity)\nall x. (Horse(x) & InRace(x) -> Racehorse(x))"
        ],
        "conclusion": "Detroit City poses risks to its rider.",
        "conclusion-FOL": "PoseRiskTo(Detroitcity, Rider)",
        "label": "ERROR"
    },
    {
        "premises": "Detroit City is a horse.\nSome horses are racehorses.\nIf a horse falls in a race, it poses risks to its rider.\nDetroit City fell in a race.\nA horse is a racehorse if it is in a race.",
        "premises-FOL": [
            "Horse(Detroitcity)\nexists x. (Horse(x) & Racehorse(x))\nall x. (Horse(x) & InRace(x) & Falls(x) -> PoseRiskTo(x, Rider))\nInRace(Detroitcity) & Fall(Detroitcity)\nall x. (Horse(x) & InRace(x) -> Racehorse(x))"
        ],
        "conclusion": "Detroit City is a racehorse.",
        "conclusion-FOL": "Racehorse(Detroitcity)",
        "label": "ERROR"
    },
    {
        "premises": "Frederick Monhoff was an architect, artist, and illustrator.\nFrederick Monhoff was an American.\nAn artist is good at physical or conceptual art.\nAll Americans are American citizens.",
        "premises-FOL": [
            "Architect(Monhoff) & Artist(Monhoff) & Illustrator(Monhoff)\nAmerican(Monhoff)\nall x. (Artist(x) -> GoodAt(x, PhysicalArt) | GoodAt(x, ConceptualArt))\nall x. (American(x) -> AmericanCitizen(x))"
        ],
        "conclusion": "Frederick Monhoff was good at physical art.",
        "conclusion-FOL": "GoodAt(Monhoff, PhysicalArt)",
        "label": "ERROR"
    },
    {
        "premises": "Frederick Monhoff was an architect, artist, and illustrator.\nFrederick Monhoff was an American.\nAn artist is good at physical or conceptual art.\nAll Americans are American citizens.",
        "premises-FOL": [
            "Architect(Monhoff) & Artist(Monhoff) & Illustrator(Monhoff)\nAmerican(Monhoff)\nall x. (Artist(x) -> GoodAt(x, PhysicalArt) | GoodAt(x, ConceptualArt))\nall x. (American(x) -> AmericanCitizen(x))"
        ],
        "conclusion": "No illustrator was an American citizen.",
        "conclusion-FOL": "-(exists x. (Illustrator(x) & AmericanCitizen(x)))",
        "label": "ERROR"
    },
    {
        "premises": "Miroslav Fiedler was a Czech mathematician.\nMiroslav Fiedler is known for his contributions to linear algebra and graph theory.\nMiroslav Fiedler is honored by the Fiedler eigenvalue.\nFiedler eigenvalue is the second smallest eigenvalue of the graph Laplacian.",
        "premises-FOL": [
            "Czech(MiroslavFiedler) & Mathematician(MiroslavFiedler)\nKnownFor(MiroslavFiedler, ContributionsToLinearAlgebraAndGraphTheory)\nHonoredBy(MiroslavFiedler, FiedlerEigenvalue)\nTheSecondSmallestEigenvalueOf(FiedlerEigenvalue, TheGraphLaplacian)"
        ],
        "conclusion": "Miroslav Fiedler is honored by the second smallest eigenvalue of the graph Laplacian.",
        "conclusion-FOL": "exists x. (TheSecondSmallestEigenvalueOf(x, TheGraphLaplacian) & HonoredBy(MiroslavFiedler, x))",
        "label": "ERROR"
    },
    {
        "premises": "Miroslav Fiedler was a Czech mathematician.\nMiroslav Fiedler is known for his contributions to linear algebra and graph theory.\nMiroslav Fiedler is honored by the Fiedler eigenvalue.\nFiedler eigenvalue is the second smallest eigenvalue of the graph Laplacian.",
        "premises-FOL": [
            "Czech(MiroslavFiedler) & Mathematician(MiroslavFiedler)\nKnownFor(MiroslavFiedler, ContributionsToLinearAlgebraAndGraphTheory)\nHonoredBy(MiroslavFiedler, FiedlerEigenvalue)\nTheSecondSmallestEigenvalueOf(FiedlerEigenvalue, TheGraphLaplacian)"
        ],
        "conclusion": "Miroslav Fiedler was a French mathematician.",
        "conclusion-FOL": "French(MiroslavFiedler) & Mathematician(MiroslavFiedler)",
        "label": "ERROR"
    },
    {
        "premises": "Miroslav Fiedler was a Czech mathematician.\nMiroslav Fiedler is known for his contributions to linear algebra and graph theory.\nMiroslav Fiedler is honored by the Fiedler eigenvalue.\nFiedler eigenvalue is the second smallest eigenvalue of the graph Laplacian.",
        "premises-FOL": [
            "Czech(MiroslavFiedler) & Mathematician(MiroslavFiedler)\nKnownFor(MiroslavFiedler, ContributionsToLinearAlgebraAndGraphTheory)\nHonoredBy(MiroslavFiedler, FiedlerEigenvalue)\nTheSecondSmallestEigenvalueOf(FiedlerEigenvalue, TheGraphLaplacian)"
        ],
        "conclusion": "A Czech mathematician is known for his contributions to linear algebra and graph theory.",
        "conclusion-FOL": "exists x. (Czech(x) & Mathematician(x) & KnownFor(x, ContributionsToLinearAlgebraAndGraphTheory))",
        "label": "ERROR"
    },
    {
        "premises": "A laptop is a computer.\nYou can play games on a computer.\nA phone is not a computer.",
        "premises-FOL": [
            "all x. (Laptop(x) -> Computer(x))\nall x. (Computer(x) -> CanPlayGameOn(x))\nall x. (Phone(x) -> -Computer(x))"
        ],
        "conclusion": "You can play games on a laptop.",
        "conclusion-FOL": "all x. (Laptop(x) -> CanPlayGameOn(x))",
        "label": "ERROR"
    },
    {
        "premises": "A laptop is a computer.\nYou can play games on a computer.\nA phone is not a computer.",
        "premises-FOL": [
            "all x. (Laptop(x) -> Computer(x))\nall x. (Computer(x) -> CanPlayGameOn(x))\nall x. (Phone(x) -> -Computer(x))"
        ],
        "conclusion": "You can not play games on a phone.",
        "conclusion-FOL": "all x. (Phone(x) -> -CanPlayGameOn(x))",
        "label": "ERROR"
    },
    {
        "premises": "Walter Folger Brown was an American politician and lawyer who served as the postmaster general.\nWalter Folger Brown graduated from Harvard University with a Bachelor of Arts.\nWhile they were both in Toledo, Walter Folger Brown's father practiced law with Walter Folger Brown.\nKatherin Hafer married Walter Folger Brown.",
        "premises-FOL": [
            "AmericanPolitician(WalterBrown) & Lawyer(WalterBrown) & ServedAs(WalterBrown, PostMasterGeneral)\nGraduated(WalterBrown, Harvard) & GraduatedWith(WalterBrown, BachelorsOfArt)\nexists t.(In(WalterBrown, Toledo, t) & In(WalterBrownFather, Toledo, t) & PracticedLawTogether(WalterBrown, WalterBrownFather, t))\nMarried(KatherinHafer, WalterBrown)"
        ],
        "conclusion": "Walter Folger Brown graduated with a Bachelor of Arts.",
        "conclusion-FOL": "GraduatedWith(WalterBrown, BachelorsOfArt)",
        "label": "ERROR"
    },
    {
        "premises": "Walter Folger Brown was an American politician and lawyer who served as the postmaster general.\nWalter Folger Brown graduated from Harvard University with a Bachelor of Arts.\nWhile they were both in Toledo, Walter Folger Brown's father practiced law with Walter Folger Brown.\nKatherin Hafer married Walter Folger Brown.",
        "premises-FOL": [
            "AmericanPolitician(WalterBrown) & Lawyer(WalterBrown) & ServedAs(WalterBrown, PostMasterGeneral)\nGraduated(WalterBrown, Harvard) & GraduatedWith(WalterBrown, BachelorsOfArt)\nexists t.(In(WalterBrown, Toledo, t) & In(WalterBrownFather, Toledo, t) & PracticedLawTogether(WalterBrown, WalterBrownFather, t))\nMarried(KatherinHafer, WalterBrown)"
        ],
        "conclusion": "Walter Folger Brown's father was in Toledo.",
        "conclusion-FOL": "exists t.(In(WalterBrownFather, Toledo, t))",
        "label": "ERROR"
    },
    {
        "premises": "Walter Folger Brown was an American politician and lawyer who served as the postmaster general.\nWalter Folger Brown graduated from Harvard University with a Bachelor of Arts.\nWhile they were both in Toledo, Walter Folger Brown's father practiced law with Walter Folger Brown.\nKatherin Hafer married Walter Folger Brown.",
        "premises-FOL": [
            "AmericanPolitician(WalterBrown) & Lawyer(WalterBrown) & ServedAs(WalterBrown, PostMasterGeneral)\nGraduated(WalterBrown, Harvard) & GraduatedWith(WalterBrown, BachelorsOfArt)\nexists t.(In(WalterBrown, Toledo, t) & In(WalterBrownFather, Toledo, t) & PracticedLawTogether(WalterBrown, WalterBrownFather, t))\nMarried(KatherinHafer, WalterBrown)"
        ],
        "conclusion": "Walter Folger Brown was not in Toledo.",
        "conclusion-FOL": "exists t.(-In(WalterBrownFather, Toledo, t))",
        "label": "ERROR"
    },
    {
        "premises": "All products designed by Apple are sold at Apple Stores.\nAll products with Apple logos are designed by Apple.\nAll Macbooks have Apple logos.\nAll products with Apple M2 chips are Mackbooks.\nA Thinkpad X1 is not both sold in Apple Stores and is a Macbook.",
        "premises-FOL": [
            "all x. ((Product(x) & DesignedBy(x, Apple)) -> SoldIn(x, AppleStore))\nall x. ((Product(x) & With(x, AppleLogo)) -> DesignedBy(x, Apple))\nall x. (Macbook(x) -> With(x, AppleLogo))\nall x. ((Product(x) & With(x, AppleMTwoChip)) -> Macbook(x))\n-(SoldIn(ThinkpadXOne, AppleStore) & Macbook(ThinkpadXOne))"
        ],
        "conclusion": "The Thinkpad X1 has an Apple M2 chip.",
        "conclusion-FOL": "With(ThinkpadXOne, AppleMTwoChip)",
        "label": "ERROR"
    },
    {
        "premises": "All products designed by Apple are sold at Apple Stores.\nAll products with Apple logos are designed by Apple.\nAll Macbooks have Apple logos.\nAll products with Apple M2 chips are Mackbooks.\nA Thinkpad X1 is not both sold in Apple Stores and is a Macbook.",
        "premises-FOL": [
            "all x. ((Product(x) & DesignedBy(x, Apple)) -> SoldIn(x, AppleStore))\nall x. ((Product(x) & With(x, AppleLogo)) -> DesignedBy(x, Apple))\nall x. (Macbook(x) -> With(x, AppleLogo))\nall x. ((Product(x) & With(x, AppleMTwoChip)) -> Macbook(x))\n-(SoldIn(ThinkpadXOne, AppleStore) & Macbook(ThinkpadXOne))"
        ],
        "conclusion": "The Thinkpad X1 is sold in Apple Stores.",
        "conclusion-FOL": "SoldIn(ThinkpadXOne, AppleStore)",
        "label": "ERROR"
    },
    {
        "premises": "All products designed by Apple are sold at Apple Stores.\nAll products with Apple logos are designed by Apple.\nAll Macbooks have Apple logos.\nAll products with Apple M2 chips are Mackbooks.\nA Thinkpad X1 is not both sold in Apple Stores and is a Macbook.",
        "premises-FOL": [
            "all x. ((Product(x) & DesignedBy(x, Apple)) -> SoldIn(x, AppleStore))\nall x. ((Product(x) & With(x, AppleLogo)) -> DesignedBy(x, Apple))\nall x. (Macbook(x) -> With(x, AppleLogo))\nall x. ((Product(x) & With(x, AppleMTwoChip)) -> Macbook(x))\n-(SoldIn(ThinkpadXOne, AppleStore) & Macbook(ThinkpadXOne))"
        ],
        "conclusion": "The Thinkpad X1 has an Apple M2 chip and is a Macbook.",
        "conclusion-FOL": "With(ThinkpadXOne, AppleMTwoChip) & Macbook(ThinkpadXOne)",
        "label": "ERROR"
    },
    {
        "premises": "All products designed by Apple are sold at Apple Stores.\nAll products with Apple logos are designed by Apple.\nAll Macbooks have Apple logos.\nAll products with Apple M2 chips are Mackbooks.\nA Thinkpad X1 is not both sold in Apple Stores and is a Macbook.",
        "premises-FOL": [
            "all x. ((Product(x) & DesignedBy(x, Apple)) -> SoldIn(x, AppleStore))\nall x. ((Product(x) & With(x, AppleLogo)) -> DesignedBy(x, Apple))\nall x. (Macbook(x) -> With(x, AppleLogo))\nall x. ((Product(x) & With(x, AppleMTwoChip)) -> Macbook(x))\n-(SoldIn(ThinkpadXOne, AppleStore) & Macbook(ThinkpadXOne))"
        ],
        "conclusion": "The Thinkpad X1 either has an Apple M2 chip or is a Macbook.",
        "conclusion-FOL": "With(ThinkpadXOne, AppleMTwoChip)) \u2295 Macbook(ThinkpadXOne)",
        "label": "ERROR"
    },
    {
        "premises": "All products designed by Apple are sold at Apple Stores.\nAll products with Apple logos are designed by Apple.\nAll Macbooks have Apple logos.\nAll products with Apple M2 chips are Mackbooks.\nA Thinkpad X1 is not both sold in Apple Stores and is a Macbook.",
        "premises-FOL": [
            "all x. ((Product(x) & DesignedBy(x, Apple)) -> SoldIn(x, AppleStore))\nall x. ((Product(x) & With(x, AppleLogo)) -> DesignedBy(x, Apple))\nall x. (Macbook(x) -> With(x, AppleLogo))\nall x. ((Product(x) & With(x, AppleMTwoChip)) -> Macbook(x))\n-(SoldIn(ThinkpadXOne, AppleStore) & Macbook(ThinkpadXOne))"
        ],
        "conclusion": "If the Thinkpad X1 has an Apple M2 chip and is a Macbook, then it neither has an Apple M2 chip nor is sold in Apple Stores.",
        "conclusion-FOL": "(With(ThinkpadXOne, AppleMTwoChip) & Macbook(ThinkpadXOne)) -> -(With(ThinkpadXOne, AppleMTwoChip) | SoldIn(ThinkpadXOne, AppleStore))",
        "label": "ERROR"
    },
    {
        "premises": "Oxford Circus is a road junction connecting Oxford Street and Regent Street.\nOxford Street and Regent Street are in London.\nJohn Nash designed a construction on Regent Street.\nJohn Nash designed Oxford Circus.\nJohn Nash is a British architect.\nOxford Circus is the entrance to Oxford Circus tube station, a part of the Central line in 1900.",
        "premises-FOL": [
            "RoadJunction(OxfordCircus) & Connect(OxfordCircus, OxfordSt, RegentSt)\nIn(OxfordSt, London) & In(RegentSt, London)\nDesigned(Nash, Construction) & On(Construction, RegentSt)\nDesigned(Nash, OxfordCircus)\nArchitect(Nash) & British(Nash)\nEntraceTo(OxfordCircus, TubeStation) & PartOf(TubeStation, Centralline) & In(TubeStation, OneNineZeroZero)"
        ],
        "conclusion": "Oxford Circus is in London.",
        "conclusion-FOL": "In(OxfordCircus, London)",
        "label": "ERROR"
    },
    {
        "premises": "Oxford Circus is a road junction connecting Oxford Street and Regent Street.\nOxford Street and Regent Street are in London.\nJohn Nash designed a construction on Regent Street.\nJohn Nash designed Oxford Circus.\nJohn Nash is a British architect.\nOxford Circus is the entrance to Oxford Circus tube station, a part of the Central line in 1900.",
        "premises-FOL": [
            "RoadJunction(OxfordCircus) & Connect(OxfordCircus, OxfordSt, RegentSt)\nIn(OxfordSt, London) & In(RegentSt, London)\nDesigned(Nash, Construction) & On(Construction, RegentSt)\nDesigned(Nash, OxfordCircus)\nArchitect(Nash) & British(Nash)\nEntraceTo(OxfordCircus, TubeStation) & PartOf(TubeStation, Centralline) & In(TubeStation, OneNineZeroZero)"
        ],
        "conclusion": "Oxford Circus is designed by a British architect.",
        "conclusion-FOL": "exists x. (British(x) & Architect(x) & Design(x, OxfordCircus))",
        "label": "ERROR"
    },
    {
        "premises": "Oxford Circus is a road junction connecting Oxford Street and Regent Street.\nOxford Street and Regent Street are in London.\nJohn Nash designed a construction on Regent Street.\nJohn Nash designed Oxford Circus.\nJohn Nash is a British architect.\nOxford Circus is the entrance to Oxford Circus tube station, a part of the Central line in 1900.",
        "premises-FOL": [
            "RoadJunction(OxfordCircus) & Connect(OxfordCircus, OxfordSt, RegentSt)\nIn(OxfordSt, London) & In(RegentSt, London)\nDesigned(Nash, Construction) & On(Construction, RegentSt)\nDesigned(Nash, OxfordCircus)\nArchitect(Nash) & British(Nash)\nEntraceTo(OxfordCircus, TubeStation) & PartOf(TubeStation, Centralline) & In(TubeStation, OneNineZeroZero)"
        ],
        "conclusion": "John Nash designed the Central line in 1900.",
        "conclusion-FOL": "all x. (PartOf(x, CentralLine) -> Design(JohnNash, x))",
        "label": "ERROR"
    },
    {
        "premises": "Oxford Circus is a road junction connecting Oxford Street and Regent Street.\nOxford Street and Regent Street are in London.\nJohn Nash designed a construction on Regent Street.\nJohn Nash designed Oxford Circus.\nJohn Nash is a British architect.\nOxford Circus is the entrance to Oxford Circus tube station, a part of the Central line in 1900.",
        "premises-FOL": [
            "RoadJunction(OxfordCircus) & Connect(OxfordCircus, OxfordSt, RegentSt)\nIn(OxfordSt, London) & In(RegentSt, London)\nDesigned(Nash, Construction) & On(Construction, RegentSt)\nDesigned(Nash, OxfordCircus)\nArchitect(Nash) & British(Nash)\nEntraceTo(OxfordCircus, TubeStation) & PartOf(TubeStation, Centralline) & In(TubeStation, OneNineZeroZero)"
        ],
        "conclusion": "Regent Street is not in London.",
        "conclusion-FOL": "-In(RegentStreet, London)",
        "label": "ERROR"
    },
    {
        "premises": "All pets in my house are either cats or dogs.\nAll the dogs in my house bark.\nGhosts do not exist.\nIf some pet in my house barks, then it is not dead.\nAll of the pets in my house are either dead or alive.\nJojo is a pet in my house, and it is not alive.",
        "premises-FOL": [
            "all x. (Pet(x) & In(x, MyHouse) -> ((Cat(x) & -Dog(x)) | (-Cat(x) & Dog(x))))\nall x. (Dog(x) & In(x, MyHouse) -> Bark(x))\nall x. (-Ghost(x))\nall x. (Bark(x) & Pet(x) & In(x, MyHouse) -> -Dead(x))\nall x. (Pet(x) & In(x, MyHouse) -> ((Dead(x) & -Alive(x)) | (-Dead(x) & Alive(x))))\nPet(Jojo) & InMyHouse(Jojo)& -Alive(Jojo)"
        ],
        "conclusion": "Jojo is a ghost.",
        "conclusion-FOL": "Ghost(Jojo)",
        "label": "ERROR"
    },
    {
        "premises": "All pets in my house are either cats or dogs.\nAll the dogs in my house bark.\nGhosts do not exist.\nIf some pet in my house barks, then it is not dead.\nAll of the pets in my house are either dead or alive.\nJojo is a pet in my house, and it is not alive.",
        "premises-FOL": [
            "all x. (Pet(x) & In(x, MyHouse) -> ((Cat(x) & -Dog(x)) | (-Cat(x) & Dog(x))))\nall x. (Dog(x) & In(x, MyHouse) -> Bark(x))\nall x. (-Ghost(x))\nall x. (Bark(x) & Pet(x) & In(x, MyHouse) -> -Dead(x))\nall x. (Pet(x) & In(x, MyHouse) -> ((Dead(x) & -Alive(x)) | (-Dead(x) & Alive(x))))\nPet(Jojo) & InMyHouse(Jojo)& -Alive(Jojo)"
        ],
        "conclusion": "Jojo is a cat or a ghost.",
        "conclusion-FOL": "Cat(Jojo) | Ghost(Jojo)",
        "label": "ERROR"
    },
    {
        "premises": "All pets in my house are either cats or dogs.\nAll the dogs in my house bark.\nGhosts do not exist.\nIf some pet in my house barks, then it is not dead.\nAll of the pets in my house are either dead or alive.\nJojo is a pet in my house, and it is not alive.",
        "premises-FOL": [
            "all x. (Pet(x) & In(x, MyHouse) -> ((Cat(x) & -Dog(x)) | (-Cat(x) & Dog(x))))\nall x. (Dog(x) & In(x, MyHouse) -> Bark(x))\nall x. (-Ghost(x))\nall x. (Bark(x) & Pet(x) & In(x, MyHouse) -> -Dead(x))\nall x. (Pet(x) & In(x, MyHouse) -> ((Dead(x) & -Alive(x)) | (-Dead(x) & Alive(x))))\nPet(Jojo) & InMyHouse(Jojo)& -Alive(Jojo)"
        ],
        "conclusion": "If Jojo is a cat or a ghost, then Jojo either barks or is a dog.",
        "conclusion-FOL": "Cat(Jojo) | Ghost(Jojo) -> ((Bark(Jojo) & -Dog(Jojo)) | (-Bark(Jojo) & Dog(Jojo)))",
        "label": "ERROR"
    },
    {
        "premises": "All tigers are cats.\nNo cats are dogs.\nAll Bengal tigers are tigers.\nAll huskies are dogs.\nFido is either a Bengal tiger or a cat.",
        "premises-FOL": [
            "all x. (Tiger(x) -> Cat(x))\nall x. (Cat(x) -> -Dog(x))\nall x. (BengalTiger(x) -> Tiger(x))\nall x. (Husky(x) -> Dog(x))\n((BengalTiger(Fido) & -Cat(Fido)) | (-BengalTiger(Fido) & Cat(Fido)))"
        ],
        "conclusion": "Fido is a husky animal.",
        "conclusion-FOL": "Husky(Fido)",
        "label": "ERROR"
    },
    {
        "premises": "All tigers are cats.\nNo cats are dogs.\nAll Bengal tigers are tigers.\nAll huskies are dogs.\nFido is either a Bengal tiger or a cat.",
        "premises-FOL": [
            "all x. (Tiger(x) -> Cat(x))\nall x. (Cat(x) -> -Dog(x))\nall x. (BengalTiger(x) -> Tiger(x))\nall x. (Husky(x) -> Dog(x))\n((BengalTiger(Fido) & -Cat(Fido)) | (-BengalTiger(Fido) & Cat(Fido)))"
        ],
        "conclusion": "Fido is not a husky.",
        "conclusion-FOL": "-Husky(Fido)",
        "label": "ERROR"
    },
    {
        "premises": "All tigers are cats.\nNo cats are dogs.\nAll Bengal tigers are tigers.\nAll huskies are dogs.\nFido is either a Bengal tiger or a cat.",
        "premises-FOL": [
            "all x. (Tiger(x) -> Cat(x))\nall x. (Cat(x) -> -Dog(x))\nall x. (BengalTiger(x) -> Tiger(x))\nall x. (Husky(x) -> Dog(x))\n((BengalTiger(Fido) & -Cat(Fido)) | (-BengalTiger(Fido) & Cat(Fido)))"
        ],
        "conclusion": "Fido is a Bengal tiger.",
        "conclusion-FOL": "BengalTiger(Fido)",
        "label": "ERROR"
    },
    {
        "premises": "All tigers are cats.\nNo cats are dogs.\nAll Bengal tigers are tigers.\nAll huskies are dogs.\nFido is either a Bengal tiger or a cat.",
        "premises-FOL": [
            "all x. (Tiger(x) -> Cat(x))\nall x. (Cat(x) -> -Dog(x))\nall x. (BengalTiger(x) -> Tiger(x))\nall x. (Husky(x) -> Dog(x))\n((BengalTiger(Fido) & -Cat(Fido)) | (-BengalTiger(Fido) & Cat(Fido)))"
        ],
        "conclusion": "Fido is neither a dog nor a husky.",
        "conclusion-FOL": "-Dog(Fido) & -Husky(Fido)",
        "label": "ERROR"
    },
    {
        "premises": "If a city holds a Summer Olympics, and the city is a US city, then the Summer Olympics will be in the US.\nIf a city is in a state in the US, the city is a US city.\nIf a city is in a state, and a Summer Olympics is in this city, then the Summer Olympics is in this state.\nThe 2028 Summer Olympics is scheduled to take place in Los Angeles.\nLos Angeles is a city in California.\nAtlanta is a US city.\nAtlanta is in Georgia.\nCalifornia is a state in the United States.\nBoxing, modern pentathlon, and weightlifting will be removed from The 2028 Summer Olympics.\nAtlanta in the United States held the 1996 Summer Olympics.",
        "premises-FOL": [
            "all x. all y. ((SummerOlympicsIn(x,y) & In(x, UnitedStates)) -> SummerOlympicsIn(x, UnitedStates))\nall x. all y. ((In(x, y) & In(y, UnitedStates)) -> In(x, UnitedStates))\nall x. all y. all z. ((In(x, z) & State(z) & SummerOlympicsIn(x,y)) -> SummerOlympicsIn(z, y))\nSummerOlympicsIn(LosAngeles, YrTwoZeroTwoEight)\nIn(LosAngeles, California)\nIn(Atlanta, UnitedStates)\nIn(California, UnitedStates)\nIn(Atlanta, Georgia)\n-InSummerOlympicsIn(Boxing, YrTwoZeroTwoEight) & (-InSummerOlympicsIn(Modern_pentathlon, YrTwoZeroTwoEight)) & (-InSummerOlympicsIn(Weightlifting, YrTwoZeroTwoEight))\nSummerOlympicsIn(Atlanta, YrOneNineNineSix)"
        ],
        "conclusion": "The 2028 Summer Olympics will take place in the US.",
        "conclusion-FOL": "SummerOlympicsIn(UnitedStates, YrTwoZeroTwoEight)",
        "label": "ERROR"
    },
    {
        "premises": "If a city holds a Summer Olympics, and the city is a US city, then the Summer Olympics will be in the US.\nIf a city is in a state in the US, the city is a US city.\nIf a city is in a state, and a Summer Olympics is in this city, then the Summer Olympics is in this state.\nThe 2028 Summer Olympics is scheduled to take place in Los Angeles.\nLos Angeles is a city in California.\nAtlanta is a US city.\nAtlanta is in Georgia.\nCalifornia is a state in the United States.\nBoxing, modern pentathlon, and weightlifting will be removed from The 2028 Summer Olympics.\nAtlanta in the United States held the 1996 Summer Olympics.",
        "premises-FOL": [
            "all x. all y. ((SummerOlympicsIn(x,y) & In(x, UnitedStates)) -> SummerOlympicsIn(x, UnitedStates))\nall x. all y. ((In(x, y) & In(y, UnitedStates)) -> In(x, UnitedStates))\nall x. all y. all z. ((In(x, z) & State(z) & SummerOlympicsIn(x,y)) -> SummerOlympicsIn(z, y))\nSummerOlympicsIn(LosAngeles, YrTwoZeroTwoEight)\nIn(LosAngeles, California)\nIn(Atlanta, UnitedStates)\nIn(California, UnitedStates)\nIn(Atlanta, Georgia)\n-InSummerOlympicsIn(Boxing, YrTwoZeroTwoEight) & (-InSummerOlympicsIn(Modern_pentathlon, YrTwoZeroTwoEight)) & (-InSummerOlympicsIn(Weightlifting, YrTwoZeroTwoEight))\nSummerOlympicsIn(Atlanta, YrOneNineNineSix)"
        ],
        "conclusion": "The 1996 Summer Olympics is not in Georgia.",
        "conclusion-FOL": "-SummerOlympicsIn(Georgia, YrOneNineNineSix)",
        "label": "ERROR"
    },
    {
        "premises": "If a city holds a Summer Olympics, and the city is a US city, then the Summer Olympics will be in the US.\nIf a city is in a state in the US, the city is a US city.\nIf a city is in a state, and a Summer Olympics is in this city, then the Summer Olympics is in this state.\nThe 2028 Summer Olympics is scheduled to take place in Los Angeles.\nLos Angeles is a city in California.\nAtlanta is a US city.\nAtlanta is in Georgia.\nCalifornia is a state in the United States.\nBoxing, modern pentathlon, and weightlifting will be removed from The 2028 Summer Olympics.\nAtlanta in the United States held the 1996 Summer Olympics.",
        "premises-FOL": [
            "all x. all y. ((SummerOlympicsIn(x,y) & In(x, UnitedStates)) -> SummerOlympicsIn(x, UnitedStates))\nall x. all y. ((In(x, y) & In(y, UnitedStates)) -> In(x, UnitedStates))\nall x. all y. all z. ((In(x, z) & State(z) & SummerOlympicsIn(x,y)) -> SummerOlympicsIn(z, y))\nSummerOlympicsIn(LosAngeles, YrTwoZeroTwoEight)\nIn(LosAngeles, California)\nIn(Atlanta, UnitedStates)\nIn(California, UnitedStates)\nIn(Atlanta, Georgia)\n-InSummerOlympicsIn(Boxing, YrTwoZeroTwoEight) & (-InSummerOlympicsIn(Modern_pentathlon, YrTwoZeroTwoEight)) & (-InSummerOlympicsIn(Weightlifting, YrTwoZeroTwoEight))\nSummerOlympicsIn(Atlanta, YrOneNineNineSix)"
        ],
        "conclusion": "Skateboarding will appear at The 2028 Summer Olympics.",
        "conclusion-FOL": "InSummerOlympicsIn(Skateboarding, YrTwoZeroTwoEight)",
        "label": "ERROR"
    },
    {
        "premises": "The taiga vole is a large vole found in northwestern North America. \nCats like playing with all voles.\nThe taiga vole lives in the boreal taiga zone.\nThe boreal taiga zone in North America is a cold place to live in.",
        "premises-FOL": [
            "Vole(TaigaVole) & LiveIn(TaigaVole, NorthAmerica)\nLikePlayingWith(Cat, TaigaVole)\nLiveIn(TaigaVole, BorealTaigaZone)\nall x. ((LiveIn(x, NorthAmerica) & LiveIn(x, BorealTaigaZone)) -> LiveIn(x, ColdPlace))"
        ],
        "conclusion": "Cats like playing with taiga vole.",
        "conclusion-FOL": "LikePlayingWith(Cat, TaigaVole)",
        "label": "ERROR"
    },
    {
        "premises": "The taiga vole is a large vole found in northwestern North America. \nCats like playing with all voles.\nThe taiga vole lives in the boreal taiga zone.\nThe boreal taiga zone in North America is a cold place to live in.",
        "premises-FOL": [
            "Vole(TaigaVole) & LiveIn(TaigaVole, NorthAmerica)\nLikePlayingWith(Cat, TaigaVole)\nLiveIn(TaigaVole, BorealTaigaZone)\nall x. ((LiveIn(x, NorthAmerica) & LiveIn(x, BorealTaigaZone)) -> LiveIn(x, ColdPlace))"
        ],
        "conclusion": "Taiga vole's living place is not cold.",
        "conclusion-FOL": "-LiveIn(TaigaVole, ColdPlace)",
        "label": "ERROR"
    },
    {
        "premises": "A diseases affect females or males.\nNo women have prostate cancer.\nA cancer is either prostate cancer or non-prostate cancer. \nNo type of cancer is without mutations.\nAll non-prostate cancers are a type of cancer.\nIf adenocarcinoma is a type of cancer or without mutations or both, then adenocarcinoma is in women or without mutations or both.",
        "premises-FOL": [
            "all x. (Disease(x) -> (Affects(x, Female) | Affects(x, Male)) )\nall x. (Affect(x, Female) -> -ProstateCancer(x))\nall x. (ProstateCancer(x) | NonProstateCancer(x)) \nall x. (Cancer(x) -> -Without(x, Mutation)) \nall x. (NonProstateCancer(x) -> Cancer(x)) \n(Cancer(Adenocarcinoma) | Without(Adenocarcinoma, Mutation)) -> (Affect(Adenocarcinoma, Female) | Without(Adenocarcinoma, Mutation))"
        ],
        "conclusion": "Adenocarcinoma is a prostate cancer.",
        "conclusion-FOL": "ProstateCancer(Adenocarcinoma)",
        "label": "ERROR"
    },
    {
        "premises": "A diseases affect females or males.\nNo women have prostate cancer.\nA cancer is either prostate cancer or non-prostate cancer. \nNo type of cancer is without mutations.\nAll non-prostate cancers are a type of cancer.\nIf adenocarcinoma is a type of cancer or without mutations or both, then adenocarcinoma is in women or without mutations or both.",
        "premises-FOL": [
            "all x. (Disease(x) -> (Affects(x, Female) | Affects(x, Male)) )\nall x. (Affect(x, Female) -> -ProstateCancer(x))\nall x. (ProstateCancer(x) | NonProstateCancer(x)) \nall x. (Cancer(x) -> -Without(x, Mutation)) \nall x. (NonProstateCancer(x) -> Cancer(x)) \n(Cancer(Adenocarcinoma) | Without(Adenocarcinoma, Mutation)) -> (Affect(Adenocarcinoma, Female) | Without(Adenocarcinoma, Mutation))"
        ],
        "conclusion": "Adenocarcinoma is a disease in women.",
        "conclusion-FOL": "Affect(Adenocarcinoma, Men)",
        "label": "ERROR"
    },
    {
        "premises": "A diseases affect females or males.\nNo women have prostate cancer.\nA cancer is either prostate cancer or non-prostate cancer. \nNo type of cancer is without mutations.\nAll non-prostate cancers are a type of cancer.\nIf adenocarcinoma is a type of cancer or without mutations or both, then adenocarcinoma is in women or without mutations or both.",
        "premises-FOL": [
            "all x. (Disease(x) -> (Affects(x, Female) | Affects(x, Male)) )\nall x. (Affect(x, Female) -> -ProstateCancer(x))\nall x. (ProstateCancer(x) | NonProstateCancer(x)) \nall x. (Cancer(x) -> -Without(x, Mutation)) \nall x. (NonProstateCancer(x) -> Cancer(x)) \n(Cancer(Adenocarcinoma) | Without(Adenocarcinoma, Mutation)) -> (Affect(Adenocarcinoma, Female) | Without(Adenocarcinoma, Mutation))"
        ],
        "conclusion": "If adenocarcinoma is a disease in women or without mutations, then adenocarcinoma is without mutations and a non-prostate cancer.",
        "conclusion-FOL": "(Affect(Adenocarcinoma, Men) | Without(Adenocarcinoma, Mutation)) -> (NonProstateCancer(Adenocarcinoma) & Without(Adenocarcinoma, Mutation))",
        "label": "ERROR"
    },
    {
        "premises": "Some monitors equipped in the lab are produced by the company named AOC. \nAll monitors equipped in the lab are cheaper than their original prices. \nIf a monitor is cheaper than its original price, then its resolution is 1080p. \nIf a monitor has a resolution of 1080p, then it does not support the type-c port. \nLG34 is equipped in the lab.  ",
        "premises-FOL": [
            "exists x. exists y.  (LabMonitor(x) & AOC(x) & (-(x=y)) & LabMonitor(y) & AOC(y))\nall x. (LabMonitor(x) -> Discounted(x))\nall x. (Discounted(x) -> AOneZeroEightZerop(x))\nall x. (AOneZeroEightZerop(x) -> -TypeC(x))\nLabMonitor(Lg-ThreeFour)"
        ],
        "conclusion": "LG34 machine is produced by AOC.",
        "conclusion-FOL": "AOC(Lg-ThreeFour)",
        "label": "ERROR"
    },
    {
        "premises": "Some monitors equipped in the lab are produced by the company named AOC. \nAll monitors equipped in the lab are cheaper than their original prices. \nIf a monitor is cheaper than its original price, then its resolution is 1080p. \nIf a monitor has a resolution of 1080p, then it does not support the type-c port. \nLG34 is equipped in the lab.  ",
        "premises-FOL": [
            "exists x. exists y.  (LabMonitor(x) & AOC(x) & (-(x=y)) & LabMonitor(y) & AOC(y))\nall x. (LabMonitor(x) -> Discounted(x))\nall x. (Discounted(x) -> AOneZeroEightZerop(x))\nall x. (AOneZeroEightZerop(x) -> -TypeC(x))\nLabMonitor(Lg-ThreeFour)"
        ],
        "conclusion": "LG34 machine does not support the type-c port.",
        "conclusion-FOL": "-TypeC(Lg-ThreeFour)",
        "label": "ERROR"
    },
    {
        "premises": "Some monitors equipped in the lab are produced by the company named AOC. \nAll monitors equipped in the lab are cheaper than their original prices. \nIf a monitor is cheaper than its original price, then its resolution is 1080p. \nIf a monitor has a resolution of 1080p, then it does not support the type-c port. \nLG34 is equipped in the lab.  ",
        "premises-FOL": [
            "exists x. exists y.  (LabMonitor(x) & AOC(x) & (-(x=y)) & LabMonitor(y) & AOC(y))\nall x. (LabMonitor(x) -> Discounted(x))\nall x. (Discounted(x) -> AOneZeroEightZerop(x))\nall x. (AOneZeroEightZerop(x) -> -TypeC(x))\nLabMonitor(Lg-ThreeFour)"
        ],
        "conclusion": "LG34 is not with a resolution of 1080p.",
        "conclusion-FOL": "-AOneZeroEightZerop(Lg-ThreeFour)",
        "label": "ERROR"
    },
    {
        "premises": "All fruits sold at Nica's market are shipped from Colombia. \nSome fruits sold in New Haven are shipped from Mexico.\nNo fruits shipped from Colombia are sold at the local farmers market in New Haven. \nAvocados are a kind of fruit sold at the local farmers market in New Haven or at Nica's market. \nAvocados are either shipped from Colombia and sold in New Haven, or neither.",
        "premises-FOL": [
            "all x. ((Fruit(x) & SoldAt(x, NicasMarket)) -> ShippedFrom(x, Colombia))\nexists x. exists y. (Fruit(x) & SoldIn(x, NewHaven) & ShippedFrom(x, Mexico) & (-(x=y)) & Fruit(y) & SoldIn(y, NewHaven) & ShippedFrom(y, Mexico))\nall x. ((Fruit(x) & ShippedFrom(x, Colombia)) -> -(SoldAt(x, LocalFarmersMarket)))\nFruit(Avocado) & (SoldAt(Avocado, LocalFarmersMarket) | SoldAt(Avocado, Nica'sMarket))\n-(((ShippedFrom(Avocado, Colombia) & -SoldIn(Avocado, NewHaven)) | (-ShippedFrom(Avocado, Colombia) & SoldIn(Avocado, NewHaven))))"
        ],
        "conclusion": "Avocados are a kind of fruit sold at the local farmers market in New Haven.",
        "conclusion-FOL": "Fruit(Avocado) & SoldAt(Avocado, LocalFarmersMarket)",
        "label": "ERROR"
    },
    {
        "premises": "All fruits sold at Nica's market are shipped from Colombia. \nSome fruits sold in New Haven are shipped from Mexico.\nNo fruits shipped from Colombia are sold at the local farmers market in New Haven. \nAvocados are a kind of fruit sold at the local farmers market in New Haven or at Nica's market. \nAvocados are either shipped from Colombia and sold in New Haven, or neither.",
        "premises-FOL": [
            "all x. ((Fruit(x) & SoldAt(x, NicasMarket)) -> ShippedFrom(x, Colombia))\nexists x. exists y. (Fruit(x) & SoldIn(x, NewHaven) & ShippedFrom(x, Mexico) & (-(x=y)) & Fruit(y) & SoldIn(y, NewHaven) & ShippedFrom(y, Mexico))\nall x. ((Fruit(x) & ShippedFrom(x, Colombia)) -> -(SoldAt(x, LocalFarmersMarket)))\nFruit(Avocado) & (SoldAt(Avocado, LocalFarmersMarket) | SoldAt(Avocado, Nica'sMarket))\n-(((ShippedFrom(Avocado, Colombia) & -SoldIn(Avocado, NewHaven)) | (-ShippedFrom(Avocado, Colombia) & SoldIn(Avocado, NewHaven))))"
        ],
        "conclusion": "Avocados are either sold at the local farmers market in New Haven or are sold in New Haven.",
        "conclusion-FOL": "((SoldAt(Avocado, LocalFarmersMarket) & -SoldIn(Avocado, NewHaven)) | (-SoldAt(Avocado, LocalFarmersMarket) & SoldIn(Avocado, NewHaven)))",
        "label": "ERROR"
    },
    {
        "premises": "All fruits sold at Nica's market are shipped from Colombia. \nSome fruits sold in New Haven are shipped from Mexico.\nNo fruits shipped from Colombia are sold at the local farmers market in New Haven. \nAvocados are a kind of fruit sold at the local farmers market in New Haven or at Nica's market. \nAvocados are either shipped from Colombia and sold in New Haven, or neither.",
        "premises-FOL": [
            "all x. ((Fruit(x) & SoldAt(x, NicasMarket)) -> ShippedFrom(x, Colombia))\nexists x. exists y. (Fruit(x) & SoldIn(x, NewHaven) & ShippedFrom(x, Mexico) & (-(x=y)) & Fruit(y) & SoldIn(y, NewHaven) & ShippedFrom(y, Mexico))\nall x. ((Fruit(x) & ShippedFrom(x, Colombia)) -> -(SoldAt(x, LocalFarmersMarket)))\nFruit(Avocado) & (SoldAt(Avocado, LocalFarmersMarket) | SoldAt(Avocado, Nica'sMarket))\n-(((ShippedFrom(Avocado, Colombia) & -SoldIn(Avocado, NewHaven)) | (-ShippedFrom(Avocado, Colombia) & SoldIn(Avocado, NewHaven))))"
        ],
        "conclusion": "Avocados are either sold in New Haven or sold at Nica's market.",
        "conclusion-FOL": "((SoldIn(Avocado, NewHaven) & -SoldAt(x, Nica'sMarket)) | (-SoldIn(Avocado, NewHaven) & SoldAt(x, Nica'sMarket)))",
        "label": "ERROR"
    },
    {
        "premises": "All fruits sold at Nica's market are shipped from Colombia. \nSome fruits sold in New Haven are shipped from Mexico.\nNo fruits shipped from Colombia are sold at the local farmers market in New Haven. \nAvocados are a kind of fruit sold at the local farmers market in New Haven or at Nica's market. \nAvocados are either shipped from Colombia and sold in New Haven, or neither.",
        "premises-FOL": [
            "all x. ((Fruit(x) & SoldAt(x, NicasMarket)) -> ShippedFrom(x, Colombia))\nexists x. exists y. (Fruit(x) & SoldIn(x, NewHaven) & ShippedFrom(x, Mexico) & (-(x=y)) & Fruit(y) & SoldIn(y, NewHaven) & ShippedFrom(y, Mexico))\nall x. ((Fruit(x) & ShippedFrom(x, Colombia)) -> -(SoldAt(x, LocalFarmersMarket)))\nFruit(Avocado) & (SoldAt(Avocado, LocalFarmersMarket) | SoldAt(Avocado, Nica'sMarket))\n-(((ShippedFrom(Avocado, Colombia) & -SoldIn(Avocado, NewHaven)) | (-ShippedFrom(Avocado, Colombia) & SoldIn(Avocado, NewHaven))))"
        ],
        "conclusion": "If avocados are not both sold at the local farmers market in New Haven and shipped from Columbia, then they are neither sold at the local farmers market in New Haven nor in New Haven generally.",
        "conclusion-FOL": "-(SoldAt(Avocado, LocalFarmersMarket) & ShippedFrom(Avocado, Colombia)) -> -SoldAt(Avocado, LocalFarmersMarket) & -SoldIn(Avocado, NewHaven)",
        "label": "ERROR"
    },
    {
        "premises": "Some monitors equipped in the library are produced by AOC. \nAll monitors equipped in the library are cheaper than 800 dollars. \nAll monitors cheaper than 800 dollars are with a resolution lower than 1080p. \nIf a monitor has a resolution lower than 1080p, then it does not support the type-c port. \nA-2017 supports the type-c port. ",
        "premises-FOL": [
            "exists x. exists y.(Monitor(x) & ProducedBy(x, aOC) & In(x, Library) & (-(x=y)) & Monitor(y) & ProducedBy(y, aOC) & In(y, Library))\nall x. ((Monitor(x) & In(x, Library)) -> CheaperThan(x, DollarsEightZeroZero))\nall x. ((Monitor(x) & CheaperThan(x, DollarsEightZeroZero)) -> ResolutionLessThan(x, pOneZeroEightZero))\nall x. ((Monitor(x) & ResolutionLessThan(x, pOneZeroEightZero)) -> -Supports(x, Type-CPort))\nSupports(a-TwoZeroOneSeven, Type-CPort)"
        ],
        "conclusion": "A-2017 is produced by AOC.",
        "conclusion-FOL": "ProducedBy(x, aOC)",
        "label": "ERROR"
    },
    {
        "premises": "Some monitors equipped in the library are produced by AOC. \nAll monitors equipped in the library are cheaper than 800 dollars. \nAll monitors cheaper than 800 dollars are with a resolution lower than 1080p. \nIf a monitor has a resolution lower than 1080p, then it does not support the type-c port. \nA-2017 supports the type-c port. ",
        "premises-FOL": [
            "exists x. exists y.(Monitor(x) & ProducedBy(x, aOC) & In(x, Library) & (-(x=y)) & Monitor(y) & ProducedBy(y, aOC) & In(y, Library))\nall x. ((Monitor(x) & In(x, Library)) -> CheaperThan(x, DollarsEightZeroZero))\nall x. ((Monitor(x) & CheaperThan(x, DollarsEightZeroZero)) -> ResolutionLessThan(x, pOneZeroEightZero))\nall x. ((Monitor(x) & ResolutionLessThan(x, pOneZeroEightZero)) -> -Supports(x, Type-CPort))\nSupports(a-TwoZeroOneSeven, Type-CPort)"
        ],
        "conclusion": "A-2017 is produced by AOC and equipped in the library.",
        "conclusion-FOL": "ProducedBy(a-TwoZeroOneSeven, aOC) & In(a-TwoZeroOneSeven, Library)",
        "label": "ERROR"
    },
    {
        "premises": "Some monitors equipped in the library are produced by AOC. \nAll monitors equipped in the library are cheaper than 800 dollars. \nAll monitors cheaper than 800 dollars are with a resolution lower than 1080p. \nIf a monitor has a resolution lower than 1080p, then it does not support the type-c port. \nA-2017 supports the type-c port. ",
        "premises-FOL": [
            "exists x. exists y.(Monitor(x) & ProducedBy(x, aOC) & In(x, Library) & (-(x=y)) & Monitor(y) & ProducedBy(y, aOC) & In(y, Library))\nall x. ((Monitor(x) & In(x, Library)) -> CheaperThan(x, DollarsEightZeroZero))\nall x. ((Monitor(x) & CheaperThan(x, DollarsEightZeroZero)) -> ResolutionLessThan(x, pOneZeroEightZero))\nall x. ((Monitor(x) & ResolutionLessThan(x, pOneZeroEightZero)) -> -Supports(x, Type-CPort))\nSupports(a-TwoZeroOneSeven, Type-CPort)"
        ],
        "conclusion": "If either A-2017 is both with a resolution of 1080p and produced by AOC or it is neither, then it is not equipped in the library.",
        "conclusion-FOL": "-(((ResolutionLessThan(a-TwoZeroOneSeven, pOneZeroEightZero) & -ProducedBy(x, aOC)) | (-ResolutionLessThan(a-TwoZeroOneSeven, pOneZeroEightZero) & ProducedBy(x, aOC)))) -> -(In(a-TwoZeroOneSeven, Library))",
        "label": "ERROR"
    },
    {
        "premises": "S\u016bduva Marijampol\u0117 holds the Lithuanian Super Cup.\nS\u016bduva Marijampol\u0117 is a soccer team.",
        "premises-FOL": [
            "Holds(Suduva, TheLithuanianSuperCup)\nSoccerTeam(Suduva)"
        ],
        "conclusion": "Some soccer team holds the Lithuanian Super Cup.",
        "conclusion-FOL": "exists x. (SoccerTeam(x) & Holds(x, TheLithuanianSuperCup))",
        "label": "ERROR"
    },
    {
        "premises": "Ainderby Quernhow is a village and civil parish in the Hambleton District.\nHambleton District is in North Yorkshire.\nNorth Yorkshire is in England.\nIf place A is located in place B and place B is located in place C, then place A is located in place C.",
        "premises-FOL": [
            "Village(AinderbyQuernhow) & CivilParish(AinderbyQuernhow) & In(AinderbyQuernhow, HambletonDistrict)\nIn(HambletonDistrict, NorthYorkshire)\nIn(NorthYorkshire, England)\nall x. all y. all z. ((In(x, y) & In(y, z)) -> In(x, z))"
        ],
        "conclusion": "There is a village in England.",
        "conclusion-FOL": "exists x. (Village(x) & In(x, England))",
        "label": "ERROR"
    },
    {
        "premises": "Ainderby Quernhow is a village and civil parish in the Hambleton District.\nHambleton District is in North Yorkshire.\nNorth Yorkshire is in England.\nIf place A is located in place B and place B is located in place C, then place A is located in place C.",
        "premises-FOL": [
            "Village(AinderbyQuernhow) & CivilParish(AinderbyQuernhow) & In(AinderbyQuernhow, HambletonDistrict)\nIn(HambletonDistrict, NorthYorkshire)\nIn(NorthYorkshire, England)\nall x. all y. all z. ((In(x, y) & In(y, z)) -> In(x, z))"
        ],
        "conclusion": "There is no civil parish in England.",
        "conclusion-FOL": "-(exists x. (CivilParish(x) & In(x, England)))",
        "label": "ERROR"
    },
    {
        "premises": "Douglas Adams is an author who created the book collection called The Salmon of Doubt. \nThe Salmon of Doubt is about life experiences and technology.\nAll authors are writers.\nWriters create innovative ideas.\nSome books that contain innovative ideas are about technology.",
        "premises-FOL": [
            "Author(DouglasAdams) & Authored(DouglasAdams, TheSalmonOfDoubt) & Book(TheSalmonOfDoubt)\nAbout(TheSalmonOfDoubt, LifeExperience) & About(TheSalmonOfDoubt, Technology)\nall x. (Author(x) -> Writer(x))\nall x. (Writer(x) -> Create(x, InnovativeIdea))\nexists x. exists y. (Contain(x, InnovativeIdea) & About(x, Technology) & (-(x=y)) & (Contain(y, InnovativeIdea) & About(y, Technology)))"
        ],
        "conclusion": "Douglas Adams is a writer.",
        "conclusion-FOL": "Writer(DouglasAdams)",
        "label": "ERROR"
    },
    {
        "premises": "Douglas Adams is an author who created the book collection called The Salmon of Doubt. \nThe Salmon of Doubt is about life experiences and technology.\nAll authors are writers.\nWriters create innovative ideas.\nSome books that contain innovative ideas are about technology.",
        "premises-FOL": [
            "Author(DouglasAdams) & Authored(DouglasAdams, TheSalmonOfDoubt) & Book(TheSalmonOfDoubt)\nAbout(TheSalmonOfDoubt, LifeExperience) & About(TheSalmonOfDoubt, Technology)\nall x. (Author(x) -> Writer(x))\nall x. (Writer(x) -> Create(x, InnovativeIdea))\nexists x. exists y. (Contain(x, InnovativeIdea) & About(x, Technology) & (-(x=y)) & (Contain(y, InnovativeIdea) & About(y, Technology)))"
        ],
        "conclusion": "Douglas Adams created innovative ideas.",
        "conclusion-FOL": "Create(DouglasAdams, InnovativeIdea)",
        "label": "ERROR"
    },
    {
        "premises": "Douglas Adams is an author who created the book collection called The Salmon of Doubt. \nThe Salmon of Doubt is about life experiences and technology.\nAll authors are writers.\nWriters create innovative ideas.\nSome books that contain innovative ideas are about technology.",
        "premises-FOL": [
            "Author(DouglasAdams) & Authored(DouglasAdams, TheSalmonOfDoubt) & Book(TheSalmonOfDoubt)\nAbout(TheSalmonOfDoubt, LifeExperience) & About(TheSalmonOfDoubt, Technology)\nall x. (Author(x) -> Writer(x))\nall x. (Writer(x) -> Create(x, InnovativeIdea))\nexists x. exists y. (Contain(x, InnovativeIdea) & About(x, Technology) & (-(x=y)) & (Contain(y, InnovativeIdea) & About(y, Technology)))"
        ],
        "conclusion": "The Salmon of Doubt has no innovative Ideas.",
        "conclusion-FOL": "-Contain(TheSalmonOfDoubt, InnovativeIdea)",
        "label": "ERROR"
    },
    {
        "premises": "No disposable products can help slow down global warming. \nAll eco-friendly brands can help slow down global warming. \nAll sustainable fashion brands are eco-friendly brands.\nAll fast fashion products are disposable products.\nIf Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.",
        "premises-FOL": [
            "all x. (Disposable(x) & Product(x) -> -HelpSlowDown(x, GlobalWarming))\nall x. (EcoFriendly(x) & Brand(x) -> Help(x, SlowDownGlobalWarming))\nall x. (Sustainable(x) & FashionBrand(x) -> EcoFriendly(x) & Brand(x))\nall x. (FastFashion(x) & Product(x) -> Disposable(x) & Product(x)) \n-HelpSlowDown(Reformation, GlobalWarming) -> (EcoFriendly(Reformation) & Brand(Reformation)) | (Sustainable(Reformation) & FashionBrand(Reformation))"
        ],
        "conclusion": "Reformation is an eco-friendly brand.",
        "conclusion-FOL": "EcoFriendly(Reformation) & Brand(Reformation)",
        "label": "ERROR"
    },
    {
        "premises": "No disposable products can help slow down global warming. \nAll eco-friendly brands can help slow down global warming. \nAll sustainable fashion brands are eco-friendly brands.\nAll fast fashion products are disposable products.\nIf Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.",
        "premises-FOL": [
            "all x. (Disposable(x) & Product(x) -> -HelpSlowDown(x, GlobalWarming))\nall x. (EcoFriendly(x) & Brand(x) -> Help(x, SlowDownGlobalWarming))\nall x. (Sustainable(x) & FashionBrand(x) -> EcoFriendly(x) & Brand(x))\nall x. (FastFashion(x) & Product(x) -> Disposable(x) & Product(x)) \n-HelpSlowDown(Reformation, GlobalWarming) -> (EcoFriendly(Reformation) & Brand(Reformation)) | (Sustainable(Reformation) & FashionBrand(Reformation))"
        ],
        "conclusion": "Reformation produces fast fashion products.",
        "conclusion-FOL": "FastFashion(Reformation) & Product(Reformation)",
        "label": "ERROR"
    },
    {
        "premises": "No disposable products can help slow down global warming. \nAll eco-friendly brands can help slow down global warming. \nAll sustainable fashion brands are eco-friendly brands.\nAll fast fashion products are disposable products.\nIf Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.",
        "premises-FOL": [
            "all x. (Disposable(x) & Product(x) -> -HelpSlowDown(x, GlobalWarming))\nall x. (EcoFriendly(x) & Brand(x) -> Help(x, SlowDownGlobalWarming))\nall x. (Sustainable(x) & FashionBrand(x) -> EcoFriendly(x) & Brand(x))\nall x. (FastFashion(x) & Product(x) -> Disposable(x) & Product(x)) \n-HelpSlowDown(Reformation, GlobalWarming) -> (EcoFriendly(Reformation) & Brand(Reformation)) | (Sustainable(Reformation) & FashionBrand(Reformation))"
        ],
        "conclusion": "Reformation does not produce fast fashion products.",
        "conclusion-FOL": "-(FastFashion(Reformation) & Product(Reformation))",
        "label": "ERROR"
    },
    {
        "premises": "No disposable products can help slow down global warming. \nAll eco-friendly brands can help slow down global warming. \nAll sustainable fashion brands are eco-friendly brands.\nAll fast fashion products are disposable products.\nIf Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.",
        "premises-FOL": [
            "all x. (Disposable(x) & Product(x) -> -HelpSlowDown(x, GlobalWarming))\nall x. (EcoFriendly(x) & Brand(x) -> Help(x, SlowDownGlobalWarming))\nall x. (Sustainable(x) & FashionBrand(x) -> EcoFriendly(x) & Brand(x))\nall x. (FastFashion(x) & Product(x) -> Disposable(x) & Product(x)) \n-HelpSlowDown(Reformation, GlobalWarming) -> (EcoFriendly(Reformation) & Brand(Reformation)) | (Sustainable(Reformation) & FashionBrand(Reformation))"
        ],
        "conclusion": "Reformation does not produce fast fashion products or does not produce disposable products.",
        "conclusion-FOL": "-(FastFashion(Reformation) & Product(Reformation)) | -(Disposable(x) & Product(x))",
        "label": "ERROR"
    },
    {
        "premises": "No disposable products can help slow down global warming. \nAll eco-friendly brands can help slow down global warming. \nAll sustainable fashion brands are eco-friendly brands.\nAll fast fashion products are disposable products.\nIf Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.",
        "premises-FOL": [
            "all x. (Disposable(x) & Product(x) -> -HelpSlowDown(x, GlobalWarming))\nall x. (EcoFriendly(x) & Brand(x) -> Help(x, SlowDownGlobalWarming))\nall x. (Sustainable(x) & FashionBrand(x) -> EcoFriendly(x) & Brand(x))\nall x. (FastFashion(x) & Product(x) -> Disposable(x) & Product(x)) \n-HelpSlowDown(Reformation, GlobalWarming) -> (EcoFriendly(Reformation) & Brand(Reformation)) | (Sustainable(Reformation) & FashionBrand(Reformation))"
        ],
        "conclusion": "If Reformation produces disposable products, then Reformation produces fast fashion products.",
        "conclusion-FOL": "(Disposable(Reformation) & Product(Reformation)) -> (FastFashion(Reformation) & Product(Reformation))",
        "label": "ERROR"
    },
    {
        "premises": "No disposable products can help slow down global warming. \nAll eco-friendly brands can help slow down global warming. \nAll sustainable fashion brands are eco-friendly brands.\nAll fast fashion products are disposable products.\nIf Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.",
        "premises-FOL": [
            "all x. (Disposable(x) & Product(x) -> -HelpSlowDown(x, GlobalWarming))\nall x. (EcoFriendly(x) & Brand(x) -> Help(x, SlowDownGlobalWarming))\nall x. (Sustainable(x) & FashionBrand(x) -> EcoFriendly(x) & Brand(x))\nall x. (FastFashion(x) & Product(x) -> Disposable(x) & Product(x)) \n-HelpSlowDown(Reformation, GlobalWarming) -> (EcoFriendly(Reformation) & Brand(Reformation)) | (Sustainable(Reformation) & FashionBrand(Reformation))"
        ],
        "conclusion": "If Reformation produces fast fashion products or helps slow down global warming, then Reformation produces fast fashion products.",
        "conclusion-FOL": "(FastFashion(Reformation) & Product(Reformation)) | -HelpSlowDown(Reformation, GlobalWarming)",
        "label": "ERROR"
    },
    {
        "premises": "Roy Richardson was a cricketer who played for Sint Maarten, a constituent country.\nRoy Richardson was a right-handed batsman and medium-pace bowler.\nRoy Richardson was old when he debuted in cricket.\nSherville Huggins dismissed Roy Richardson.",
        "premises-FOL": [
            "Cricketeer(RoyRichardson) & PlaysFor(RoyRichardson, SintMaarten) & ConstituentCountry(SintMaarten)\nRightHanded(RoyRichardson) & Batsman(RoyRichardson) & MediumPaceBowler(RoyRichardson)\nOldAtDebut(RoyRichardson)\nDismisses(ShervilleHuggins, RoyRichardson)"
        ],
        "conclusion": "Sherville Huggins has never dismissed anyone playing cricket for a constituent country.",
        "conclusion-FOL": "all x. all y. ((ConsituentCountry(y) & PlayedFor(x, y)) ->  -Dismissed(Shervillehuggins, x))",
        "label": "ERROR"
    },
    {
        "premises": "Roy Richardson was a cricketer who played for Sint Maarten, a constituent country.\nRoy Richardson was a right-handed batsman and medium-pace bowler.\nRoy Richardson was old when he debuted in cricket.\nSherville Huggins dismissed Roy Richardson.",
        "premises-FOL": [
            "Cricketeer(RoyRichardson) & PlaysFor(RoyRichardson, SintMaarten) & ConstituentCountry(SintMaarten)\nRightHanded(RoyRichardson) & Batsman(RoyRichardson) & MediumPaceBowler(RoyRichardson)\nOldAtDebut(RoyRichardson)\nDismisses(ShervilleHuggins, RoyRichardson)"
        ],
        "conclusion": "No right-handed medium-pace bowlers were playing for Sint Maarten.",
        "conclusion-FOL": "all x. ((RightHanded(x) & MediumPaceBowler(x)) -> -PlayedFor(x, SintMaarten))",
        "label": "ERROR"
    },
    {
        "premises": "To get a job at Google, you need to have a lot of work experience or a good education.\nOne needs to submit their resume to Google to get a job there.\nJohn has a lot of work experience.\nJohn submitted his resume to Google and got a job there.",
        "premises-FOL": [
            "all x. (GetAJobAt(x, Google) -> Have(x, aLotOfWorkExperience) | Have(x, GoodEducation))\nall x. (GetAJobAt(x, Google) -> Submitted(x, Resume, Google))\nHave(John, aLotOfWorkExperience)\nSubmitted(John, Resume, Google) & GetAJobAt(John, Google)"
        ],
        "conclusion": "John is a Yale graduate.",
        "conclusion-FOL": "YaleGraduate(John)",
        "label": "ERROR"
    },
    {
        "premises": "No iPhones are standalone desktops. \nAll Apple-made cellphones are iPhones.  \nAll phones with A15 Bionic chips are Apple-made cell phones. \nAll phones equipped with four core-GPU made by Apple are phones with A15 Bionic chips. \nIf an unannounced Huawei phone is either a phone with A15 Bionic chips or equipped with four core-GPU made by Apple, then unannounced Huawei phone is neither a phone with A15 Bionic chips nor a standalone desktop.",
        "premises-FOL": [
            "all x. (IPhone(x) -> -StandaloneDesktop(x))\nall x. (AppleMade(x) & Cellphone(x) -> IPhone(x))\nall x. (Phone(x) & With(x, aOneFiveBionicChip) -> AppleMade(x) & Cellphone(x))\nall x. (Phone(x) & EquippedWith(x, FourCoreGPU) & MadeBy(x, Apple) -> Phone(x) & With(x, aOneFiveBionicChip))\n(((Phone(UnannouncedHuaweiPhone) & With(UnannouncedHuaweiPhone, aOneFiveBionicChip)) & -(Phone(UnannouncedHuaweiPhone) & EquippedWith(UnannouncedHuaweiPhone, FourCoreGPU) & MadeBy(UnannouncedHuaweiPhone, Apple))) | (-(Phone(UnannouncedHuaweiPhone) & With(UnannouncedHuaweiPhone, aOneFiveBionicChip)) & (Phone(UnannouncedHuaweiPhone) & EquippedWith(UnannouncedHuaweiPhone, FourCoreGPU) & MadeBy(UnannouncedHuaweiPhone, Apple)))) -> -(Phone(UnannouncedHuaweiPhone) & With(UnannouncedHuaweiPhone, aOneFiveBionicChip) & StandaloneDesktop(UnannouncedHuaweiPhone))"
        ],
        "conclusion": "Joe is a person taking classes.",
        "conclusion-FOL": "AppleMade(UnannouncedHuaweiPhone) & Cellphone(UnannouncedHuaweiPhone)",
        "label": "ERROR"
    },
    {
        "premises": "No iPhones are standalone desktops. \nAll Apple-made cellphones are iPhones.  \nAll phones with A15 Bionic chips are Apple-made cell phones. \nAll phones equipped with four core-GPU made by Apple are phones with A15 Bionic chips. \nIf an unannounced Huawei phone is either a phone with A15 Bionic chips or equipped with four core-GPU made by Apple, then unannounced Huawei phone is neither a phone with A15 Bionic chips nor a standalone desktop.",
        "premises-FOL": [
            "all x. (IPhone(x) -> -StandaloneDesktop(x))\nall x. (AppleMade(x) & Cellphone(x) -> IPhone(x))\nall x. (Phone(x) & With(x, aOneFiveBionicChip) -> AppleMade(x) & Cellphone(x))\nall x. (Phone(x) & EquippedWith(x, FourCoreGPU) & MadeBy(x, Apple) -> Phone(x) & With(x, aOneFiveBionicChip))\n(((Phone(UnannouncedHuaweiPhone) & With(UnannouncedHuaweiPhone, aOneFiveBionicChip)) & -(Phone(UnannouncedHuaweiPhone) & EquippedWith(UnannouncedHuaweiPhone, FourCoreGPU) & MadeBy(UnannouncedHuaweiPhone, Apple))) | (-(Phone(UnannouncedHuaweiPhone) & With(UnannouncedHuaweiPhone, aOneFiveBionicChip)) & (Phone(UnannouncedHuaweiPhone) & EquippedWith(UnannouncedHuaweiPhone, FourCoreGPU) & MadeBy(UnannouncedHuaweiPhone, Apple)))) -> -(Phone(UnannouncedHuaweiPhone) & With(UnannouncedHuaweiPhone, aOneFiveBionicChip) & StandaloneDesktop(UnannouncedHuaweiPhone))"
        ],
        "conclusion": "Joe is a PhD student.",
        "conclusion-FOL": "Phone(UnannouncedHuaweiPhone) & EquippedWith(UnannouncedHuaweiPhone, FourCoreGPU) & MadeByApple(UnannouncedHuaweiPhone)",
        "label": "ERROR"
    },
    {
        "premises": "No iPhones are standalone desktops. \nAll Apple-made cellphones are iPhones.  \nAll phones with A15 Bionic chips are Apple-made cell phones. \nAll phones equipped with four core-GPU made by Apple are phones with A15 Bionic chips. \nIf an unannounced Huawei phone is either a phone with A15 Bionic chips or equipped with four core-GPU made by Apple, then unannounced Huawei phone is neither a phone with A15 Bionic chips nor a standalone desktop.",
        "premises-FOL": [
            "all x. (IPhone(x) -> -StandaloneDesktop(x))\nall x. (AppleMade(x) & Cellphone(x) -> IPhone(x))\nall x. (Phone(x) & With(x, aOneFiveBionicChip) -> AppleMade(x) & Cellphone(x))\nall x. (Phone(x) & EquippedWith(x, FourCoreGPU) & MadeBy(x, Apple) -> Phone(x) & With(x, aOneFiveBionicChip))\n(((Phone(UnannouncedHuaweiPhone) & With(UnannouncedHuaweiPhone, aOneFiveBionicChip)) & -(Phone(UnannouncedHuaweiPhone) & EquippedWith(UnannouncedHuaweiPhone, FourCoreGPU) & MadeBy(UnannouncedHuaweiPhone, Apple))) | (-(Phone(UnannouncedHuaweiPhone) & With(UnannouncedHuaweiPhone, aOneFiveBionicChip)) & (Phone(UnannouncedHuaweiPhone) & EquippedWith(UnannouncedHuaweiPhone, FourCoreGPU) & MadeBy(UnannouncedHuaweiPhone, Apple)))) -> -(Phone(UnannouncedHuaweiPhone) & With(UnannouncedHuaweiPhone, aOneFiveBionicChip) & StandaloneDesktop(UnannouncedHuaweiPhone))"
        ],
        "conclusion": "Joe is not a PhD student.",
        "conclusion-FOL": "-(Phone(UnannouncedHuaweiPhone) & EquippedWith(UnannouncedHuaweiPhone, FourCoreGPU) & MadeByApple(UnannouncedHuaweiPhone))",
        "label": "ERROR"
    },
    {
        "premises": "Hugh Vanstone is one of the world's leading lighting designers. \nHugh Vanstone is from the UK.\nHugh Vanstone has lit more than 160 productions.\nHugh Vanstone attended a school where he is from. ",
        "premises-FOL": [
            "WorldLeadingLightingDesigner(HughVanstone)\nFrom(HughVanstone, UnitedKingdom)\nexists x.(GreaterThan(x, NumOneSixZero) & LitProductions(HughVanstone,x))\nexists x.(Hometown(HughVanstone,x) & AttendedSchoolIn(HughVanstone,x))"
        ],
        "conclusion": "Hugh Vanstone is one of the world's leading lighting designers and is from the UK.",
        "conclusion-FOL": "WorldLeadingLightingDesigner(HughVanstone) & From(HughVanstone, UnitedKingdom)",
        "label": "ERROR"
    },
    {
        "premises": "Hugh Vanstone is one of the world's leading lighting designers. \nHugh Vanstone is from the UK.\nHugh Vanstone has lit more than 160 productions.\nHugh Vanstone attended a school where he is from. ",
        "premises-FOL": [
            "WorldLeadingLightingDesigner(HughVanstone)\nFrom(HughVanstone, UnitedKingdom)\nexists x.(GreaterThan(x, NumOneSixZero) & LitProductions(HughVanstone,x))\nexists x.(Hometown(HughVanstone,x) & AttendedSchoolIn(HughVanstone,x))"
        ],
        "conclusion": "Hugh Vanstone has lit 170 productions.",
        "conclusion-FOL": "exists x.(GreaterThan(x, NumOneSevenZero) & LitProductions(HughVanstone,x))",
        "label": "ERROR"
    },
    {
        "premises": "Hugh Vanstone is one of the world's leading lighting designers. \nHugh Vanstone is from the UK.\nHugh Vanstone has lit more than 160 productions.\nHugh Vanstone attended a school where he is from. ",
        "premises-FOL": [
            "WorldLeadingLightingDesigner(HughVanstone)\nFrom(HughVanstone, UnitedKingdom)\nexists x.(GreaterThan(x, NumOneSixZero) & LitProductions(HughVanstone,x))\nexists x.(Hometown(HughVanstone,x) & AttendedSchoolIn(HughVanstone,x))"
        ],
        "conclusion": "Hugh Vanstone attended a school in the United States.",
        "conclusion-FOL": "AttendedSchoolIn(HughVanstone, UnitedStates)",
        "label": "ERROR"
    },
    {
        "premises": "No man can run faster than Bolt. \nSuperman is not a man.",
        "premises-FOL": [
            "all x. (Man(x) -> -RunFasterThan(Xm Bolt))\n-Man(Superman)"
        ],
        "conclusion": "Superman can run faster than Bolt.",
        "conclusion-FOL": "RunFasterThan(Superman, Bolt)",
        "label": "ERROR"
    },
    {
        "premises": "Donald Ervin Knuth is an American computer scientist, mathematician, and Professor Emeritus at Stanford University.\nKnuth has been called the \"father of the analysis of algorithms.\"",
        "premises-FOL": [
            "American(DonaldErvinKnuth) & ComputerScientist(DonaldErvinKnuth) & Mathematician(DonaldErvinKnuth) & ProfessorEmeritusAt(DonaldErvinKnuth, Stanford)\nCalled(DonaldErvinKnuth, FatherOfTheAnalysisOfAlgorithms)"
        ],
        "conclusion": "An American scientist has been called the \"father of the analysis of algorithms\".",
        "conclusion-FOL": "exists x. (American(x) & ComputerScientist(x) & Called(x, FatherOfTheAnalysisOfAlgorithms))",
        "label": "ERROR"
    },
    {
        "premises": "Donald Ervin Knuth is an American computer scientist, mathematician, and Professor Emeritus at Stanford University.\nKnuth has been called the \"father of the analysis of algorithms.\"",
        "premises-FOL": [
            "American(DonaldErvinKnuth) & ComputerScientist(DonaldErvinKnuth) & Mathematician(DonaldErvinKnuth) & ProfessorEmeritusAt(DonaldErvinKnuth, Stanford)\nCalled(DonaldErvinKnuth, FatherOfTheAnalysisOfAlgorithms)"
        ],
        "conclusion": "A mathematician has been called the \"father of the analysis of algorithms\".",
        "conclusion-FOL": "exists x. (Mathematician(x) & Called(x, FatherOfTheAnalysisOfAlgorithms))",
        "label": "ERROR"
    },
    {
        "premises": "Donald Ervin Knuth is an American computer scientist, mathematician, and Professor Emeritus at Stanford University.\nKnuth has been called the \"father of the analysis of algorithms.\"",
        "premises-FOL": [
            "American(DonaldErvinKnuth) & ComputerScientist(DonaldErvinKnuth) & Mathematician(DonaldErvinKnuth) & ProfessorEmeritusAt(DonaldErvinKnuth, Stanford)\nCalled(DonaldErvinKnuth, FatherOfTheAnalysisOfAlgorithms)"
        ],
        "conclusion": "Donald Knuth is a well-known figure in the field of artificial intelligence.",
        "conclusion-FOL": "WellKnownFigureIn(DonaldErvinKnuth, ArtificialIntelligence)",
        "label": "ERROR"
    },
    {
        "premises": "Neocrepidodera Corpulentas are flea beetles or moths, or both.\nNeocrepidodera Corpulentas are in the Chrysomelidae family.\nThere are no moths within the Chrysomelidae family.\nThere is a Neocrepidodera Corpulenta. ",
        "premises-FOL": [
            "all x. (NeocrepidoderaCorpulenta(x) -> (FleaBeetle(x) | Moth(x)))\nall x. (NeocrepidoderaCorpulenta(x) -> In(x, ChrysomelidaeFamily))\nall x. (In(x, ChrysomelidaeFamily) -> -Moth(x))\nexists x. (NeocrepidoderaCorpulenta(x))"
        ],
        "conclusion": "There is a flea beetle within the Chrysomelidae family.",
        "conclusion-FOL": "exists x. (FleaBeetle(x) & In(x, ChrysomelidaeFamily))",
        "label": "ERROR"
    },
    {
        "premises": "Neocrepidodera Corpulentas are flea beetles or moths, or both.\nNeocrepidodera Corpulentas are in the Chrysomelidae family.\nThere are no moths within the Chrysomelidae family.\nThere is a Neocrepidodera Corpulenta. ",
        "premises-FOL": [
            "all x. (NeocrepidoderaCorpulenta(x) -> (FleaBeetle(x) | Moth(x)))\nall x. (NeocrepidoderaCorpulenta(x) -> In(x, ChrysomelidaeFamily))\nall x. (In(x, ChrysomelidaeFamily) -> -Moth(x))\nexists x. (NeocrepidoderaCorpulenta(x))"
        ],
        "conclusion": "There are no flea beetles within the Chrysomelidae family.",
        "conclusion-FOL": "all x. (FleaBeetle(x) -> -In(x, ChrysomelidaeFamily))",
        "label": "ERROR"
    },
    {
        "premises": "Carrozzeria Colli is a Milanese coachbuilder company established by Giuseppe Colli in 1931.\nCarrozzeria Colli is a company that specializes in using aluminum.\nThe first automobiles built by Carrozzeria Colli were racing cars.\nSome racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chassis.\nCarrozzeria Colli worked for airforces.\nCarrozzeria Colli made car bodies. ",
        "premises-FOL": [
            "Milanese(CarrozzeriaColli) & CoachBuilder(CarrozzeriaColli) & Company(CarrozzeriaColli) & EstablishedBy(CarrozzeriaColli, GiuseppeColli) & EstablishedIn(CarrozzeriaColli, OneNineThreeOne)\nCompany(CarrozzeriaColli) & SpecializesIn(CarrozzeriaColli, UsingAluminum)\nall x. (BuiltBy(x, CarrozzeriaColli) & FirstAutomobile(x) -> RacingCar(x))\nexists x. (BuiltBy(x, CarrozzeriaColli) & RacingCar(x) & Used(x, FiatOneOneZeroZeromechanicals) & Used(x, Chassis))\nexists x. (Airforce(x) & WorkedFor(CarrozzeriaColli, x))\nexists (CarBody(x) & Made(x, CarrozzeriaColli))"
        ],
        "conclusion": "Carrozzeria Colli made car bodies in 1931.",
        "conclusion-FOL": "exists x. (CarBody(x) & Made(x, CarrozzeriaColli) & MadeIn(x, OneNineThreeOne))",
        "label": "ERROR"
    },
    {
        "premises": "Carrozzeria Colli is a Milanese coachbuilder company established by Giuseppe Colli in 1931.\nCarrozzeria Colli is a company that specializes in using aluminum.\nThe first automobiles built by Carrozzeria Colli were racing cars.\nSome racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chassis.\nCarrozzeria Colli worked for airforces.\nCarrozzeria Colli made car bodies. ",
        "premises-FOL": [
            "Milanese(CarrozzeriaColli) & CoachBuilder(CarrozzeriaColli) & Company(CarrozzeriaColli) & EstablishedBy(CarrozzeriaColli, GiuseppeColli) & EstablishedIn(CarrozzeriaColli, OneNineThreeOne)\nCompany(CarrozzeriaColli) & SpecializesIn(CarrozzeriaColli, UsingAluminum)\nall x. (BuiltBy(x, CarrozzeriaColli) & FirstAutomobile(x) -> RacingCar(x))\nexists x. (BuiltBy(x, CarrozzeriaColli) & RacingCar(x) & Used(x, FiatOneOneZeroZeromechanicals) & Used(x, Chassis))\nexists x. (Airforce(x) & WorkedFor(CarrozzeriaColli, x))\nexists (CarBody(x) & Made(x, CarrozzeriaColli))"
        ],
        "conclusion": "Carrozzeria Colli built airplanes during World War II.",
        "conclusion-FOL": "exists x. (Airplane(x) & Made(x, CarrozzeriaColli) & MadeDuring(x, WorldWarII))",
        "label": "ERROR"
    },
    {
        "premises": "Carrozzeria Colli is a Milanese coachbuilder company established by Giuseppe Colli in 1931.\nCarrozzeria Colli is a company that specializes in using aluminum.\nThe first automobiles built by Carrozzeria Colli were racing cars.\nSome racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chassis.\nCarrozzeria Colli worked for airforces.\nCarrozzeria Colli made car bodies. ",
        "premises-FOL": [
            "Milanese(CarrozzeriaColli) & CoachBuilder(CarrozzeriaColli) & Company(CarrozzeriaColli) & EstablishedBy(CarrozzeriaColli, GiuseppeColli) & EstablishedIn(CarrozzeriaColli, OneNineThreeOne)\nCompany(CarrozzeriaColli) & SpecializesIn(CarrozzeriaColli, UsingAluminum)\nall x. (BuiltBy(x, CarrozzeriaColli) & FirstAutomobile(x) -> RacingCar(x))\nexists x. (BuiltBy(x, CarrozzeriaColli) & RacingCar(x) & Used(x, FiatOneOneZeroZeromechanicals) & Used(x, Chassis))\nexists x. (Airforce(x) & WorkedFor(CarrozzeriaColli, x))\nexists (CarBody(x) & Made(x, CarrozzeriaColli))"
        ],
        "conclusion": "Giuseppe Colli established a company that made car bodies.",
        "conclusion-FOL": "exists x. exists y. (Company(x) & EstablishedBy(x, GiuseppeColli) & CarBody(y) & Made(y, x))",
        "label": "ERROR"
    },
    {
        "premises": "Carrozzeria Colli is a Milanese coachbuilder company established by Giuseppe Colli in 1931.\nCarrozzeria Colli is a company that specializes in using aluminum.\nThe first automobiles built by Carrozzeria Colli were racing cars.\nSome racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chassis.\nCarrozzeria Colli worked for airforces.\nCarrozzeria Colli made car bodies. ",
        "premises-FOL": [
            "Milanese(CarrozzeriaColli) & CoachBuilder(CarrozzeriaColli) & Company(CarrozzeriaColli) & EstablishedBy(CarrozzeriaColli, GiuseppeColli) & EstablishedIn(CarrozzeriaColli, OneNineThreeOne)\nCompany(CarrozzeriaColli) & SpecializesIn(CarrozzeriaColli, UsingAluminum)\nall x. (BuiltBy(x, CarrozzeriaColli) & FirstAutomobile(x) -> RacingCar(x))\nexists x. (BuiltBy(x, CarrozzeriaColli) & RacingCar(x) & Used(x, FiatOneOneZeroZeromechanicals) & Used(x, Chassis))\nexists x. (Airforce(x) & WorkedFor(CarrozzeriaColli, x))\nexists (CarBody(x) & Made(x, CarrozzeriaColli))"
        ],
        "conclusion": "Giuseppe Colli established a Milanese coachbuilder company that specialized in using aluminum.",
        "conclusion-FOL": "exists x. (Milanese(x) & CoachBuilder(x) & Company(x) & EstablishedBy(x, GiuseppeColli) & SpecializesIn(x, UsingAluminum))",
        "label": "ERROR"
    },
    {
        "premises": "Carrozzeria Colli is a Milanese coachbuilder company established by Giuseppe Colli in 1931.\nCarrozzeria Colli is a company that specializes in using aluminum.\nThe first automobiles built by Carrozzeria Colli were racing cars.\nSome racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chassis.\nCarrozzeria Colli worked for airforces.\nCarrozzeria Colli made car bodies. ",
        "premises-FOL": [
            "Milanese(CarrozzeriaColli) & CoachBuilder(CarrozzeriaColli) & Company(CarrozzeriaColli) & EstablishedBy(CarrozzeriaColli, GiuseppeColli) & EstablishedIn(CarrozzeriaColli, OneNineThreeOne)\nCompany(CarrozzeriaColli) & SpecializesIn(CarrozzeriaColli, UsingAluminum)\nall x. (BuiltBy(x, CarrozzeriaColli) & FirstAutomobile(x) -> RacingCar(x))\nexists x. (BuiltBy(x, CarrozzeriaColli) & RacingCar(x) & Used(x, FiatOneOneZeroZeromechanicals) & Used(x, Chassis))\nexists x. (Airforce(x) & WorkedFor(CarrozzeriaColli, x))\nexists (CarBody(x) & Made(x, CarrozzeriaColli))"
        ],
        "conclusion": "The first automobiles built by Carrozzeria Colli were built using Fiat 1100 mechanicals and chassis.",
        "conclusion-FOL": "exists x. (BuiltBy(x, CarrozzeriaColli) & FirstAutomobil(x) & Used(x, FiatOneOneZeroZeromechanicals) & Used(x, Chassis))",
        "label": "ERROR"
    },
    {
        "premises": "John will go to the cinema if and only if Jack goes to the cinema today.\nJack will go to the cinema if and only if Iron Man is on and the weather is not bad today.\nSome days in March have bad weather.\nIron Man is on.\nIt's March now.",
        "premises-FOL": [
            "(GoTo(John, TheCinema) & GoTo(John, Today)) <-> GoTo(Jack, TheCinema) & GoTo(Jack, Today)\n(GoTo(John, TheCinema) & GoTo(John, Today)) <-> (On(Ironman) & -Bad(Weather, Today))\nexists x. (Day(x) & March(x) -> -Bad(Weather, x))\nOn(Ironman)\nDay(PresentMoment) & March(PresentMoment)"
        ],
        "conclusion": "John will go to the cinema.",
        "conclusion-FOL": "GoTo(John, TheCinema) & GoTo(John, Today)",
        "label": "ERROR"
    },
    {
        "premises": "John will go to the cinema if and only if Jack goes to the cinema today.\nJack will go to the cinema if and only if Iron Man is on and the weather is not bad today.\nSome days in March have bad weather.\nIron Man is on.\nIt's March now.",
        "premises-FOL": [
            "(GoTo(John, TheCinema) & GoTo(John, Today)) <-> GoTo(Jack, TheCinema) & GoTo(Jack, Today)\n(GoTo(John, TheCinema) & GoTo(John, Today)) <-> (On(Ironman) & -Bad(Weather, Today))\nexists x. (Day(x) & March(x) -> -Bad(Weather, x))\nOn(Ironman)\nDay(PresentMoment) & March(PresentMoment)"
        ],
        "conclusion": "The weather is good today.",
        "conclusion-FOL": "-Bad(Weather, Today)",
        "label": "ERROR"
    },
    {
        "premises": "Quiksilver sells sportswear, clothing, footwear, and accessories.\nFlannels are a type of clothing.\nJoe owns an item from Quiksilver.",
        "premises-FOL": [
            "all x. (Sells(Quiksilver, x) -> (Sportswear(x) | Clothing(x) | Footwear(x) | Accessory(x)))\nClothing(Flannel)\nexists x. (Sells(Quiksilver, x) & Owns(Joe, x))"
        ],
        "conclusion": "Quiksilver sells beer.",
        "conclusion-FOL": "Sells(Quiksilver, Beer)",
        "label": "ERROR"
    },
    {
        "premises": "Quiksilver sells sportswear, clothing, footwear, and accessories.\nFlannels are a type of clothing.\nJoe owns an item from Quiksilver.",
        "premises-FOL": [
            "all x. (Sells(Quiksilver, x) -> (Sportswear(x) | Clothing(x) | Footwear(x) | Accessory(x)))\nClothing(Flannel)\nexists x. (Sells(Quiksilver, x) & Owns(Joe, x))"
        ],
        "conclusion": "Joe owns a flannel.",
        "conclusion-FOL": "Owns(Joe, Flannel)",
        "label": "ERROR"
    },
    {
        "premises": "Quiksilver sells sportswear, clothing, footwear, and accessories.\nFlannels are a type of clothing.\nJoe owns an item from Quiksilver.",
        "premises-FOL": [
            "all x. (Sells(Quiksilver, x) -> (Sportswear(x) | Clothing(x) | Footwear(x) | Accessory(x)))\nClothing(Flannel)\nexists x. (Sells(Quiksilver, x) & Owns(Joe, x))"
        ],
        "conclusion": "Joe owns at least one piece of sportswear, clothing, footwear, or accessory",
        "conclusion-FOL": "exists x. (Owns(Joe, x) & Sportswear(x) | Clothing(x) | Footwear(x) | Accessory(x))",
        "label": "ERROR"
    },
    {
        "premises": "No video games released by Nintendo support the PS4 platform.\nAll video games in the Pokemon series are released by Nintendo. \nAll video games in the FIFA series support the PS4 platform. \nAll video games that allow users to simulate playing online soccer using licensed players are in the FIFA series.\nThe video game named \u201cBe Lionel\u201d is in the Pokemon series, or it allows users to simulate playing online soccer games using licensed players.",
        "premises-FOL": [
            "all x. (VideoGame(x) & ReleasedBy(x, Nintendo) -> -Support(x, pSFour))\nall x. (VideoGame(x) & In(x, PokemonSeries) -> ReleasedBy(x, Nintendo))\nall x. (VideoGame(x) & In(x, fIFASeries) -> Support(x, pSFour))\nall x. (VideoGame(x) & Simulate(x, OnlineSoccer) & Use(x, LicensedPlayer) -> In(x, fIFASeries))\nVideoGame(BeLionel) & In(BeLionel, PokemonSeries) | (Simulate(BeLionel, OnlineSoccer) & Use(BeLionel, LicensedPlayer))"
        ],
        "conclusion": "The video game \"Be Lionel\" is in the pokemon series.",
        "conclusion-FOL": "VideoGame(BeLionel) & PokemonSeries(BeLionel)",
        "label": "ERROR"
    },
    {
        "premises": "No video games released by Nintendo support the PS4 platform.\nAll video games in the Pokemon series are released by Nintendo. \nAll video games in the FIFA series support the PS4 platform. \nAll video games that allow users to simulate playing online soccer using licensed players are in the FIFA series.\nThe video game named \u201cBe Lionel\u201d is in the Pokemon series, or it allows users to simulate playing online soccer games using licensed players.",
        "premises-FOL": [
            "all x. (VideoGame(x) & ReleasedBy(x, Nintendo) -> -Support(x, pSFour))\nall x. (VideoGame(x) & In(x, PokemonSeries) -> ReleasedBy(x, Nintendo))\nall x. (VideoGame(x) & In(x, fIFASeries) -> Support(x, pSFour))\nall x. (VideoGame(x) & Simulate(x, OnlineSoccer) & Use(x, LicensedPlayer) -> In(x, fIFASeries))\nVideoGame(BeLionel) & In(BeLionel, PokemonSeries) | (Simulate(BeLionel, OnlineSoccer) & Use(BeLionel, LicensedPlayer))"
        ],
        "conclusion": "The video game named \u201cBe Lionel\u201d either is in the FIFA series and supports the PS4 platform, or it neither is in the FIFA series nor supports the PS4 platform.",
        "conclusion-FOL": "VideoGame(BeLionel) &  -(((FIFASeries(BeLionel) & -Support(BeLionel, pSFour)) | (-FIFASeries(BeLionel) & Support(BeLionel, pSFour))))",
        "label": "ERROR"
    },
    {
        "premises": "No video games released by Nintendo support the PS4 platform.\nAll video games in the Pokemon series are released by Nintendo. \nAll video games in the FIFA series support the PS4 platform. \nAll video games that allow users to simulate playing online soccer using licensed players are in the FIFA series.\nThe video game named \u201cBe Lionel\u201d is in the Pokemon series, or it allows users to simulate playing online soccer games using licensed players.",
        "premises-FOL": [
            "all x. (VideoGame(x) & ReleasedBy(x, Nintendo) -> -Support(x, pSFour))\nall x. (VideoGame(x) & In(x, PokemonSeries) -> ReleasedBy(x, Nintendo))\nall x. (VideoGame(x) & In(x, fIFASeries) -> Support(x, pSFour))\nall x. (VideoGame(x) & Simulate(x, OnlineSoccer) & Use(x, LicensedPlayer) -> In(x, fIFASeries))\nVideoGame(BeLionel) & In(BeLionel, PokemonSeries) | (Simulate(BeLionel, OnlineSoccer) & Use(BeLionel, LicensedPlayer))"
        ],
        "conclusion": "The video game named \u201cBe Lionel\u201d is either in the FIFA series or supports the PS4 platform.",
        "conclusion-FOL": "VideoGame(BeLionel) & ((FIFASeries(BeLionel) & -Support(BeLionel, pSFour)) | (-FIFASeries(BeLionel) & Support(BeLionel, pSFour)))",
        "label": "ERROR"
    },
    {
        "premises": "No video games released by Nintendo support the PS4 platform.\nAll video games in the Pokemon series are released by Nintendo. \nAll video games in the FIFA series support the PS4 platform. \nAll video games that allow users to simulate playing online soccer using licensed players are in the FIFA series.\nThe video game named \u201cBe Lionel\u201d is in the Pokemon series, or it allows users to simulate playing online soccer games using licensed players.",
        "premises-FOL": [
            "all x. (VideoGame(x) & ReleasedBy(x, Nintendo) -> -Support(x, pSFour))\nall x. (VideoGame(x) & In(x, PokemonSeries) -> ReleasedBy(x, Nintendo))\nall x. (VideoGame(x) & In(x, fIFASeries) -> Support(x, pSFour))\nall x. (VideoGame(x) & Simulate(x, OnlineSoccer) & Use(x, LicensedPlayer) -> In(x, fIFASeries))\nVideoGame(BeLionel) & In(BeLionel, PokemonSeries) | (Simulate(BeLionel, OnlineSoccer) & Use(BeLionel, LicensedPlayer))"
        ],
        "conclusion": "The video game named \u201cBe Lionel\u201d  is not in the FIFA or Pokemon series.",
        "conclusion-FOL": "VideoGame(BeLionel) & -(FIFASeries(BeLionel) | Support(BeLionel, pSFour))",
        "label": "ERROR"
    },
    {
        "premises": "No payment cards issued by Russian banks can be used with ApplePay.\nAll MIR payment cards are issued by Russian banks.\nSome international payment cards can be used with ApplePay.\nSocial payments in Russia can only be transferred to MIR payment cards.\nBank of America payment cards can be used with ApplePay.",
        "premises-FOL": [
            "all x. all y. (PaymentCard(x) & RussianBank(y) & IssuedBy(x, y) -> -UsedWith(x, ApplePay))\nall x. all y. (PaymentCard(x) & MIR(x) -> RussianBank(y) & IssuedBy(x, y))\nexists x. (PaymentCard(x) & International(x) -> UsedWith(x, ApplePay))\nall x. all y. (SocialPayment(x) &TransferredTo(x, y) -> PaymentCard(y) & MIR(y))\nPaymentCard(BankOfAmerica) & UsedWith(BankOfAmerica, ApplePay)"
        ],
        "conclusion": "Bank of America payment cards are international.",
        "conclusion-FOL": "PaymentCard(BankOfAmerica) & International(BankOfAmerica)",
        "label": "ERROR"
    },
    {
        "premises": "No payment cards issued by Russian banks can be used with ApplePay.\nAll MIR payment cards are issued by Russian banks.\nSome international payment cards can be used with ApplePay.\nSocial payments in Russia can only be transferred to MIR payment cards.\nBank of America payment cards can be used with ApplePay.",
        "premises-FOL": [
            "all x. all y. (PaymentCard(x) & RussianBank(y) & IssuedBy(x, y) -> -UsedWith(x, ApplePay))\nall x. all y. (PaymentCard(x) & MIR(x) -> RussianBank(y) & IssuedBy(x, y))\nexists x. (PaymentCard(x) & International(x) -> UsedWith(x, ApplePay))\nall x. all y. (SocialPayment(x) &TransferredTo(x, y) -> PaymentCard(y) & MIR(y))\nPaymentCard(BankOfAmerica) & UsedWith(BankOfAmerica, ApplePay)"
        ],
        "conclusion": "Bank of America payment cards are international and can be used to transfer social payments in Russia.",
        "conclusion-FOL": "all x. (PaymentCard(BankOfAmerica) & International(BankOfAmerica) & SocialPayment(x) &TransferredTo(x, BankOfAmerica))",
        "label": "ERROR"
    },
    {
        "premises": "No payment cards issued by Russian banks can be used with ApplePay.\nAll MIR payment cards are issued by Russian banks.\nSome international payment cards can be used with ApplePay.\nSocial payments in Russia can only be transferred to MIR payment cards.\nBank of America payment cards can be used with ApplePay.",
        "premises-FOL": [
            "all x. all y. (PaymentCard(x) & RussianBank(y) & IssuedBy(x, y) -> -UsedWith(x, ApplePay))\nall x. all y. (PaymentCard(x) & MIR(x) -> RussianBank(y) & IssuedBy(x, y))\nexists x. (PaymentCard(x) & International(x) -> UsedWith(x, ApplePay))\nall x. all y. (SocialPayment(x) &TransferredTo(x, y) -> PaymentCard(y) & MIR(y))\nPaymentCard(BankOfAmerica) & UsedWith(BankOfAmerica, ApplePay)"
        ],
        "conclusion": "If Bank of America payment cards are international and can be used to transfer social payments in Russia, then they are international.",
        "conclusion-FOL": "all x. ((PaymentCard(BandOfAmerica) & International(BandOfAmerica) & SocialPayment(x) & TransferredTo(x, BandOfAmerica)) -> International(BandOfAmerica))",
        "label": "ERROR"
    },
    {
        "premises": "The Lumina APV is produced by Chevrolet. \nThe Astro is a van produced by Chevrolet. \nVehicles produced by Chevrolet in this batch are either cars or vans.",
        "premises-FOL": [
            "ProducedBy(LuminaAPV, Chevrolet)\nProducedBy(Astro, Chevrolet) & Van(Astro)\nall x. (Vehicle(x) & ProducedBy(x, Chevrolet) & InThisBatch(x) -> (((Car(x) & -Van(x)) | (-Car(x) & Van(x)))))"
        ],
        "conclusion": "The Lumina APV is a van.",
        "conclusion-FOL": "Van(LuminaAPV)",
        "label": "ERROR"
    },
    {
        "premises": "The Lumina APV is produced by Chevrolet. \nThe Astro is a van produced by Chevrolet. \nVehicles produced by Chevrolet in this batch are either cars or vans.",
        "premises-FOL": [
            "ProducedBy(LuminaAPV, Chevrolet)\nProducedBy(Astro, Chevrolet) & Van(Astro)\nall x. (Vehicle(x) & ProducedBy(x, Chevrolet) & InThisBatch(x) -> (((Car(x) & -Van(x)) | (-Car(x) & Van(x)))))"
        ],
        "conclusion": "The Lumina APV is either a car or a van.",
        "conclusion-FOL": "((Car(LuminaAPV) & -Van(LuminaAPV)) | (-Car(LuminaAPV) & Van(LuminaAPV)))",
        "label": "ERROR"
    },
    {
        "premises": "The Lumina APV is produced by Chevrolet. \nThe Astro is a van produced by Chevrolet. \nVehicles produced by Chevrolet in this batch are either cars or vans.",
        "premises-FOL": [
            "ProducedBy(LuminaAPV, Chevrolet)\nProducedBy(Astro, Chevrolet) & Van(Astro)\nall x. (Vehicle(x) & ProducedBy(x, Chevrolet) & InThisBatch(x) -> (((Car(x) & -Van(x)) | (-Car(x) & Van(x)))))"
        ],
        "conclusion": "The Astro is a van.",
        "conclusion-FOL": "Van(Astro)",
        "label": "ERROR"
    },
    {
        "premises": "The Lumina APV is produced by Chevrolet. \nThe Astro is a van produced by Chevrolet. \nVehicles produced by Chevrolet in this batch are either cars or vans.",
        "premises-FOL": [
            "ProducedBy(LuminaAPV, Chevrolet)\nProducedBy(Astro, Chevrolet) & Van(Astro)\nall x. (Vehicle(x) & ProducedBy(x, Chevrolet) & InThisBatch(x) -> (((Car(x) & -Van(x)) | (-Car(x) & Van(x)))))"
        ],
        "conclusion": "The Astro is a car.",
        "conclusion-FOL": "Car(Astro)",
        "label": "ERROR"
    },
    {
        "premises": "Everyone who works in the office is a commuter. \nPeople either work in the office or work from home.\nEveryone who works from home has a relaxed schedule.\nGeorge is either a commuter or has a home office setup. \nIf George is either a person who works from home or has a home office setup, then George is a commuter and is not a person who works from home.",
        "premises-FOL": [
            "all x. (WorkIn(x, Office) -> Commuter(x))\nall x. (((WorkIn(x, Office) & -WorkFrom(x, Home)) | (-WorkIn(x, Office) & WorkFrom(x, Home))))\nall x. (WorkFrom(x, Home) -> Have(x, RelaxedSchedule))\n((Commuter(George) & -Have(George, HomeOffice)) | (-Commuter(George) & Have(George, HomeOffice)))\n(((WorkFrom(George, Home) & -Have(George, HomeOffice)) | (-WorkFrom(George, Home) & Have(George, HomeOffice)))) -> -WorkFrom(George, Home) & Commuter(George)"
        ],
        "conclusion": "George is a person who works from home.",
        "conclusion-FOL": "WorkFrom(George, Home)",
        "label": "ERROR"
    },
    {
        "premises": "Everyone who works in the office is a commuter. \nPeople either work in the office or work from home.\nEveryone who works from home has a relaxed schedule.\nGeorge is either a commuter or has a home office setup. \nIf George is either a person who works from home or has a home office setup, then George is a commuter and is not a person who works from home.",
        "premises-FOL": [
            "all x. (WorkIn(x, Office) -> Commuter(x))\nall x. (((WorkIn(x, Office) & -WorkFrom(x, Home)) | (-WorkIn(x, Office) & WorkFrom(x, Home))))\nall x. (WorkFrom(x, Home) -> Have(x, RelaxedSchedule))\n((Commuter(George) & -Have(George, HomeOffice)) | (-Commuter(George) & Have(George, HomeOffice)))\n(((WorkFrom(George, Home) & -Have(George, HomeOffice)) | (-WorkFrom(George, Home) & Have(George, HomeOffice)))) -> -WorkFrom(George, Home) & Commuter(George)"
        ],
        "conclusion": "If George is not a person who works from home and a person who works in the office, then George is neither a commuter nor a person who has a relaxed schedule.",
        "conclusion-FOL": "-(WorkFrom(George, Home) & WorkIn(George, Office)) -> -(Commuter(George) | Have(George, RelaxedSchedule))",
        "label": "ERROR"
    },
    {
        "premises": "Everyone who works in the office is a commuter. \nPeople either work in the office or work from home.\nEveryone who works from home has a relaxed schedule.\nGeorge is either a commuter or has a home office setup. \nIf George is either a person who works from home or has a home office setup, then George is a commuter and is not a person who works from home.",
        "premises-FOL": [
            "all x. (WorkIn(x, Office) -> Commuter(x))\nall x. (((WorkIn(x, Office) & -WorkFrom(x, Home)) | (-WorkIn(x, Office) & WorkFrom(x, Home))))\nall x. (WorkFrom(x, Home) -> Have(x, RelaxedSchedule))\n((Commuter(George) & -Have(George, HomeOffice)) | (-Commuter(George) & Have(George, HomeOffice)))\n(((WorkFrom(George, Home) & -Have(George, HomeOffice)) | (-WorkFrom(George, Home) & Have(George, HomeOffice)))) -> -WorkFrom(George, Home) & Commuter(George)"
        ],
        "conclusion": "If George is either a person who has a home office setup and a person who works in the office, or neither a person who has a home office setup nor a person who works in the office, then George is either a person who works from home or a person who has a relaxed schedule.",
        "conclusion-FOL": "-(((Have(George, HomeOffice) & -WorkIn(George, Office)) | (-Have(George, HomeOffice) & WorkIn(George, Office)))) -> (((WorkFrom(George, Home) & -Have(George, RelaxedSchedule)) | (-WorkFrom(George, Home) & Have(George, RelaxedSchedule))))",
        "label": "ERROR"
    },
    {
        "premises": "Jason Kramer is an American music supervisor.\nSome American radio personalities are also music supervisors. \nAnyone who hosts a show on a public radio station is a radio personality.\nJoe Rogan is a radio personality.\nJason Kramer hosted a show on a public radio station.",
        "premises-FOL": [
            "MusicSupervisor(JasonKramer) & American(JasonKramer)\nexists x. exists y. (American(x) & MusicSupervisor(x) & RadioPersonality(x) & (-(x=y)) & American(y) & MusicSupervisor(y) & RadioPersonality(y))\nall x. all y.((HostShowOn(x, y) & PublicRadioStation(x)) -> RadioPersonality(x))\nRadioPersonality(JoeRogan)\nexists x.(HostShowOn(JasonKramer, x) & PublicRadioStation(x))"
        ],
        "conclusion": "Joe Rogan is American.",
        "conclusion-FOL": "American(JoeRogan)",
        "label": "ERROR"
    },
    {
        "premises": "Jason Kramer is an American music supervisor.\nSome American radio personalities are also music supervisors. \nAnyone who hosts a show on a public radio station is a radio personality.\nJoe Rogan is a radio personality.\nJason Kramer hosted a show on a public radio station.",
        "premises-FOL": [
            "MusicSupervisor(JasonKramer) & American(JasonKramer)\nexists x. exists y. (American(x) & MusicSupervisor(x) & RadioPersonality(x) & (-(x=y)) & American(y) & MusicSupervisor(y) & RadioPersonality(y))\nall x. all y.((HostShowOn(x, y) & PublicRadioStation(x)) -> RadioPersonality(x))\nRadioPersonality(JoeRogan)\nexists x.(HostShowOn(JasonKramer, x) & PublicRadioStation(x))"
        ],
        "conclusion": "Jason Kramer is a music supervisor.",
        "conclusion-FOL": "MusicSupervisor(JasonKramer)",
        "label": "ERROR"
    },
    {
        "premises": "Jason Kramer is an American music supervisor.\nSome American radio personalities are also music supervisors. \nAnyone who hosts a show on a public radio station is a radio personality.\nJoe Rogan is a radio personality.\nJason Kramer hosted a show on a public radio station.",
        "premises-FOL": [
            "MusicSupervisor(JasonKramer) & American(JasonKramer)\nexists x. exists y. (American(x) & MusicSupervisor(x) & RadioPersonality(x) & (-(x=y)) & American(y) & MusicSupervisor(y) & RadioPersonality(y))\nall x. all y.((HostShowOn(x, y) & PublicRadioStation(x)) -> RadioPersonality(x))\nRadioPersonality(JoeRogan)\nexists x.(HostShowOn(JasonKramer, x) & PublicRadioStation(x))"
        ],
        "conclusion": "Jason Kramer is a radio personality.",
        "conclusion-FOL": "RadioPersonality(JasonKramer)",
        "label": "ERROR"
    },
    {
        "premises": "Herm\u00e8s bags are not made in Italy.\nAll Birkin bags are Herm\u00e8s bags. \nAll Ferraris are made in Italy. \nAll cars that carry a Ferrari V12 engine are Ferraris. \nAll cars that are made in Maranello carry a Ferrari V12 engine.\nA Lamborghini SUV is not both a Ferrari and made in Maranello. \nA Kelly bag is a Herm\u00e8s bag, or it is a car that carries a Ferrari V12 engine. ",
        "premises-FOL": [
            "all x. ((Bag(x) & Herm\u00e8s(x)) -> -MadeIn(x, Italy))\nall x. ((Bag(x) & Birkin(x)) -> Herm\u00e8s(x))\nall x. (Ferrari(x) -> MadeIn(x, Italy))\nall x. ((Car(x) & Carry(x, FerrariVOneTwoEngine)) -> Ferrrari(x))\nall x. ((Car(x) & MadeIn(x, Maranello)) -> Carry(x, FerrariVOneTwoEngine))\n-(Ferrari(LamborghiniSUV) & MadeIn(LamborghiniSUV, Maranello))\n(Bag(Kelly) & Herm\u00e8s(Kelly)) | (Bag(Kelly) & Car(Kelly) & Carry(Kelly, FerrariVOneTwoEngine))"
        ],
        "conclusion": "A Lamborghini SUV is made in Italy.",
        "conclusion-FOL": "MadeIn(LamborghiniSUV, Italy)",
        "label": "ERROR"
    },
    {
        "premises": "Herm\u00e8s bags are not made in Italy.\nAll Birkin bags are Herm\u00e8s bags. \nAll Ferraris are made in Italy. \nAll cars that carry a Ferrari V12 engine are Ferraris. \nAll cars that are made in Maranello carry a Ferrari V12 engine.\nA Lamborghini SUV is not both a Ferrari and made in Maranello. \nA Kelly bag is a Herm\u00e8s bag, or it is a car that carries a Ferrari V12 engine. ",
        "premises-FOL": [
            "all x. ((Bag(x) & Herm\u00e8s(x)) -> -MadeIn(x, Italy))\nall x. ((Bag(x) & Birkin(x)) -> Herm\u00e8s(x))\nall x. (Ferrari(x) -> MadeIn(x, Italy))\nall x. ((Car(x) & Carry(x, FerrariVOneTwoEngine)) -> Ferrrari(x))\nall x. ((Car(x) & MadeIn(x, Maranello)) -> Carry(x, FerrariVOneTwoEngine))\n-(Ferrari(LamborghiniSUV) & MadeIn(LamborghiniSUV, Maranello))\n(Bag(Kelly) & Herm\u00e8s(Kelly)) | (Bag(Kelly) & Car(Kelly) & Carry(Kelly, FerrariVOneTwoEngine))"
        ],
        "conclusion": "A Lamborghini SUV is not made in Italy.",
        "conclusion-FOL": "-MadeIn(LamborghiniSUV, Italy)",
        "label": "ERROR"
    },
    {
        "premises": "Herm\u00e8s bags are not made in Italy.\nAll Birkin bags are Herm\u00e8s bags. \nAll Ferraris are made in Italy. \nAll cars that carry a Ferrari V12 engine are Ferraris. \nAll cars that are made in Maranello carry a Ferrari V12 engine.\nA Lamborghini SUV is not both a Ferrari and made in Maranello. \nA Kelly bag is a Herm\u00e8s bag, or it is a car that carries a Ferrari V12 engine. ",
        "premises-FOL": [
            "all x. ((Bag(x) & Herm\u00e8s(x)) -> -MadeIn(x, Italy))\nall x. ((Bag(x) & Birkin(x)) -> Herm\u00e8s(x))\nall x. (Ferrari(x) -> MadeIn(x, Italy))\nall x. ((Car(x) & Carry(x, FerrariVOneTwoEngine)) -> Ferrrari(x))\nall x. ((Car(x) & MadeIn(x, Maranello)) -> Carry(x, FerrariVOneTwoEngine))\n-(Ferrari(LamborghiniSUV) & MadeIn(LamborghiniSUV, Maranello))\n(Bag(Kelly) & Herm\u00e8s(Kelly)) | (Bag(Kelly) & Car(Kelly) & Carry(Kelly, FerrariVOneTwoEngine))"
        ],
        "conclusion": "A Kelly bag is a Birkin bag made in Maranello.",
        "conclusion-FOL": "Bag(Kelly) & MadeIn(Kelly, Maranello) & Birkin(Kelly)",
        "label": "ERROR"
    },
    {
        "premises": "Herm\u00e8s bags are not made in Italy.\nAll Birkin bags are Herm\u00e8s bags. \nAll Ferraris are made in Italy. \nAll cars that carry a Ferrari V12 engine are Ferraris. \nAll cars that are made in Maranello carry a Ferrari V12 engine.\nA Lamborghini SUV is not both a Ferrari and made in Maranello. \nA Kelly bag is a Herm\u00e8s bag, or it is a car that carries a Ferrari V12 engine. ",
        "premises-FOL": [
            "all x. ((Bag(x) & Herm\u00e8s(x)) -> -MadeIn(x, Italy))\nall x. ((Bag(x) & Birkin(x)) -> Herm\u00e8s(x))\nall x. (Ferrari(x) -> MadeIn(x, Italy))\nall x. ((Car(x) & Carry(x, FerrariVOneTwoEngine)) -> Ferrrari(x))\nall x. ((Car(x) & MadeIn(x, Maranello)) -> Carry(x, FerrariVOneTwoEngine))\n-(Ferrari(LamborghiniSUV) & MadeIn(LamborghiniSUV, Maranello))\n(Bag(Kelly) & Herm\u00e8s(Kelly)) | (Bag(Kelly) & Car(Kelly) & Carry(Kelly, FerrariVOneTwoEngine))"
        ],
        "conclusion": "A Kelly bag is not both made in Maranello and a Birkin bag.",
        "conclusion-FOL": "Bag(Kelly) & -(MadeIn(Kelly, Maranello) & Birkin(Kelly))",
        "label": "ERROR"
    },
    {
        "premises": "If someone lives in a place named Galicia, then they live in either Spain or Poland.\nSpain is in Europe.\nPoland is in Europe.\nRochelle lives in Europe.\nDominique does not live in Europe.\nAlfonso lives in a place named Galicia.",
        "premises-FOL": [
            "all x. (exists y. (LiveIn(x, y) & Place(y) & Named(y, Galicia)) -> ((LiveIn(x, Spain) & -LiveIn(x, Poland)) | (-LiveIn(x, Spain) & LiveIn(x, Poland))))\nall x. (LiveIn(x, Spain) -> LiveIn(x, Europe))\nall x. (LiveIn(x, Poland) -> LiveIn(x, Europe))\nLiveIn(Rochelle, Europe)\n-LiveIn(Dominique, Europe)\nexists y. (LiveIn(Alfonso, y) & Place(y) & Named(y, Galicia))"
        ],
        "conclusion": "Rochelle lives in a place namedGalicia.",
        "conclusion-FOL": "exists y. (LiveIn(Rochelle, y) & Place(y) & Named(y, Galicia))",
        "label": "ERROR"
    },
    {
        "premises": "If someone lives in a place named Galicia, then they live in either Spain or Poland.\nSpain is in Europe.\nPoland is in Europe.\nRochelle lives in Europe.\nDominique does not live in Europe.\nAlfonso lives in a place named Galicia.",
        "premises-FOL": [
            "all x. (exists y. (LiveIn(x, y) & Place(y) & Named(y, Galicia)) -> ((LiveIn(x, Spain) & -LiveIn(x, Poland)) | (-LiveIn(x, Spain) & LiveIn(x, Poland))))\nall x. (LiveIn(x, Spain) -> LiveIn(x, Europe))\nall x. (LiveIn(x, Poland) -> LiveIn(x, Europe))\nLiveIn(Rochelle, Europe)\n-LiveIn(Dominique, Europe)\nexists y. (LiveIn(Alfonso, y) & Place(y) & Named(y, Galicia))"
        ],
        "conclusion": "Dominique does not live in Spain.",
        "conclusion-FOL": "all x. (Live(Dominique, x) -> -In(x, Spain))",
        "label": "ERROR"
    },
    {
        "premises": "If someone lives in a place named Galicia, then they live in either Spain or Poland.\nSpain is in Europe.\nPoland is in Europe.\nRochelle lives in Europe.\nDominique does not live in Europe.\nAlfonso lives in a place named Galicia.",
        "premises-FOL": [
            "all x. (exists y. (LiveIn(x, y) & Place(y) & Named(y, Galicia)) -> ((LiveIn(x, Spain) & -LiveIn(x, Poland)) | (-LiveIn(x, Spain) & LiveIn(x, Poland))))\nall x. (LiveIn(x, Spain) -> LiveIn(x, Europe))\nall x. (LiveIn(x, Poland) -> LiveIn(x, Europe))\nLiveIn(Rochelle, Europe)\n-LiveIn(Dominique, Europe)\nexists y. (LiveIn(Alfonso, y) & Place(y) & Named(y, Galicia))"
        ],
        "conclusion": "Alfonso lives in Europe.",
        "conclusion-FOL": "all x. (Live(Alfonso, x) -> In(x, Europe))",
        "label": "ERROR"
    },
    {
        "premises": "Ralph Hammerthaler was born in Wasserburg am Inn.\nWasserburg am Inn is in Germany.\nGermany is in Europe.\nRalph Hammerthaler is a German writer.\nRalph Hammerthaler was born in 1965. ",
        "premises-FOL": [
            "BornIn(RalphHammerthaler, WasserburgamInn)\nLocatedIn(WasserbAmInn, Germany)\nLocatedIn(Germany, Europe)\nWriter(RalphHammerthaler) & German(RalphHammerthaler)\nBornInOneNineSixFive(RalphHammerthaler)"
        ],
        "conclusion": "Ralph Hammerthaler is a writer born in Asia.",
        "conclusion-FOL": "Writer(RalphHammerthaler) & BornIn(RalphHammerthaler, Asia)",
        "label": "ERROR"
    },
    {
        "premises": "Ralph Hammerthaler was born in Wasserburg am Inn.\nWasserburg am Inn is in Germany.\nGermany is in Europe.\nRalph Hammerthaler is a German writer.\nRalph Hammerthaler was born in 1965. ",
        "premises-FOL": [
            "BornIn(RalphHammerthaler, WasserburgamInn)\nLocatedIn(WasserbAmInn, Germany)\nLocatedIn(Germany, Europe)\nWriter(RalphHammerthaler) & German(RalphHammerthaler)\nBornInOneNineSixFive(RalphHammerthaler)"
        ],
        "conclusion": "Ralph Hammerthaler lives in Germany.",
        "conclusion-FOL": "LivesIn(RalphHammerthaler, Germany)",
        "label": "ERROR"
    },
    {
        "premises": "All books written by Neil Gaiman have sold more than one thousand copies.\nSome books that have won Hugo Awards are written by Neil Gaiman.\nTomas has read all books written by Tolkien. \nEither Tomas has read Hamlet, or it has sold more than one thousand copies.\nHamlet has either sold more than one thousand copies or it is written by Neil Gaiman.",
        "premises-FOL": [
            "all x. ((Book(x) & WrittenBy(x, NeilGaiman)) -> exists y. (MoreThan(y, NumOneZeroZeroZero) & SoldCopies(x, y)))\nexists x. exists y. (Book(x) & Win(x, HugoAward) & WrittenBy(x, NeilGaiman) & (-(x=y)) & Book(y) & Win(y, HugoAward) & WrittenBy(y, NeilGaiman))\nall x. ((Book(x) & WrittenBy(x, Tolkien)) -> ReadBy(x, Tomas))\nReadBy(Hamlet, Tomas) \u2295 (exists y. (MoreThan(y, NumOneZeroZeroZero) & SoldCopies(Hamlet, y)))\nexists y. (MoreThan(y, NumOneZeroZeroZero) & SoldCopies(Hamlet, y)) \u2295 WrittenBy(Hamlet, NeilGaiman)"
        ],
        "conclusion": "Hamlet has won a Hugo Award.",
        "conclusion-FOL": "Win(Hamlet, HugoAward)",
        "label": "ERROR"
    },
    {
        "premises": "All books written by Neil Gaiman have sold more than one thousand copies.\nSome books that have won Hugo Awards are written by Neil Gaiman.\nTomas has read all books written by Tolkien. \nEither Tomas has read Hamlet, or it has sold more than one thousand copies.\nHamlet has either sold more than one thousand copies or it is written by Neil Gaiman.",
        "premises-FOL": [
            "all x. ((Book(x) & WrittenBy(x, NeilGaiman)) -> exists y. (MoreThan(y, NumOneZeroZeroZero) & SoldCopies(x, y)))\nexists x. exists y. (Book(x) & Win(x, HugoAward) & WrittenBy(x, NeilGaiman) & (-(x=y)) & Book(y) & Win(y, HugoAward) & WrittenBy(y, NeilGaiman))\nall x. ((Book(x) & WrittenBy(x, Tolkien)) -> ReadBy(x, Tomas))\nReadBy(Hamlet, Tomas) \u2295 (exists y. (MoreThan(y, NumOneZeroZeroZero) & SoldCopies(Hamlet, y)))\nexists y. (MoreThan(y, NumOneZeroZeroZero) & SoldCopies(Hamlet, y)) \u2295 WrittenBy(Hamlet, NeilGaiman)"
        ],
        "conclusion": "Hamlet has won a Hugo Award and is written by Tolkien.",
        "conclusion-FOL": "Win(Hamlet, HugoAward) & WrittenBy(Hamlet, Tolkien)",
        "label": "ERROR"
    },
    {
        "premises": "All books written by Neil Gaiman have sold more than one thousand copies.\nSome books that have won Hugo Awards are written by Neil Gaiman.\nTomas has read all books written by Tolkien. \nEither Tomas has read Hamlet, or it has sold more than one thousand copies.\nHamlet has either sold more than one thousand copies or it is written by Neil Gaiman.",
        "premises-FOL": [
            "all x. ((Book(x) & WrittenBy(x, NeilGaiman)) -> exists y. (MoreThan(y, NumOneZeroZeroZero) & SoldCopies(x, y)))\nexists x. exists y. (Book(x) & Win(x, HugoAward) & WrittenBy(x, NeilGaiman) & (-(x=y)) & Book(y) & Win(y, HugoAward) & WrittenBy(y, NeilGaiman))\nall x. ((Book(x) & WrittenBy(x, Tolkien)) -> ReadBy(x, Tomas))\nReadBy(Hamlet, Tomas) \u2295 (exists y. (MoreThan(y, NumOneZeroZeroZero) & SoldCopies(Hamlet, y)))\nexists y. (MoreThan(y, NumOneZeroZeroZero) & SoldCopies(Hamlet, y)) \u2295 WrittenBy(Hamlet, NeilGaiman)"
        ],
        "conclusion": "If Hamlet has either won a Hugo Award and is written by Tolkien, or neither has won a Hugo Award nor is written by Tolkien, then Hamlet has neither won a Hugo Award nor is written by Neil Gaiman.",
        "conclusion-FOL": "-(((Win(Hamlet, HugoAward) & -WrittenBy(Hamlet, Tolkien)) | (-Win(Hamlet, HugoAward) & WrittenBy(Hamlet, Tolkien)))) -> (-Win(Hamlet, HugoAward) & (-WrittenBy(Hamlet, NeilGaiman)))",
        "label": "ERROR"
    },
    {
        "premises": "Grass is not food\nAll meadows are grass.\nAll edible things are food. \nAll fruits are edible.\nAll lemons are fruit.\nGrapes are not both edible and lemons.\nBananas are grasses or fruits. ",
        "premises-FOL": [
            "all x. (Grass(x) -> -Food(x))\nall x. (Meadow(x) -> Grass(x))\nall x. (Edible(x) -> Food(x))\nall x. (Fruit(x) -> Edible(x))\nall x. (Lemon(x) -> Fruit(x))\n-(Edible(Grape) & Lemon(Grape))\nGrass(Banana) | Fruit(Banana)"
        ],
        "conclusion": "Grapes are food.",
        "conclusion-FOL": "Food(Grape)",
        "label": "ERROR"
    },
    {
        "premises": "Grass is not food\nAll meadows are grass.\nAll edible things are food. \nAll fruits are edible.\nAll lemons are fruit.\nGrapes are not both edible and lemons.\nBananas are grasses or fruits. ",
        "premises-FOL": [
            "all x. (Grass(x) -> -Food(x))\nall x. (Meadow(x) -> Grass(x))\nall x. (Edible(x) -> Food(x))\nall x. (Fruit(x) -> Edible(x))\nall x. (Lemon(x) -> Fruit(x))\n-(Edible(Grape) & Lemon(Grape))\nGrass(Banana) | Fruit(Banana)"
        ],
        "conclusion": "Grapes are not a food.",
        "conclusion-FOL": "-Food(Grape)",
        "label": "ERROR"
    },
    {
        "premises": "Grass is not food\nAll meadows are grass.\nAll edible things are food. \nAll fruits are edible.\nAll lemons are fruit.\nGrapes are not both edible and lemons.\nBananas are grasses or fruits. ",
        "premises-FOL": [
            "all x. (Grass(x) -> -Food(x))\nall x. (Meadow(x) -> Grass(x))\nall x. (Edible(x) -> Food(x))\nall x. (Fruit(x) -> Edible(x))\nall x. (Lemon(x) -> Fruit(x))\n-(Edible(Grape) & Lemon(Grape))\nGrass(Banana) | Fruit(Banana)"
        ],
        "conclusion": "Bananas are both lemons and meadows.",
        "conclusion-FOL": "Lemon(Banana) & Meadow(Banana)",
        "label": "ERROR"
    },
    {
        "premises": "Grass is not food\nAll meadows are grass.\nAll edible things are food. \nAll fruits are edible.\nAll lemons are fruit.\nGrapes are not both edible and lemons.\nBananas are grasses or fruits. ",
        "premises-FOL": [
            "all x. (Grass(x) -> -Food(x))\nall x. (Meadow(x) -> Grass(x))\nall x. (Edible(x) -> Food(x))\nall x. (Fruit(x) -> Edible(x))\nall x. (Lemon(x) -> Fruit(x))\n-(Edible(Grape) & Lemon(Grape))\nGrass(Banana) | Fruit(Banana)"
        ],
        "conclusion": "Bananas are not both a lemon and a meadow.",
        "conclusion-FOL": "-(Lemon(Banana) & Meadow(Banana))",
        "label": "ERROR"
    },
    {
        "premises": "The Golden State Warriors are a team from San Francisco.\nThe Golden State Warriors won the NBA finals.\nAll teams attending the NBA finals have won many games.\nBoston Celtics are a team that lost the NBA finals.\nIf a team wins the NBA finals, then they will have more income.\nIf a team wins or loses at the NBA finals, then they are attending the finals.",
        "premises-FOL": [
            "Team(GoldenStateWarriors) & From(GoldenStateWarriors, SanFrancisco)\nWon(GoldenStateWarriors, NbaFinals)\nall x. ((Team(x) & Attending(x, NbaFinals)) -> WonManyGames(x))\nTeam(BostonCeltics) & Lost(BostonCeltics, NbaFinals)\nall x. ((Team(x) & Won(x, NbaFinals)) -> MoreIncome(x))\nall x. ((Won(x, NbaFinals) | Lost(x, NbaFinals)) -> Attending(x, NbaFinals))"
        ],
        "conclusion": "The Boston Celtics are from San Francisco.",
        "conclusion-FOL": "From(BostonCeltics, SanFrancisco)",
        "label": "ERROR"
    },
    {
        "premises": "The Golden State Warriors are a team from San Francisco.\nThe Golden State Warriors won the NBA finals.\nAll teams attending the NBA finals have won many games.\nBoston Celtics are a team that lost the NBA finals.\nIf a team wins the NBA finals, then they will have more income.\nIf a team wins or loses at the NBA finals, then they are attending the finals.",
        "premises-FOL": [
            "Team(GoldenStateWarriors) & From(GoldenStateWarriors, SanFrancisco)\nWon(GoldenStateWarriors, NbaFinals)\nall x. ((Team(x) & Attending(x, NbaFinals)) -> WonManyGames(x))\nTeam(BostonCeltics) & Lost(BostonCeltics, NbaFinals)\nall x. ((Team(x) & Won(x, NbaFinals)) -> MoreIncome(x))\nall x. ((Won(x, NbaFinals) | Lost(x, NbaFinals)) -> Attending(x, NbaFinals))"
        ],
        "conclusion": "The Boston Celtics have more than 30 years of experience.",
        "conclusion-FOL": "HasMoreThanThirtyYearsOfHistory(BostonCeltics)",
        "label": "ERROR"
    },
    {
        "premises": "The Golden State Warriors are a team from San Francisco.\nThe Golden State Warriors won the NBA finals.\nAll teams attending the NBA finals have won many games.\nBoston Celtics are a team that lost the NBA finals.\nIf a team wins the NBA finals, then they will have more income.\nIf a team wins or loses at the NBA finals, then they are attending the finals.",
        "premises-FOL": [
            "Team(GoldenStateWarriors) & From(GoldenStateWarriors, SanFrancisco)\nWon(GoldenStateWarriors, NbaFinals)\nall x. ((Team(x) & Attending(x, NbaFinals)) -> WonManyGames(x))\nTeam(BostonCeltics) & Lost(BostonCeltics, NbaFinals)\nall x. ((Team(x) & Won(x, NbaFinals)) -> MoreIncome(x))\nall x. ((Won(x, NbaFinals) | Lost(x, NbaFinals)) -> Attending(x, NbaFinals))"
        ],
        "conclusion": "The Golden State Warriors will have more income from gate receipts.",
        "conclusion-FOL": "MoreIncome(GoldenStateWarriors)",
        "label": "ERROR"
    },
    {
        "premises": "Maya would only play the violin if her fingers could never be injured. \nVolleyball players can injure their ankles, fingers, or shoulder.\nMaya is a volleyball player.",
        "premises-FOL": [
            "Play(Maya, Violin) -> -CanInjure(Maya, Fingers)\nall x. (VolleyballPlayer(x) -> (CanInjure(Ankles) & CanInjure(Fingers) & CanInjure(Shoulder)))\nVolleyballPlayer(Maya)"
        ],
        "conclusion": "Maya will not play the violin.",
        "conclusion-FOL": "-Play(Maya, Violin)",
        "label": "ERROR"
    },
    {
        "premises": "All devices belonging to the company are connected to Google Home. \nAll devices with the company logo belong to the company. \nEach device either has the company logo or belongs to employees. \nAll of the devices belonging to employees can be connected to the company's wifi. \nAll of the devices connected to Google Home are controlled by managers. \nAll of the devices that connect to the company's wifi are easy to operate. \nAll of the devices that are easy to operate were produced after a new CTO is appointed. \nModelXX was not produced after a new CTO was appointed.",
        "premises-FOL": [
            "all x. ((Devices(x) & BelongTo(x, Company)) -> ConnectTo(x, GoogleHome))\nall x. ((Devices(x) & With(x, CompanyLogo)) -> BelongTo(x, Company))\nall x. ((Devices(x) -> (((With(x, CompanyLogo) & -BelongTo(x, Employee)) | (-With(x, CompanyLogo) & BelongTo(x, Employee)))))\nall x. ((Devices(x) & BelongTo(x, Employee)) -> CanBeConnectedTo(x, Wifi))\nall x. ((Devices(x) & ConnectTo(x, GoogleHome)) -> ControlledBy(x, Manager))\nall x. ((Devices(x) & CanBeConnectedTo(x, Wifi)) -> EasyToOperate(x))\nall x. ((Devices(x) & EasyToOperate(x)) -> ProducedAfterNewCTOAppointed(x, Company))\nDevices(ModelXX) & (-ProducedAfterNewCTOAppointed(ModelXX, Company))"
        ],
        "conclusion": "ModelXX is controlled by managers.",
        "conclusion-FOL": "ControlledBy(x, Manager)",
        "label": "ERROR"
    },
    {
        "premises": "All devices belonging to the company are connected to Google Home. \nAll devices with the company logo belong to the company. \nEach device either has the company logo or belongs to employees. \nAll of the devices belonging to employees can be connected to the company's wifi. \nAll of the devices connected to Google Home are controlled by managers. \nAll of the devices that connect to the company's wifi are easy to operate. \nAll of the devices that are easy to operate were produced after a new CTO is appointed. \nModelXX was not produced after a new CTO was appointed.",
        "premises-FOL": [
            "all x. ((Devices(x) & BelongTo(x, Company)) -> ConnectTo(x, GoogleHome))\nall x. ((Devices(x) & With(x, CompanyLogo)) -> BelongTo(x, Company))\nall x. ((Devices(x) -> (((With(x, CompanyLogo) & -BelongTo(x, Employee)) | (-With(x, CompanyLogo) & BelongTo(x, Employee)))))\nall x. ((Devices(x) & BelongTo(x, Employee)) -> CanBeConnectedTo(x, Wifi))\nall x. ((Devices(x) & ConnectTo(x, GoogleHome)) -> ControlledBy(x, Manager))\nall x. ((Devices(x) & CanBeConnectedTo(x, Wifi)) -> EasyToOperate(x))\nall x. ((Devices(x) & EasyToOperate(x)) -> ProducedAfterNewCTOAppointed(x, Company))\nDevices(ModelXX) & (-ProducedAfterNewCTOAppointed(ModelXX, Company))"
        ],
        "conclusion": "ModelXX is either produced after a new CTO was appointed or it is controlled by managers.",
        "conclusion-FOL": "((ProducedAfterNewCTOAppointed(ModelXX, TheCompany) & -ControlledBy(x, Manager)) | (-ProducedAfterNewCTOAppointed(ModelXX, TheCompany) & ControlledBy(x, Manager)))",
        "label": "ERROR"
    },
    {
        "premises": "All devices belonging to the company are connected to Google Home. \nAll devices with the company logo belong to the company. \nEach device either has the company logo or belongs to employees. \nAll of the devices belonging to employees can be connected to the company's wifi. \nAll of the devices connected to Google Home are controlled by managers. \nAll of the devices that connect to the company's wifi are easy to operate. \nAll of the devices that are easy to operate were produced after a new CTO is appointed. \nModelXX was not produced after a new CTO was appointed.",
        "premises-FOL": [
            "all x. ((Devices(x) & BelongTo(x, Company)) -> ConnectTo(x, GoogleHome))\nall x. ((Devices(x) & With(x, CompanyLogo)) -> BelongTo(x, Company))\nall x. ((Devices(x) -> (((With(x, CompanyLogo) & -BelongTo(x, Employee)) | (-With(x, CompanyLogo) & BelongTo(x, Employee)))))\nall x. ((Devices(x) & BelongTo(x, Employee)) -> CanBeConnectedTo(x, Wifi))\nall x. ((Devices(x) & ConnectTo(x, GoogleHome)) -> ControlledBy(x, Manager))\nall x. ((Devices(x) & CanBeConnectedTo(x, Wifi)) -> EasyToOperate(x))\nall x. ((Devices(x) & EasyToOperate(x)) -> ProducedAfterNewCTOAppointed(x, Company))\nDevices(ModelXX) & (-ProducedAfterNewCTOAppointed(ModelXX, Company))"
        ],
        "conclusion": "ModelXX is not with the company logo, and managers do not control it.",
        "conclusion-FOL": "-With(ModelXX, CompanyLogo) & (-ControlledBy(x, Manager))",
        "label": "ERROR"
    },
    {
        "premises": "All devices belonging to the company are connected to Google Home. \nAll devices with the company logo belong to the company. \nEach device either has the company logo or belongs to employees. \nAll of the devices belonging to employees can be connected to the company's wifi. \nAll of the devices connected to Google Home are controlled by managers. \nAll of the devices that connect to the company's wifi are easy to operate. \nAll of the devices that are easy to operate were produced after a new CTO is appointed. \nModelXX was not produced after a new CTO was appointed.",
        "premises-FOL": [
            "all x. ((Devices(x) & BelongTo(x, Company)) -> ConnectTo(x, GoogleHome))\nall x. ((Devices(x) & With(x, CompanyLogo)) -> BelongTo(x, Company))\nall x. ((Devices(x) -> (((With(x, CompanyLogo) & -BelongTo(x, Employee)) | (-With(x, CompanyLogo) & BelongTo(x, Employee)))))\nall x. ((Devices(x) & BelongTo(x, Employee)) -> CanBeConnectedTo(x, Wifi))\nall x. ((Devices(x) & ConnectTo(x, GoogleHome)) -> ControlledBy(x, Manager))\nall x. ((Devices(x) & CanBeConnectedTo(x, Wifi)) -> EasyToOperate(x))\nall x. ((Devices(x) & EasyToOperate(x)) -> ProducedAfterNewCTOAppointed(x, Company))\nDevices(ModelXX) & (-ProducedAfterNewCTOAppointed(ModelXX, Company))"
        ],
        "conclusion": "ModelXX is either with the company logo or controlled by managers.",
        "conclusion-FOL": "((With(ModelXX, CompanyLogo) & -ControlledBy(x, Manager)) | (-With(ModelXX, CompanyLogo) & ControlledBy(x, Manager)))",
        "label": "ERROR"
    },
    {
        "premises": "All CD players are delicate mechanisms.\nNo delicate mechanisms are suitable toys for children.",
        "premises-FOL": [
            "all x. (CDPlayer(x) -> DelicateMechanism(x))\nall x. (DelicateMechanism(x) -> -(Toy(x) & SuitableFor(x, Children)))"
        ],
        "conclusion": "Some CD players are suitable toys for children.",
        "conclusion-FOL": "exists x. exists y. (CDPlayer(x) & CDPlayer(y) & Toy(x) & Toy(y) & SuitableFor(x, Children) & SuitableFor(y, Children) & -(x=y))",
        "label": "ERROR"
    },
    {
        "premises": "All mammals are living beings.\nAll elephants are mammals.\nAll baby elephants are elephants.\nSome baby elephants are sleepy.\nIf Jumbo is a living being, then Jumbo is not both an elephant and a mammal.\nIf Jumbo is sleepy, then Jumbo is either a baby elephant or a mammal.",
        "premises-FOL": [
            "all x. (Mammal(x) -> LivingBeing(x)) \nall x. (Elephant(x) -> Mammal(x))\nall x. (BabyElephant(x) -> Elephant(x))\nexists x. (BabyElephant(x) & Sleepy(x))\nLivingBeing(Jumbo) -> -(Elephant(Jumbo) & Mammal(Jumbo))\nSleepy(Jumbo) -> ((BabyElephant(Jumbo) & -Mammal(Jumbo)) | (-BabyElephant(Jumbo) & Mammal(Jumbo)))"
        ],
        "conclusion": "Jumbo is sleepy.",
        "conclusion-FOL": "Sleepy(Jumbo)",
        "label": "ERROR"
    },
    {
        "premises": "All mammals are living beings.\nAll elephants are mammals.\nAll baby elephants are elephants.\nSome baby elephants are sleepy.\nIf Jumbo is a living being, then Jumbo is not both an elephant and a mammal.\nIf Jumbo is sleepy, then Jumbo is either a baby elephant or a mammal.",
        "premises-FOL": [
            "all x. (Mammal(x) -> LivingBeing(x)) \nall x. (Elephant(x) -> Mammal(x))\nall x. (BabyElephant(x) -> Elephant(x))\nexists x. (BabyElephant(x) & Sleepy(x))\nLivingBeing(Jumbo) -> -(Elephant(Jumbo) & Mammal(Jumbo))\nSleepy(Jumbo) -> ((BabyElephant(Jumbo) & -Mammal(Jumbo)) | (-BabyElephant(Jumbo) & Mammal(Jumbo)))"
        ],
        "conclusion": "Jumbo is not sleepy.",
        "conclusion-FOL": "-Sleepy(Jumbo)",
        "label": "ERROR"
    },
    {
        "premises": "All mammals are living beings.\nAll elephants are mammals.\nAll baby elephants are elephants.\nSome baby elephants are sleepy.\nIf Jumbo is a living being, then Jumbo is not both an elephant and a mammal.\nIf Jumbo is sleepy, then Jumbo is either a baby elephant or a mammal.",
        "premises-FOL": [
            "all x. (Mammal(x) -> LivingBeing(x)) \nall x. (Elephant(x) -> Mammal(x))\nall x. (BabyElephant(x) -> Elephant(x))\nexists x. (BabyElephant(x) & Sleepy(x))\nLivingBeing(Jumbo) -> -(Elephant(Jumbo) & Mammal(Jumbo))\nSleepy(Jumbo) -> ((BabyElephant(Jumbo) & -Mammal(Jumbo)) | (-BabyElephant(Jumbo) & Mammal(Jumbo)))"
        ],
        "conclusion": "Jumbo is a living being.",
        "conclusion-FOL": "LivingBeing(Jumbo)",
        "label": "ERROR"
    },
    {
        "premises": "All mammals are living beings.\nAll elephants are mammals.\nAll baby elephants are elephants.\nSome baby elephants are sleepy.\nIf Jumbo is a living being, then Jumbo is not both an elephant and a mammal.\nIf Jumbo is sleepy, then Jumbo is either a baby elephant or a mammal.",
        "premises-FOL": [
            "all x. (Mammal(x) -> LivingBeing(x)) \nall x. (Elephant(x) -> Mammal(x))\nall x. (BabyElephant(x) -> Elephant(x))\nexists x. (BabyElephant(x) & Sleepy(x))\nLivingBeing(Jumbo) -> -(Elephant(Jumbo) & Mammal(Jumbo))\nSleepy(Jumbo) -> ((BabyElephant(Jumbo) & -Mammal(Jumbo)) | (-BabyElephant(Jumbo) & Mammal(Jumbo)))"
        ],
        "conclusion": "Jumbo is neither sleepy nor a baby elephant.",
        "conclusion-FOL": "-Sleepy(Jumbo) & -BabyElephant(Jumbo))",
        "label": "ERROR"
    },
    {
        "premises": "All mammals are living beings.\nAll elephants are mammals.\nAll baby elephants are elephants.\nSome baby elephants are sleepy.\nIf Jumbo is a living being, then Jumbo is not both an elephant and a mammal.\nIf Jumbo is sleepy, then Jumbo is either a baby elephant or a mammal.",
        "premises-FOL": [
            "all x. (Mammal(x) -> LivingBeing(x)) \nall x. (Elephant(x) -> Mammal(x))\nall x. (BabyElephant(x) -> Elephant(x))\nexists x. (BabyElephant(x) & Sleepy(x))\nLivingBeing(Jumbo) -> -(Elephant(Jumbo) & Mammal(Jumbo))\nSleepy(Jumbo) -> ((BabyElephant(Jumbo) & -Mammal(Jumbo)) | (-BabyElephant(Jumbo) & Mammal(Jumbo)))"
        ],
        "conclusion": "Jumbo is not sleepy or an elephant.",
        "conclusion-FOL": "-(((Sleepy(Jumbo) & -Elephant(Jumbo)) | (-Sleepy(Jumbo) & Elephant(Jumbo))))",
        "label": "ERROR"
    },
    {
        "premises": "No planet in the solar system relies on nuclear fusion to generate light.\nAll stars in the solar system rely on nuclear fusion to generate light. \nAll celestial bodies in the solar systems that have greater than 0.08 solar masses are stars. \nIf a celestial body in the solar system has cleared its orbit of other debris and has a nearly spherical shape due to its own gravity, then it is a planet.\nIf Europa is a celestial body in the solar system that has cleared its orbit of other debris and has a nearly spherical shape due to its own gravity or relies on nuclear fusion to generate light, then Europa is a celestial body in the solar system. ",
        "premises-FOL": [
            "all x. (Planet(x) & In(x, SolarSystem) -> -RelyOnToGenerate(x, NuclearFusion, Light))\nall x. (Star(x) & In(x, SolarSystem) -> RelyOnToGenerate(x, NuclearFusion, Light))\nall x. (CelestialBody(x) & In(x, SolarSystem) & GreaterThan(x, SolarMass, ZeropointZeroEight) -> Star(x))\nall x. (CelestialBody(x) & In(x, SolarSystem) & (exists y. (OrbitOf(y, x) & Clear(x, y) & DebrisFree(y))) & NearlySphericalShape(x, Gravity) -> Planet(x))\n(CelestialBody(Europa) & In(Europa, SolarSystem) & (exists y. (OrbitOf(y, x) & Clear(x, y) & DebrisFree(y))) & NearlySphericalShape(Europa, Gravity)) | RelyOnToGenerate(Europa, NuclearFusion, Light) -> CelestialBody(Europa) & In(Europa, SolarSystem)"
        ],
        "conclusion": "Europa is a celestial body in the solar system has cleared its orbit of other debris and has a nearly spherical shape due to its own gravity.",
        "conclusion-FOL": "CelestialBody(Europa) & In(Europa, SolarSystem) & (exists y. (OrbitOf(y, x) & Clear(x, y) & DebrisFree(y))) & NearlySphericalShape(Europa, Gravity)",
        "label": "ERROR"
    },
    {
        "premises": "No planet in the solar system relies on nuclear fusion to generate light.\nAll stars in the solar system rely on nuclear fusion to generate light. \nAll celestial bodies in the solar systems that have greater than 0.08 solar masses are stars. \nIf a celestial body in the solar system has cleared its orbit of other debris and has a nearly spherical shape due to its own gravity, then it is a planet.\nIf Europa is a celestial body in the solar system that has cleared its orbit of other debris and has a nearly spherical shape due to its own gravity or relies on nuclear fusion to generate light, then Europa is a celestial body in the solar system. ",
        "premises-FOL": [
            "all x. (Planet(x) & In(x, SolarSystem) -> -RelyOnToGenerate(x, NuclearFusion, Light))\nall x. (Star(x) & In(x, SolarSystem) -> RelyOnToGenerate(x, NuclearFusion, Light))\nall x. (CelestialBody(x) & In(x, SolarSystem) & GreaterThan(x, SolarMass, ZeropointZeroEight) -> Star(x))\nall x. (CelestialBody(x) & In(x, SolarSystem) & (exists y. (OrbitOf(y, x) & Clear(x, y) & DebrisFree(y))) & NearlySphericalShape(x, Gravity) -> Planet(x))\n(CelestialBody(Europa) & In(Europa, SolarSystem) & (exists y. (OrbitOf(y, x) & Clear(x, y) & DebrisFree(y))) & NearlySphericalShape(Europa, Gravity)) | RelyOnToGenerate(Europa, NuclearFusion, Light) -> CelestialBody(Europa) & In(Europa, SolarSystem)"
        ],
        "conclusion": "Europa is a celestial body in one of the solar systems that have greater than 0.08 solar masses.",
        "conclusion-FOL": "CelestialBody(Europa) & In(Europa, SolarSystem) & GreaterThan(Europa, SolarMass, ZeroDotZeroEight)",
        "label": "ERROR"
    },
    {
        "premises": "No planet in the solar system relies on nuclear fusion to generate light.\nAll stars in the solar system rely on nuclear fusion to generate light. \nAll celestial bodies in the solar systems that have greater than 0.08 solar masses are stars. \nIf a celestial body in the solar system has cleared its orbit of other debris and has a nearly spherical shape due to its own gravity, then it is a planet.\nIf Europa is a celestial body in the solar system that has cleared its orbit of other debris and has a nearly spherical shape due to its own gravity or relies on nuclear fusion to generate light, then Europa is a celestial body in the solar system. ",
        "premises-FOL": [
            "all x. (Planet(x) & In(x, SolarSystem) -> -RelyOnToGenerate(x, NuclearFusion, Light))\nall x. (Star(x) & In(x, SolarSystem) -> RelyOnToGenerate(x, NuclearFusion, Light))\nall x. (CelestialBody(x) & In(x, SolarSystem) & GreaterThan(x, SolarMass, ZeropointZeroEight) -> Star(x))\nall x. (CelestialBody(x) & In(x, SolarSystem) & (exists y. (OrbitOf(y, x) & Clear(x, y) & DebrisFree(y))) & NearlySphericalShape(x, Gravity) -> Planet(x))\n(CelestialBody(Europa) & In(Europa, SolarSystem) & (exists y. (OrbitOf(y, x) & Clear(x, y) & DebrisFree(y))) & NearlySphericalShape(Europa, Gravity)) | RelyOnToGenerate(Europa, NuclearFusion, Light) -> CelestialBody(Europa) & In(Europa, SolarSystem)"
        ],
        "conclusion": "Europa is not a celestial body in one of the solar systems that have greater than 0.08 solar masses.",
        "conclusion-FOL": "-(CelestialBody(Europa) & In(Europa, SolarSystem) & GreaterThan(Europa, SolarMass, ZeroDotZeroEight))",
        "label": "ERROR"
    },
    {
        "premises": "If Max listens to music, he either listens to classical music or rap.\nAll the classical songs that Max listens to are from the 12th century. \nIf Max is listening to a rap song, then the song is by Kanye West. \nAll songs by Kanye West are full of lyrics. \nAll songs that are full of lyrics need to be written with words\nIt is not true that \u201cAs it was\u201d by Harry Styles is classical music that Max listens to and is from the 12th century.\nMax listens to \"As it was\" by Harry Styles.",
        "premises-FOL": [
            "all x. (MaxListenTo(x) -> (((ClassicalMusic(x) & -Rap(x)) | (-ClassicalMusic(x) & Rap(x)))))\nall x. (MaxListenTo(x) & ClassicalMusic(x) -> Song(x) & From(x, OneTwothCentury))\nall x. (MaxListenTo(x) & Rap(x) -> Song(x) & By(x, KanyeWest))\nall x. (Song(x) & By(x, KanyeWest) -> Song(x) & FullOfLyrics(x))\nall x. (Song(x) & FullOfLyrics(x) -> NeedToBeWrittenWith(x, Words))\n-(ClassicalMusic(AsItWasByHarryStyles) & Song(AsItWasByHarryStyles) & From(AsItWasByHarryStyles, OneTwothCentury))\nMaxListenTo(AsItWasByHarryStyles)"
        ],
        "conclusion": "\u201cAs it was\u201d by Harry Styles needs to be written with words.",
        "conclusion-FOL": "NeedToBeWrittenWith(AsItWasByHarryStyles, Words)",
        "label": "ERROR"
    },
    {
        "premises": "If Max listens to music, he either listens to classical music or rap.\nAll the classical songs that Max listens to are from the 12th century. \nIf Max is listening to a rap song, then the song is by Kanye West. \nAll songs by Kanye West are full of lyrics. \nAll songs that are full of lyrics need to be written with words\nIt is not true that \u201cAs it was\u201d by Harry Styles is classical music that Max listens to and is from the 12th century.\nMax listens to \"As it was\" by Harry Styles.",
        "premises-FOL": [
            "all x. (MaxListenTo(x) -> (((ClassicalMusic(x) & -Rap(x)) | (-ClassicalMusic(x) & Rap(x)))))\nall x. (MaxListenTo(x) & ClassicalMusic(x) -> Song(x) & From(x, OneTwothCentury))\nall x. (MaxListenTo(x) & Rap(x) -> Song(x) & By(x, KanyeWest))\nall x. (Song(x) & By(x, KanyeWest) -> Song(x) & FullOfLyrics(x))\nall x. (Song(x) & FullOfLyrics(x) -> NeedToBeWrittenWith(x, Words))\n-(ClassicalMusic(AsItWasByHarryStyles) & Song(AsItWasByHarryStyles) & From(AsItWasByHarryStyles, OneTwothCentury))\nMaxListenTo(AsItWasByHarryStyles)"
        ],
        "conclusion": "\"As it was\u201d by Harry Styles is a song from the 12th century.",
        "conclusion-FOL": "Song(AsItWasByHarryStyles) & From(AsItWasByHarryStyles, OneTwothCentury)",
        "label": "ERROR"
    },
    {
        "premises": "If Max listens to music, he either listens to classical music or rap.\nAll the classical songs that Max listens to are from the 12th century. \nIf Max is listening to a rap song, then the song is by Kanye West. \nAll songs by Kanye West are full of lyrics. \nAll songs that are full of lyrics need to be written with words\nIt is not true that \u201cAs it was\u201d by Harry Styles is classical music that Max listens to and is from the 12th century.\nMax listens to \"As it was\" by Harry Styles.",
        "premises-FOL": [
            "all x. (MaxListenTo(x) -> (((ClassicalMusic(x) & -Rap(x)) | (-ClassicalMusic(x) & Rap(x)))))\nall x. (MaxListenTo(x) & ClassicalMusic(x) -> Song(x) & From(x, OneTwothCentury))\nall x. (MaxListenTo(x) & Rap(x) -> Song(x) & By(x, KanyeWest))\nall x. (Song(x) & By(x, KanyeWest) -> Song(x) & FullOfLyrics(x))\nall x. (Song(x) & FullOfLyrics(x) -> NeedToBeWrittenWith(x, Words))\n-(ClassicalMusic(AsItWasByHarryStyles) & Song(AsItWasByHarryStyles) & From(AsItWasByHarryStyles, OneTwothCentury))\nMaxListenTo(AsItWasByHarryStyles)"
        ],
        "conclusion": "\"As it was\u201d by Harry Styles is not both a song from Kanye West and needed to be written with words.",
        "conclusion-FOL": "-(Song(AsItWasByHarryStyles) & By(AsItWasByHarryStyles, KanyeWest) & NeedToBeWrittenWith(AsItWasByHarryStyles, Words))",
        "label": "ERROR"
    },
    {
        "premises": "\"Your Woman\" is a song by the British one-person band White Town.\n\"Your Woman\" song peaked at No. 1 on the UK Singles Chart.\nIf a song peaked at No.1 at a particular place, it was extremely popular.\n\"Your Woman\" peaked at No. 1 in Iceland, Israel, and Spain.",
        "premises-FOL": [
            "Produce(WhiteTown, YourWoman) & OnePersonBand(WhiteTown)\nPeak(YourWoman, uKSinglesChart)\nall x. ((exists y.(Peak(x, y))) -> Popular(x))\nPeak(YourWoman, Iceland) & Peak(YourWoman, Israel) & Peak(YourWoman, Spain)"
        ],
        "conclusion": "\"Your Woman\" was extremely popular.",
        "conclusion-FOL": "Popular(YourWoman)",
        "label": "ERROR"
    },
    {
        "premises": "\"Your Woman\" is a song by the British one-person band White Town.\n\"Your Woman\" song peaked at No. 1 on the UK Singles Chart.\nIf a song peaked at No.1 at a particular place, it was extremely popular.\n\"Your Woman\" peaked at No. 1 in Iceland, Israel, and Spain.",
        "premises-FOL": [
            "Produce(WhiteTown, YourWoman) & OnePersonBand(WhiteTown)\nPeak(YourWoman, uKSinglesChart)\nall x. ((exists y.(Peak(x, y))) -> Popular(x))\nPeak(YourWoman, Iceland) & Peak(YourWoman, Israel) & Peak(YourWoman, Spain)"
        ],
        "conclusion": "White Town did not produce any popular songs.",
        "conclusion-FOL": "all x. (Produce(WhiteTown, x) -> -Popular(x))",
        "label": "ERROR"
    },
    {
        "premises": "\"Your Woman\" is a song by the British one-person band White Town.\n\"Your Woman\" song peaked at No. 1 on the UK Singles Chart.\nIf a song peaked at No.1 at a particular place, it was extremely popular.\n\"Your Woman\" peaked at No. 1 in Iceland, Israel, and Spain.",
        "premises-FOL": [
            "Produce(WhiteTown, YourWoman) & OnePersonBand(WhiteTown)\nPeak(YourWoman, uKSinglesChart)\nall x. ((exists y.(Peak(x, y))) -> Popular(x))\nPeak(YourWoman, Iceland) & Peak(YourWoman, Israel) & Peak(YourWoman, Spain)"
        ],
        "conclusion": "White Town was a successful band.",
        "conclusion-FOL": "Successful(WhiteTown)",
        "label": "ERROR"
    },
    {
        "premises": "\nAll functions that represent straight lines on the coordinate plane are linear functions. \nNo linear functions are non-convex functions.\nA function is either a non-convex fuction or a convex function.\nAll quasi-convex functions are real-valued functions.\nAll convex functions are quasi-convex functions. \nThe maximum of quasiconvex functions is a function.\nThe maximum of quasiconvex functions is a function that represents straight lines on the coordinate plane or it is a convex function or it is not a non-convex function.",
        "premises-FOL": [
            "all x. (Function(x) & RepresentOn(x, StraightLine, CoordinatePlane) -> LinearFunction(x))\nall x. (LinearFunction(x) -> -NonConvexFunction(x))\nall x. (Function(x) -> ((NonConvexFunction(x) & -ConvexFunction(x)) | (-NonConvexFunction(x) & ConvexFunction(x))))\nall x. (QuasiConvexFunction(x) -> RealValuedFunction(x))\nall x. (ConvexFunction(x) -> QuasiConvexFunction(x))\nFunction(MaximumOfQuasiConvexFunction)\n(Function(MaximumOfQuasiConvexFunction) & RepresentOn(MaximumOfQuasiConvexFunction, StraightLine, CoordinatePlane)) | ConvexFunction(MaximumOfQuasiConvexFunction) | -NonConvexFunction(MaximumOfQuasiConvexFunction)"
        ],
        "conclusion": "The maximum of quasiconvex functions is a function that represent straight lines on the coordinate plane.",
        "conclusion-FOL": "Function(MaximumOfQuasiConvexFunction) & RepresentOn(MaximumOfQuasiConvexFunction, StraightLine, CoordinatePlane)",
        "label": "ERROR"
    },
    {
        "premises": "\nAll functions that represent straight lines on the coordinate plane are linear functions. \nNo linear functions are non-convex functions.\nA function is either a non-convex fuction or a convex function.\nAll quasi-convex functions are real-valued functions.\nAll convex functions are quasi-convex functions. \nThe maximum of quasiconvex functions is a function.\nThe maximum of quasiconvex functions is a function that represents straight lines on the coordinate plane or it is a convex function or it is not a non-convex function.",
        "premises-FOL": [
            "all x. (Function(x) & RepresentOn(x, StraightLine, CoordinatePlane) -> LinearFunction(x))\nall x. (LinearFunction(x) -> -NonConvexFunction(x))\nall x. (Function(x) -> ((NonConvexFunction(x) & -ConvexFunction(x)) | (-NonConvexFunction(x) & ConvexFunction(x))))\nall x. (QuasiConvexFunction(x) -> RealValuedFunction(x))\nall x. (ConvexFunction(x) -> QuasiConvexFunction(x))\nFunction(MaximumOfQuasiConvexFunction)\n(Function(MaximumOfQuasiConvexFunction) & RepresentOn(MaximumOfQuasiConvexFunction, StraightLine, CoordinatePlane)) | ConvexFunction(MaximumOfQuasiConvexFunction) | -NonConvexFunction(MaximumOfQuasiConvexFunction)"
        ],
        "conclusion": "The maximum of quasiconvex functions is not a real-valued function.",
        "conclusion-FOL": "-RealValuedFunction(MaximumOfQuasiConvexFunction)",
        "label": "ERROR"
    },
    {
        "premises": "\nAll functions that represent straight lines on the coordinate plane are linear functions. \nNo linear functions are non-convex functions.\nA function is either a non-convex fuction or a convex function.\nAll quasi-convex functions are real-valued functions.\nAll convex functions are quasi-convex functions. \nThe maximum of quasiconvex functions is a function.\nThe maximum of quasiconvex functions is a function that represents straight lines on the coordinate plane or it is a convex function or it is not a non-convex function.",
        "premises-FOL": [
            "all x. (Function(x) & RepresentOn(x, StraightLine, CoordinatePlane) -> LinearFunction(x))\nall x. (LinearFunction(x) -> -NonConvexFunction(x))\nall x. (Function(x) -> ((NonConvexFunction(x) & -ConvexFunction(x)) | (-NonConvexFunction(x) & ConvexFunction(x))))\nall x. (QuasiConvexFunction(x) -> RealValuedFunction(x))\nall x. (ConvexFunction(x) -> QuasiConvexFunction(x))\nFunction(MaximumOfQuasiConvexFunction)\n(Function(MaximumOfQuasiConvexFunction) & RepresentOn(MaximumOfQuasiConvexFunction, StraightLine, CoordinatePlane)) | ConvexFunction(MaximumOfQuasiConvexFunction) | -NonConvexFunction(MaximumOfQuasiConvexFunction)"
        ],
        "conclusion": "The maximum of quasiconvex functions is a quasi-convex function or it is not a real-valued function.",
        "conclusion-FOL": "QuasiConvexFunction(MaximumOfQuasiConvexFunction) | -RealValuedFunction(MaximumOfQuasiConvexFunction)",
        "label": "ERROR"
    },
    {
        "premises": "If two soccer teams score the same number of goals in one UCL final during the regular time, they need to play for the extra time.\nIf two soccer teams score the same number of goals in one UCL final during both regular and extra time, they need to play the penalty shoot-out.\nReal Madrid and Atl\u00e9tico Madrid both scored one goal in the 2016 UCL final during the regular time.\nReal Madrid and Atl\u00e9tico Madrid both scored zero goals in the 2016 UCL final during the extra time.",
        "premises-FOL": [
            "all w. all x. all y. all z. (SoccerTeam(x) & SoccerTeam(y) & NumberOfGoalScored(x, z) & NumberOfGoalScored(y, w) & y=w & During(RegularTime) -> PlayExtra(x, y))\nall x. all y. (SoccerTeam(x) & SoccerTeam(y) & SameScore(x, y) & During(RegularTime) & During(ExtraTime) -> PlayPenalty(x, y))\nSoccerTeam(RealMadrid) & SoccerTeam(AtleticoMadrid) & SameScore(RealMadrid, AtleticoMadrid) & During(RegularTime)\nSoccerTeam(RealMadrid) & SoccerTeam(AtleticoMadrid) & SameScore(RealMadrid, AtleticoMadrid) & During(ExtraTime)"
        ],
        "conclusion": "Real Madrid and Atl\u00e9tico Madrid needed to play a penalty shoot-out in the 2016 UCL final.",
        "conclusion-FOL": "PlayPenalty(RealMadrid, AtleticoMadrid)",
        "label": "ERROR"
    },
    {
        "premises": "If two soccer teams score the same number of goals in one UCL final during the regular time, they need to play for the extra time.\nIf two soccer teams score the same number of goals in one UCL final during both regular and extra time, they need to play the penalty shoot-out.\nReal Madrid and Atl\u00e9tico Madrid both scored one goal in the 2016 UCL final during the regular time.\nReal Madrid and Atl\u00e9tico Madrid both scored zero goals in the 2016 UCL final during the extra time.",
        "premises-FOL": [
            "all w. all x. all y. all z. (SoccerTeam(x) & SoccerTeam(y) & NumberOfGoalScored(x, z) & NumberOfGoalScored(y, w) & y=w & During(RegularTime) -> PlayExtra(x, y))\nall x. all y. (SoccerTeam(x) & SoccerTeam(y) & SameScore(x, y) & During(RegularTime) & During(ExtraTime) -> PlayPenalty(x, y))\nSoccerTeam(RealMadrid) & SoccerTeam(AtleticoMadrid) & SameScore(RealMadrid, AtleticoMadrid) & During(RegularTime)\nSoccerTeam(RealMadrid) & SoccerTeam(AtleticoMadrid) & SameScore(RealMadrid, AtleticoMadrid) & During(ExtraTime)"
        ],
        "conclusion": "Real Madrid and Atl\u00e9tico Madrid did not need to play a penalty shoot-out in the 2016 UCL final.",
        "conclusion-FOL": "-PlayPenalty(RealMadrid, AtleticoMadrid)",
        "label": "ERROR"
    },
    {
        "premises": "System 7 is a UK-based electronic dance music band.\nSteve Hillage and Miquette Giraudy formed System 7.\nSteve Hillage and Miquette Giraudy are former members of the band Gong.\nElectric dance music bands are bands.\nSystem 7 has released several club singles.\nClub singles are not singles.",
        "premises-FOL": [
            "BasedIn(SystemSeven, Uk) & ElectronicDanceMusicBand(SystemSeven)\nForm(Stevehillage, SystemSeven) & Form(Miquettegiraudy, SystemSeven)\nFormerMemberOf(Stevehillage, Gong) & FormerMemberOf(Miquettegiraudy, Gong)\nall x. (ElectronicDanceMusicBand(x) -> Band(x))\nexists x. (ClubSingle(x) & Release(SystemSeven, x))\nall x. (ClubSingle(x) -> -Single(x))"
        ],
        "conclusion": "System 7 was formed by former members of Gong.",
        "conclusion-FOL": "exists x. (Form(x, SystemSeven) & FormerMemberOf(x, Gong))",
        "label": "ERROR"
    },
    {
        "premises": "System 7 is a UK-based electronic dance music band.\nSteve Hillage and Miquette Giraudy formed System 7.\nSteve Hillage and Miquette Giraudy are former members of the band Gong.\nElectric dance music bands are bands.\nSystem 7 has released several club singles.\nClub singles are not singles.",
        "premises-FOL": [
            "BasedIn(SystemSeven, Uk) & ElectronicDanceMusicBand(SystemSeven)\nForm(Stevehillage, SystemSeven) & Form(Miquettegiraudy, SystemSeven)\nFormerMemberOf(Stevehillage, Gong) & FormerMemberOf(Miquettegiraudy, Gong)\nall x. (ElectronicDanceMusicBand(x) -> Band(x))\nexists x. (ClubSingle(x) & Release(SystemSeven, x))\nall x. (ClubSingle(x) -> -Single(x))"
        ],
        "conclusion": "System 7 has released several singles.",
        "conclusion-FOL": "exists x. (Single(x) & Release(SystemSeven, x))",
        "label": "ERROR"
    },
    {
        "premises": "System 7 is a UK-based electronic dance music band.\nSteve Hillage and Miquette Giraudy formed System 7.\nSteve Hillage and Miquette Giraudy are former members of the band Gong.\nElectric dance music bands are bands.\nSystem 7 has released several club singles.\nClub singles are not singles.",
        "premises-FOL": [
            "BasedIn(SystemSeven, Uk) & ElectronicDanceMusicBand(SystemSeven)\nForm(Stevehillage, SystemSeven) & Form(Miquettegiraudy, SystemSeven)\nFormerMemberOf(Stevehillage, Gong) & FormerMemberOf(Miquettegiraudy, Gong)\nall x. (ElectronicDanceMusicBand(x) -> Band(x))\nexists x. (ClubSingle(x) & Release(SystemSeven, x))\nall x. (ClubSingle(x) -> -Single(x))"
        ],
        "conclusion": "System 7 is not a band.",
        "conclusion-FOL": "-Band(SystemSeven)",
        "label": "ERROR"
    },
    {
        "premises": "A summarization model is always faithful if it uses content from the input documents.\nExtractive models are summarization models.\nAn extractive model can only use content from the input documents.",
        "premises-FOL": [
            "all x. (Model(x) & Summarization(x) & OnlyUseInputDocument(x) -> Faithful(x))\nall x. (Model(x) & Extractive(x) -> Model(x) & Summarization(x))\nall x. (Model(x) & Extractive(x) -> OnlyUseInputDocument(x))"
        ],
        "conclusion": "Extractive models are always faithful.",
        "conclusion-FOL": "all x. (Model(x) & Extractive(x) -> Faithful(x))",
        "label": "ERROR"
    },
    {
        "premises": "A summarization model is always faithful if it uses content from the input documents.\nExtractive models are summarization models.\nAn extractive model can only use content from the input documents.",
        "premises-FOL": [
            "all x. (Model(x) & Summarization(x) & OnlyUseInputDocument(x) -> Faithful(x))\nall x. (Model(x) & Extractive(x) -> Model(x) & Summarization(x))\nall x. (Model(x) & Extractive(x) -> OnlyUseInputDocument(x))"
        ],
        "conclusion": "Extractive models are not always faithful.",
        "conclusion-FOL": "exists x. (Model(x) & Extractive(x) & -Faithful(x))",
        "label": "ERROR"
    },
    {
        "premises": "If Robin's friends practice coding questions, then they are not studying to go to medical school to become a doctor.\nIf Robin's friends want to work in the software engineering industry, then they practice coding questions.\nIf Robin's friends enjoy healthcare fields and want to help people with medical issues, then they are studying to go to medical school to become a doctor.\nIf Robin's friends grew up with parents who worked as doctors, then they enjoy healthcare fields and want to help people with medical issues.\nIf Robin's friends study hard, then they grew up with parents who worked as doctors.\nMark is Robin's friend.\nIf Mark neither enjoys healthcare fields and wants to help people with medical issues nor grew up with parents who worked as doctors, then Mark is either a person who studies hard or grew up with parents who worked as doctors.",
        "premises-FOL": [
            "all x. (RobinsFriends(x) & Practice(x, CodingQuestion) -> -StudyingToGoToToBecome(x, MedicalSchool, Doctor))\nall x. (RobinsFriends(x) & WantToWorkIn(x, SoftwareEngineeringIndustry) -> PracticeCodingQuestions(x))\nall x. (RobinsFriends(x) & Enjoy(x, HealthcareField) & WantToHelp(x, PeopleWithMedicalIssue) -> StudyingToGoToToBecome(x, MedicalSchool, Doctor))\nall x. (RobinsFriends(x) & (exists y. exists z. (-(y=z) & GrowUpWith(x, y) & GrowUpWith(x, z) & ParentOf(y, x) & ParentOf(z, x) & Doctor(y) & Doctor(z))) -> EnjoyHealthcareFields(x) & WantToHelp(x, PeopleWithMedicalIssue))\nall x. (RobinsFriends(x) & StudyHard(x) -> exists y. exists z. (-(y=z) & GrowUpWith(x, y) & GrowUpWith(x, z) & ParentOf(y, x) & ParentOf(z, x) & Doctor(y) & Doctor(z)))\nRobinsFriends(Mark)\n-((Enjoy(x, HealthcareField) & WantToHelp(Mark, PeopleWithMedicalIssues)) & -(exists y. exists z. (-(y=z) & GrowUpWith(x, y) & GrowUpWith(x, z) & ParentOf(y, x) & ParentOf(z, x) & Doctor(y) & Doctor(z))) -> StudyHard(Mark) | (exists y. exists z. (-(y=z) & GrowUpWith(x, y) & GrowUpWith(x, z) & ParentOf(y, x) & ParentOf(z, x) & Doctor(y) & Doctor(z)))"
        ],
        "conclusion": "Mark is Robin's friend and he is a person who studies hard.",
        "conclusion-FOL": "RobinsFriends(Mark) & StudyHard(Mark)",
        "label": "ERROR"
    },
    {
        "premises": "If Robin's friends practice coding questions, then they are not studying to go to medical school to become a doctor.\nIf Robin's friends want to work in the software engineering industry, then they practice coding questions.\nIf Robin's friends enjoy healthcare fields and want to help people with medical issues, then they are studying to go to medical school to become a doctor.\nIf Robin's friends grew up with parents who worked as doctors, then they enjoy healthcare fields and want to help people with medical issues.\nIf Robin's friends study hard, then they grew up with parents who worked as doctors.\nMark is Robin's friend.\nIf Mark neither enjoys healthcare fields and wants to help people with medical issues nor grew up with parents who worked as doctors, then Mark is either a person who studies hard or grew up with parents who worked as doctors.",
        "premises-FOL": [
            "all x. (RobinsFriends(x) & Practice(x, CodingQuestion) -> -StudyingToGoToToBecome(x, MedicalSchool, Doctor))\nall x. (RobinsFriends(x) & WantToWorkIn(x, SoftwareEngineeringIndustry) -> PracticeCodingQuestions(x))\nall x. (RobinsFriends(x) & Enjoy(x, HealthcareField) & WantToHelp(x, PeopleWithMedicalIssue) -> StudyingToGoToToBecome(x, MedicalSchool, Doctor))\nall x. (RobinsFriends(x) & (exists y. exists z. (-(y=z) & GrowUpWith(x, y) & GrowUpWith(x, z) & ParentOf(y, x) & ParentOf(z, x) & Doctor(y) & Doctor(z))) -> EnjoyHealthcareFields(x) & WantToHelp(x, PeopleWithMedicalIssue))\nall x. (RobinsFriends(x) & StudyHard(x) -> exists y. exists z. (-(y=z) & GrowUpWith(x, y) & GrowUpWith(x, z) & ParentOf(y, x) & ParentOf(z, x) & Doctor(y) & Doctor(z)))\nRobinsFriends(Mark)\n-((Enjoy(x, HealthcareField) & WantToHelp(Mark, PeopleWithMedicalIssues)) & -(exists y. exists z. (-(y=z) & GrowUpWith(x, y) & GrowUpWith(x, z) & ParentOf(y, x) & ParentOf(z, x) & Doctor(y) & Doctor(z))) -> StudyHard(Mark) | (exists y. exists z. (-(y=z) & GrowUpWith(x, y) & GrowUpWith(x, z) & ParentOf(y, x) & ParentOf(z, x) & Doctor(y) & Doctor(z)))"
        ],
        "conclusion": "Mark is Robin's friend and he practices coding questions and wants to work in the software engineering industry.",
        "conclusion-FOL": "RobinsFriends(Mark) & Practice(Mark, CodingQuestion) & WantToWorkIn(Mark, SoftwareEngineeringIndustry)",
        "label": "ERROR"
    },
    {
        "premises": "If Robin's friends practice coding questions, then they are not studying to go to medical school to become a doctor.\nIf Robin's friends want to work in the software engineering industry, then they practice coding questions.\nIf Robin's friends enjoy healthcare fields and want to help people with medical issues, then they are studying to go to medical school to become a doctor.\nIf Robin's friends grew up with parents who worked as doctors, then they enjoy healthcare fields and want to help people with medical issues.\nIf Robin's friends study hard, then they grew up with parents who worked as doctors.\nMark is Robin's friend.\nIf Mark neither enjoys healthcare fields and wants to help people with medical issues nor grew up with parents who worked as doctors, then Mark is either a person who studies hard or grew up with parents who worked as doctors.",
        "premises-FOL": [
            "all x. (RobinsFriends(x) & Practice(x, CodingQuestion) -> -StudyingToGoToToBecome(x, MedicalSchool, Doctor))\nall x. (RobinsFriends(x) & WantToWorkIn(x, SoftwareEngineeringIndustry) -> PracticeCodingQuestions(x))\nall x. (RobinsFriends(x) & Enjoy(x, HealthcareField) & WantToHelp(x, PeopleWithMedicalIssue) -> StudyingToGoToToBecome(x, MedicalSchool, Doctor))\nall x. (RobinsFriends(x) & (exists y. exists z. (-(y=z) & GrowUpWith(x, y) & GrowUpWith(x, z) & ParentOf(y, x) & ParentOf(z, x) & Doctor(y) & Doctor(z))) -> EnjoyHealthcareFields(x) & WantToHelp(x, PeopleWithMedicalIssue))\nall x. (RobinsFriends(x) & StudyHard(x) -> exists y. exists z. (-(y=z) & GrowUpWith(x, y) & GrowUpWith(x, z) & ParentOf(y, x) & ParentOf(z, x) & Doctor(y) & Doctor(z)))\nRobinsFriends(Mark)\n-((Enjoy(x, HealthcareField) & WantToHelp(Mark, PeopleWithMedicalIssues)) & -(exists y. exists z. (-(y=z) & GrowUpWith(x, y) & GrowUpWith(x, z) & ParentOf(y, x) & ParentOf(z, x) & Doctor(y) & Doctor(z))) -> StudyHard(Mark) | (exists y. exists z. (-(y=z) & GrowUpWith(x, y) & GrowUpWith(x, z) & ParentOf(y, x) & ParentOf(z, x) & Doctor(y) & Doctor(z)))"
        ],
        "conclusion": "Mark is Robin's friend and he neither practices coding questions nor works to work in the software engineering industry.",
        "conclusion-FOL": "RobinsFriends(Mark) & -(Practice(Mark, CodingQuestion) | WantToWorkIn(Mark, SoftwareEngineeringIndustry))",
        "label": "ERROR"
    },
    {
        "premises": "People who work at Jess's company and go to the spa frequently are not people who are miserly and need to save a large portion of their income.\nPeople who work at Jess's company are either miserly and need to save a large portion of their income, or frivolously spend a lot of money.\nIf people who work at Jess's company frivolously spend a lot of money when they go out, then they value quality manufacturing and luxury items.\nIf people who work at Jess's company value quality manufacturing and luxury items, then they enjoy shopping for materialistic items in their free time.\nThomas works at Jess's company.\nIf Thomas is not miserly and needs to save a large portion of his income, then Thomas does not value quality manufacturing and luxury items.\nThomas values quality manufacturing and luxury items or he is not miserly.",
        "premises-FOL": [
            "all x. (WorkAt(x, JesssCompany) & GoToSpafrequently(x) -> -(Miserly(x) & NeedToSave(x, aLargePortionOfIncome)))\nall x. (WorkAt(x, JesssCompany) -> Miserly(x) & NeedToSave(x, aLargePortionOfIncome)\u2295 SpendFrivolously(x, aLotOfMoney))\nall x. (WorkAt(x, JesssCompany) & SpendFrivolously(x, aLotOfMoney) -> Value(x, QualityManufacturing) & Value(x, LuxuryItem))\nall x. (WorkAt(x, JesssCompany) & Value(x, QualityManufacturing) & Value(x, LuxuryItem) -> Enjoy(x, Shopping, MaterialisticItem))\nWorkAt(Thomas, JesssCompany)\n-(Miserly(Thomas) & NeedToSave(Thomas, aLargePortionOfIncome)) -> -((Value(Thomas, QualityManufacturing) & Value(Thomas, LuxuryItem)))\n(Value(Thomas, QualityManufacturing) & Value(Thomas, LuxuryItem)) | -(Miserly(x) & NeedToSave(x, aLargePortionOfIncome))"
        ],
        "conclusion": "Thomas frivolously spends a lot of money.",
        "conclusion-FOL": "SpendFrivolously(Thomas, aLotOfMoney)",
        "label": "ERROR"
    },
    {
        "premises": "People who work at Jess's company and go to the spa frequently are not people who are miserly and need to save a large portion of their income.\nPeople who work at Jess's company are either miserly and need to save a large portion of their income, or frivolously spend a lot of money.\nIf people who work at Jess's company frivolously spend a lot of money when they go out, then they value quality manufacturing and luxury items.\nIf people who work at Jess's company value quality manufacturing and luxury items, then they enjoy shopping for materialistic items in their free time.\nThomas works at Jess's company.\nIf Thomas is not miserly and needs to save a large portion of his income, then Thomas does not value quality manufacturing and luxury items.\nThomas values quality manufacturing and luxury items or he is not miserly.",
        "premises-FOL": [
            "all x. (WorkAt(x, JesssCompany) & GoToSpafrequently(x) -> -(Miserly(x) & NeedToSave(x, aLargePortionOfIncome)))\nall x. (WorkAt(x, JesssCompany) -> Miserly(x) & NeedToSave(x, aLargePortionOfIncome)\u2295 SpendFrivolously(x, aLotOfMoney))\nall x. (WorkAt(x, JesssCompany) & SpendFrivolously(x, aLotOfMoney) -> Value(x, QualityManufacturing) & Value(x, LuxuryItem))\nall x. (WorkAt(x, JesssCompany) & Value(x, QualityManufacturing) & Value(x, LuxuryItem) -> Enjoy(x, Shopping, MaterialisticItem))\nWorkAt(Thomas, JesssCompany)\n-(Miserly(Thomas) & NeedToSave(Thomas, aLargePortionOfIncome)) -> -((Value(Thomas, QualityManufacturing) & Value(Thomas, LuxuryItem)))\n(Value(Thomas, QualityManufacturing) & Value(Thomas, LuxuryItem)) | -(Miserly(x) & NeedToSave(x, aLargePortionOfIncome))"
        ],
        "conclusion": "Thomas either enjoys shopping for materialistic items in his free time or, if he does not, then he goes to the spa frequently.",
        "conclusion-FOL": "((Enjoy(Thomas, Shopping, MaterialisticItem) & -GoToSpaFrequently(Thomas)) | (-Enjoy(Thomas, Shopping, MaterialisticItem) & GoToSpaFrequently(Thomas)))",
        "label": "ERROR"
    },
    {
        "premises": "People who work at Jess's company and go to the spa frequently are not people who are miserly and need to save a large portion of their income.\nPeople who work at Jess's company are either miserly and need to save a large portion of their income, or frivolously spend a lot of money.\nIf people who work at Jess's company frivolously spend a lot of money when they go out, then they value quality manufacturing and luxury items.\nIf people who work at Jess's company value quality manufacturing and luxury items, then they enjoy shopping for materialistic items in their free time.\nThomas works at Jess's company.\nIf Thomas is not miserly and needs to save a large portion of his income, then Thomas does not value quality manufacturing and luxury items.\nThomas values quality manufacturing and luxury items or he is not miserly.",
        "premises-FOL": [
            "all x. (WorkAt(x, JesssCompany) & GoToSpafrequently(x) -> -(Miserly(x) & NeedToSave(x, aLargePortionOfIncome)))\nall x. (WorkAt(x, JesssCompany) -> Miserly(x) & NeedToSave(x, aLargePortionOfIncome)\u2295 SpendFrivolously(x, aLotOfMoney))\nall x. (WorkAt(x, JesssCompany) & SpendFrivolously(x, aLotOfMoney) -> Value(x, QualityManufacturing) & Value(x, LuxuryItem))\nall x. (WorkAt(x, JesssCompany) & Value(x, QualityManufacturing) & Value(x, LuxuryItem) -> Enjoy(x, Shopping, MaterialisticItem))\nWorkAt(Thomas, JesssCompany)\n-(Miserly(Thomas) & NeedToSave(Thomas, aLargePortionOfIncome)) -> -((Value(Thomas, QualityManufacturing) & Value(Thomas, LuxuryItem)))\n(Value(Thomas, QualityManufacturing) & Value(Thomas, LuxuryItem)) | -(Miserly(x) & NeedToSave(x, aLargePortionOfIncome))"
        ],
        "conclusion": "If Thomas either enjoys shopping for materialistic items in his free time or, if he does not, then he goes to the spa frequently, then Thomas neither values quality manufacturing and luxury items nor goes to the spa frequently.",
        "conclusion-FOL": "((Enjoy(Thomas, Shopping, MaterialisticItem) & -GoToSpaFrequently(Thomas)) | (-Enjoy(Thomas, Shopping, MaterialisticItem) & GoToSpaFrequently(Thomas))) -> -((Value(x, QualityManufacturing) & Value(x, LuxuryItem)) | GoToSpaFrequently(Thomas))",
        "label": "ERROR"
    },
    {
        "premises": "The indie pop band Phoenix has released six albums. \nPhoenix's album \"Wolfgang Amadeus Phoenix\" sold over 500,000 copies. \nA certified gold album or single is one which sold over half a million copies. \n\"1901\" is a single from Phoenix's album \"Wolfgang Amadeus Phoenix.\"\nOver 400,000 copies of \"1901\" have been sold. ",
        "premises-FOL": [
            "AlbumsReleased(Phoenix, Six)\nAlbum(Wolfgangamadeusphoenix) & IsAlbumOf(Wolfgangamadeusphoenix, Phoenix) & SoldOver(Wolfgangamadeusphoenix, FiveZeroZero,ZeroZeroZero)\nall x. ((Album(x) | Single(x)) & SoldOver(x, FiveZeroZero,ZeroZeroZero) -> CertifiedGold(x))\nSingle(OneNineZeroOne) & From(OneNineZeroOne, Wolfgangamadeusphoenix) & By(OneNineZeroOne, Phoenix)\nSoldOver(lOneNineZeroOne, FourZeroZero,ZeroZeroZero)"
        ],
        "conclusion": "The album \"Wolfgang Amadeus Phoenix\" is a certified gold album.",
        "conclusion-FOL": "CertifiedGold(WolfgangamAdeusPhoenix)",
        "label": "ERROR"
    },
    {
        "premises": "The indie pop band Phoenix has released six albums. \nPhoenix's album \"Wolfgang Amadeus Phoenix\" sold over 500,000 copies. \nA certified gold album or single is one which sold over half a million copies. \n\"1901\" is a single from Phoenix's album \"Wolfgang Amadeus Phoenix.\"\nOver 400,000 copies of \"1901\" have been sold. ",
        "premises-FOL": [
            "AlbumsReleased(Phoenix, Six)\nAlbum(Wolfgangamadeusphoenix) & IsAlbumOf(Wolfgangamadeusphoenix, Phoenix) & SoldOver(Wolfgangamadeusphoenix, FiveZeroZero,ZeroZeroZero)\nall x. ((Album(x) | Single(x)) & SoldOver(x, FiveZeroZero,ZeroZeroZero) -> CertifiedGold(x))\nSingle(OneNineZeroOne) & From(OneNineZeroOne, Wolfgangamadeusphoenix) & By(OneNineZeroOne, Phoenix)\nSoldOver(lOneNineZeroOne, FourZeroZero,ZeroZeroZero)"
        ],
        "conclusion": "The single \"1901\" is a certified gold single.",
        "conclusion-FOL": "CertifiedGold(OneNineZeroOne)",
        "label": "ERROR"
    },
    {
        "premises": "Peter Parker is either a superhero or a civilian.\nThe Hulk is a destroyer.\nThe Hulk wakes up when he is angry.\nIf the Hulk wakes up, then he will break a bridge.\nThor is a god.\nThor will break a bridge when he is happy.\nA god is not a destroyer.\nPeter Parker wears a uniform when he is a superhero.\nPeter Parker is not a civilian if a destroyer is breaking a bridge.\nIf Thor is happy, the Hulk is angry.",
        "premises-FOL": [
            "((Superhero(PeterParker) & -Civilian(PeterParker)) | (-Superhero(PeterParker) & Civilian(PeterParker)))\nDestroyer(TheHulk)\nAngry(TheHulk) -> WakesUp(TheHulk)\nWakesUp(TheHulk) -> Breaks(TheHulk, Bridge)\nGod(Thor)\nHappy(Thor) -> Breaks(Thor, Bridge)\nall x. (God(x) -> -Destroyer(x))\nSuperhero(Peter) -> Wears(Peter, Uniform)\nall x. ((Destroyer(x) & Breaks(x,Bridge)) -> -Civilian(Peter))\nHappy(Thor) -> Angry(TheHulk)"
        ],
        "conclusion": "If the Hulk does not wake up, then Thor is not happy.",
        "conclusion-FOL": "-WakesUp(TheHulk) -> -Happy(Thor)",
        "label": "ERROR"
    },
    {
        "premises": "Peter Parker is either a superhero or a civilian.\nThe Hulk is a destroyer.\nThe Hulk wakes up when he is angry.\nIf the Hulk wakes up, then he will break a bridge.\nThor is a god.\nThor will break a bridge when he is happy.\nA god is not a destroyer.\nPeter Parker wears a uniform when he is a superhero.\nPeter Parker is not a civilian if a destroyer is breaking a bridge.\nIf Thor is happy, the Hulk is angry.",
        "premises-FOL": [
            "((Superhero(PeterParker) & -Civilian(PeterParker)) | (-Superhero(PeterParker) & Civilian(PeterParker)))\nDestroyer(TheHulk)\nAngry(TheHulk) -> WakesUp(TheHulk)\nWakesUp(TheHulk) -> Breaks(TheHulk, Bridge)\nGod(Thor)\nHappy(Thor) -> Breaks(Thor, Bridge)\nall x. (God(x) -> -Destroyer(x))\nSuperhero(Peter) -> Wears(Peter, Uniform)\nall x. ((Destroyer(x) & Breaks(x,Bridge)) -> -Civilian(Peter))\nHappy(Thor) -> Angry(TheHulk)"
        ],
        "conclusion": "If Thor is happy, then Peter Parker wears a uniform.",
        "conclusion-FOL": "Happy(Thor) -> Wears(PeterParker, Uniform)",
        "label": "ERROR"
    },
    {
        "premises": "Peter Parker is either a superhero or a civilian.\nThe Hulk is a destroyer.\nThe Hulk wakes up when he is angry.\nIf the Hulk wakes up, then he will break a bridge.\nThor is a god.\nThor will break a bridge when he is happy.\nA god is not a destroyer.\nPeter Parker wears a uniform when he is a superhero.\nPeter Parker is not a civilian if a destroyer is breaking a bridge.\nIf Thor is happy, the Hulk is angry.",
        "premises-FOL": [
            "((Superhero(PeterParker) & -Civilian(PeterParker)) | (-Superhero(PeterParker) & Civilian(PeterParker)))\nDestroyer(TheHulk)\nAngry(TheHulk) -> WakesUp(TheHulk)\nWakesUp(TheHulk) -> Breaks(TheHulk, Bridge)\nGod(Thor)\nHappy(Thor) -> Breaks(Thor, Bridge)\nall x. (God(x) -> -Destroyer(x))\nSuperhero(Peter) -> Wears(Peter, Uniform)\nall x. ((Destroyer(x) & Breaks(x,Bridge)) -> -Civilian(Peter))\nHappy(Thor) -> Angry(TheHulk)"
        ],
        "conclusion": "If Thor is not happy, then no bridge will be broken.",
        "conclusion-FOL": "-Happy(Thor) -> -Breaks(Thor, Bridge)",
        "label": "ERROR"
    },
    {
        "premises": "Diethylcarbamazine is a medication discovered in the year 1947.\nDiethylcarbamazine can be used to treat river blindness.\nThe only preferred treatment for river blindness is ivermectin.\nDiethylcarbamazine is not ivermectin.",
        "premises-FOL": [
            "Medication(Diethylcarbamazine) & DiscoversIn(Diethylcarbamazine, YrOneNineFourSeven)\nTreats(Diethylcarbamazine, RiverBlindness)\nPreferredTreatmentFor(RiverBlindness, Ivermectin)\n-(Is(Diethylcarbamazine, Ivermectin))"
        ],
        "conclusion": "Diethylcarbamazine is not preferred for the treatment of river blindness.",
        "conclusion-FOL": "-(PreferredTreatmentFor(RiverBlindness, Diethylcarbamazine))",
        "label": "ERROR"
    },
    {
        "premises": "Diethylcarbamazine is a medication discovered in the year 1947.\nDiethylcarbamazine can be used to treat river blindness.\nThe only preferred treatment for river blindness is ivermectin.\nDiethylcarbamazine is not ivermectin.",
        "premises-FOL": [
            "Medication(Diethylcarbamazine) & DiscoversIn(Diethylcarbamazine, YrOneNineFourSeven)\nTreats(Diethylcarbamazine, RiverBlindness)\nPreferredTreatmentFor(RiverBlindness, Ivermectin)\n-(Is(Diethylcarbamazine, Ivermectin))"
        ],
        "conclusion": "Diethylcarbamazine was often used to treat river blindness.",
        "conclusion-FOL": "Treats(Diethylcarbamazine, RiverBlindness)",
        "label": "ERROR"
    },
    {
        "premises": "Diethylcarbamazine is a medication discovered in the year 1947.\nDiethylcarbamazine can be used to treat river blindness.\nThe only preferred treatment for river blindness is ivermectin.\nDiethylcarbamazine is not ivermectin.",
        "premises-FOL": [
            "Medication(Diethylcarbamazine) & DiscoversIn(Diethylcarbamazine, YrOneNineFourSeven)\nTreats(Diethylcarbamazine, RiverBlindness)\nPreferredTreatmentFor(RiverBlindness, Ivermectin)\n-(Is(Diethylcarbamazine, Ivermectin))"
        ],
        "conclusion": "Diethylcarbamazine is used in the treatment of filariasis.",
        "conclusion-FOL": "Treats(Diethylcarbamazine, Filariasis)",
        "label": "ERROR"
    },
    {
        "premises": "All prime numbers are natural numbers.\nAll integers are real numbers. \nAll real numbers are complex numbers. \nOne is a prime number or a natural number or both.\nIf one is not a complex number, then one is a prime number and an integer.",
        "premises-FOL": [
            "all x. (PrimeNumber(x) -> NaturalNumber(x)) \nall x. (Integer(x) -> RealNumber(x))\nall x. (RealNumber(x) -> ComplexNumber(x)) \nPrimeNumber(One) | NaturalNumber(One)\n-ComplexNumber(One) -> (PrimeNumber(One) & Integer(One))"
        ],
        "conclusion": "One is a real number.",
        "conclusion-FOL": "RealNumber(One)",
        "label": "ERROR"
    },
    {
        "premises": "All prime numbers are natural numbers.\nAll integers are real numbers. \nAll real numbers are complex numbers. \nOne is a prime number or a natural number or both.\nIf one is not a complex number, then one is a prime number and an integer.",
        "premises-FOL": [
            "all x. (PrimeNumber(x) -> NaturalNumber(x)) \nall x. (Integer(x) -> RealNumber(x))\nall x. (RealNumber(x) -> ComplexNumber(x)) \nPrimeNumber(One) | NaturalNumber(One)\n-ComplexNumber(One) -> (PrimeNumber(One) & Integer(One))"
        ],
        "conclusion": "One is a prime number and a natural number.",
        "conclusion-FOL": "PrimeNumber(One) & NaturalNumber(One)",
        "label": "ERROR"
    },
    {
        "premises": "All prime numbers are natural numbers.\nAll integers are real numbers. \nAll real numbers are complex numbers. \nOne is a prime number or a natural number or both.\nIf one is not a complex number, then one is a prime number and an integer.",
        "premises-FOL": [
            "all x. (PrimeNumber(x) -> NaturalNumber(x)) \nall x. (Integer(x) -> RealNumber(x))\nall x. (RealNumber(x) -> ComplexNumber(x)) \nPrimeNumber(One) | NaturalNumber(One)\n-ComplexNumber(One) -> (PrimeNumber(One) & Integer(One))"
        ],
        "conclusion": "One is either a prime number or a natural number.",
        "conclusion-FOL": "PrimeNumber(One) \u2295  NaturalNumber(One)",
        "label": "ERROR"
    },
    {
        "premises": "If some diseases require a medical diagnosis, then lab tests or imaging is required. \nAll rare diseases require a medical diagnosis.\nIf a disease is mild, then no lab tests or imaging is required. \nAll blood cancers are rare diseases.\nAll types of leukemia are diseases and blood cancers. \nBladder cancer is a disease and is blood cancer or Leukemia.",
        "premises-FOL": [
            "all x. (Disease(x) & Require(x, MedicalDiagnosis) -> RequiredFor(LabTest, x) | RequiredFor(Imaging, x)) \nall x. (RareDisease(x) -> Require(x, MedicalDiagnosis))\nall x. (Disease(x) & Mild(x) -> -(RequiredFor(LabTest, x) | RequiredFor(Imaging, x))) \nall x. (BloodCancer(x) -> RareDiseases(x))\nall x. (Disease(x) & Leukemia(x) -> BloodCancer(x))\nDisease(BladderCancer) & (BloodCancer(BladderCancer) | Leukemia(BladderCancer))"
        ],
        "conclusion": "Bladder cancer is a mild disease.",
        "conclusion-FOL": "Mild(BladderCancer)",
        "label": "ERROR"
    },
    {
        "premises": "If some diseases require a medical diagnosis, then lab tests or imaging is required. \nAll rare diseases require a medical diagnosis.\nIf a disease is mild, then no lab tests or imaging is required. \nAll blood cancers are rare diseases.\nAll types of leukemia are diseases and blood cancers. \nBladder cancer is a disease and is blood cancer or Leukemia.",
        "premises-FOL": [
            "all x. (Disease(x) & Require(x, MedicalDiagnosis) -> RequiredFor(LabTest, x) | RequiredFor(Imaging, x)) \nall x. (RareDisease(x) -> Require(x, MedicalDiagnosis))\nall x. (Disease(x) & Mild(x) -> -(RequiredFor(LabTest, x) | RequiredFor(Imaging, x))) \nall x. (BloodCancer(x) -> RareDiseases(x))\nall x. (Disease(x) & Leukemia(x) -> BloodCancer(x))\nDisease(BladderCancer) & (BloodCancer(BladderCancer) | Leukemia(BladderCancer))"
        ],
        "conclusion": "Bladder cancer is Leukemia.",
        "conclusion-FOL": "Leukemia(BladderCancer)",
        "label": "ERROR"
    },
    {
        "premises": "If some diseases require a medical diagnosis, then lab tests or imaging is required. \nAll rare diseases require a medical diagnosis.\nIf a disease is mild, then no lab tests or imaging is required. \nAll blood cancers are rare diseases.\nAll types of leukemia are diseases and blood cancers. \nBladder cancer is a disease and is blood cancer or Leukemia.",
        "premises-FOL": [
            "all x. (Disease(x) & Require(x, MedicalDiagnosis) -> RequiredFor(LabTest, x) | RequiredFor(Imaging, x)) \nall x. (RareDisease(x) -> Require(x, MedicalDiagnosis))\nall x. (Disease(x) & Mild(x) -> -(RequiredFor(LabTest, x) | RequiredFor(Imaging, x))) \nall x. (BloodCancer(x) -> RareDiseases(x))\nall x. (Disease(x) & Leukemia(x) -> BloodCancer(x))\nDisease(BladderCancer) & (BloodCancer(BladderCancer) | Leukemia(BladderCancer))"
        ],
        "conclusion": "Bladder cancer is either a rare disease or a mild disease.",
        "conclusion-FOL": "((RareDisease(BladderCancer) & -Mild(BladderCancer)) | (-RareDisease(BladderCancer) & Mild(BladderCancer)))",
        "label": "ERROR"
    },
    {
        "premises": "There are no elements with atomic number between 61-63 that are not scarce in China.\nNon-rare earth elements are not scarce in China.\nAll elements are either non-rare earth elements or rare earth elements. \nAll rare earth elements can be used for industry.\nAll rare earth elements are essential for exploring future directions of electronics.\nLithium is either a non-rare earth element and essential for exploring future directions of electronics, or is not a non-rare earth element and is not essential for exploring future directions of electronics.",
        "premises-FOL": [
            "all x. ((Element(x) & exists y.(Between(y, NumSixOne, NumSixThree) & AtomicNumber(x, y))) -> ScarceIn(x, China))\nall x. (-RareEarthElement(x) -> -ScarceIn(x, China)) \nall x. (-((RareEarthElement(x) & -RareEarthElement(x)) | (-RareEarthElement(x) & RareEarthElement(x)))) \nall x. (RareEarthElement(x) -> UsedIn(x, Industry)) \nall x. (RareEarthElement(x) -> EssentialFor(x, Electronics))\n-(-((RareEarthElement(Lithium) & -EssentialFor(Lithium, Electronics)) | (-RareEarthElement(Lithium) & EssentialFor(Lithium, Electronics))))"
        ],
        "conclusion": "Lithium is a rare earth element.",
        "conclusion-FOL": "RareEarthElement(Lithium)",
        "label": "ERROR"
    },
    {
        "premises": "There are no elements with atomic number between 61-63 that are not scarce in China.\nNon-rare earth elements are not scarce in China.\nAll elements are either non-rare earth elements or rare earth elements. \nAll rare earth elements can be used for industry.\nAll rare earth elements are essential for exploring future directions of electronics.\nLithium is either a non-rare earth element and essential for exploring future directions of electronics, or is not a non-rare earth element and is not essential for exploring future directions of electronics.",
        "premises-FOL": [
            "all x. ((Element(x) & exists y.(Between(y, NumSixOne, NumSixThree) & AtomicNumber(x, y))) -> ScarceIn(x, China))\nall x. (-RareEarthElement(x) -> -ScarceIn(x, China)) \nall x. (-((RareEarthElement(x) & -RareEarthElement(x)) | (-RareEarthElement(x) & RareEarthElement(x)))) \nall x. (RareEarthElement(x) -> UsedIn(x, Industry)) \nall x. (RareEarthElement(x) -> EssentialFor(x, Electronics))\n-(-((RareEarthElement(Lithium) & -EssentialFor(Lithium, Electronics)) | (-RareEarthElement(Lithium) & EssentialFor(Lithium, Electronics))))"
        ],
        "conclusion": "Lithium is an element with atomic number between 61-63 and is used for batteries.",
        "conclusion-FOL": "Element(x) & exists y.(Between(y, NumSixOne, NumSixThree) & AtomicNumber(x, y)) & UsedFor(Lithium, Batteries)",
        "label": "ERROR"
    },
    {
        "premises": "There are no elements with atomic number between 61-63 that are not scarce in China.\nNon-rare earth elements are not scarce in China.\nAll elements are either non-rare earth elements or rare earth elements. \nAll rare earth elements can be used for industry.\nAll rare earth elements are essential for exploring future directions of electronics.\nLithium is either a non-rare earth element and essential for exploring future directions of electronics, or is not a non-rare earth element and is not essential for exploring future directions of electronics.",
        "premises-FOL": [
            "all x. ((Element(x) & exists y.(Between(y, NumSixOne, NumSixThree) & AtomicNumber(x, y))) -> ScarceIn(x, China))\nall x. (-RareEarthElement(x) -> -ScarceIn(x, China)) \nall x. (-((RareEarthElement(x) & -RareEarthElement(x)) | (-RareEarthElement(x) & RareEarthElement(x)))) \nall x. (RareEarthElement(x) -> UsedIn(x, Industry)) \nall x. (RareEarthElement(x) -> EssentialFor(x, Electronics))\n-(-((RareEarthElement(Lithium) & -EssentialFor(Lithium, Electronics)) | (-RareEarthElement(Lithium) & EssentialFor(Lithium, Electronics))))"
        ],
        "conclusion": "If Lithium is not essential for exploring future directions of electronics or an element with atomic number between 61-63, then Lithium is not a non-rare earth element or usable in industry.",
        "conclusion-FOL": "-(EssentialFor(Lithium, Electronics) \u2295 (exists y.(Between(y, NumSixOne, NumSixThree) & AtomicNumber(Lithium, y)))) -> -(-RareEarthMetals(Lithium) | UsedIn(Lithium, Industry))",
        "label": "ERROR"
    },
    {
        "premises": "If people don't often clean their homes, then they do not have tidy houses.\nIf people don't prioritize cleaning, then they do not often clean their homes.\nIf people hire a maid or cleaning service, then they have tidy houses.\nIf people don't care about cleanliness, then they do not prioritize cleaning.\nEither Jack does hire a maid or cleaning service and does not often clean his home, or he does not hire a maid or cleaning service nor often clean his home.",
        "premises-FOL": [
            "all x. (-CleanOften(x, Home) -> -Have(x, TidyHouse))\nall x. (-Prioritize(x, Cleaning) -> -CleanOften(x, Home))\nall x. (Hire(x, Maid) | Hire(x, CleaningService) -> Have(x, TidyHouse))\nall x. (-CareAbout(x, Cleanliness) -> -Prioritize(x, Cleaning))\n-(Hire(x, Maid) | Hire(x, CleaningService)) \u2295 -CleanOften(Jack, Home))"
        ],
        "conclusion": "Jack doesn't care about cleanliness.",
        "conclusion-FOL": "-(CareAbout(Jack, Cleanliness))",
        "label": "ERROR"
    },
    {
        "premises": "If people don't often clean their homes, then they do not have tidy houses.\nIf people don't prioritize cleaning, then they do not often clean their homes.\nIf people hire a maid or cleaning service, then they have tidy houses.\nIf people don't care about cleanliness, then they do not prioritize cleaning.\nEither Jack does hire a maid or cleaning service and does not often clean his home, or he does not hire a maid or cleaning service nor often clean his home.",
        "premises-FOL": [
            "all x. (-CleanOften(x, Home) -> -Have(x, TidyHouse))\nall x. (-Prioritize(x, Cleaning) -> -CleanOften(x, Home))\nall x. (Hire(x, Maid) | Hire(x, CleaningService) -> Have(x, TidyHouse))\nall x. (-CareAbout(x, Cleanliness) -> -Prioritize(x, Cleaning))\n-(Hire(x, Maid) | Hire(x, CleaningService)) \u2295 -CleanOften(Jack, Home))"
        ],
        "conclusion": "Jack does care about cleanliness.",
        "conclusion-FOL": "CareAbout(Jack, Cleanliness)",
        "label": "ERROR"
    },
    {
        "premises": "If people don't often clean their homes, then they do not have tidy houses.\nIf people don't prioritize cleaning, then they do not often clean their homes.\nIf people hire a maid or cleaning service, then they have tidy houses.\nIf people don't care about cleanliness, then they do not prioritize cleaning.\nEither Jack does hire a maid or cleaning service and does not often clean his home, or he does not hire a maid or cleaning service nor often clean his home.",
        "premises-FOL": [
            "all x. (-CleanOften(x, Home) -> -Have(x, TidyHouse))\nall x. (-Prioritize(x, Cleaning) -> -CleanOften(x, Home))\nall x. (Hire(x, Maid) | Hire(x, CleaningService) -> Have(x, TidyHouse))\nall x. (-CareAbout(x, Cleanliness) -> -Prioritize(x, Cleaning))\n-(Hire(x, Maid) | Hire(x, CleaningService)) \u2295 -CleanOften(Jack, Home))"
        ],
        "conclusion": "Jack has a tidy house.",
        "conclusion-FOL": "Have(Jack, TidyHouse)",
        "label": "ERROR"
    },
    {
        "premises": "If people don't often clean their homes, then they do not have tidy houses.\nIf people don't prioritize cleaning, then they do not often clean their homes.\nIf people hire a maid or cleaning service, then they have tidy houses.\nIf people don't care about cleanliness, then they do not prioritize cleaning.\nEither Jack does hire a maid or cleaning service and does not often clean his home, or he does not hire a maid or cleaning service nor often clean his home.",
        "premises-FOL": [
            "all x. (-CleanOften(x, Home) -> -Have(x, TidyHouse))\nall x. (-Prioritize(x, Cleaning) -> -CleanOften(x, Home))\nall x. (Hire(x, Maid) | Hire(x, CleaningService) -> Have(x, TidyHouse))\nall x. (-CareAbout(x, Cleanliness) -> -Prioritize(x, Cleaning))\n-(Hire(x, Maid) | Hire(x, CleaningService)) \u2295 -CleanOften(Jack, Home))"
        ],
        "conclusion": "Jack neither lives in the suburbs nor is too busy to clean.",
        "conclusion-FOL": "-(-CareAbout(Jack, Cleanliness) | -CleanOften(Jack, Home)",
        "label": "ERROR"
    },
    {
        "premises": "If people don't often clean their homes, then they do not have tidy houses.\nIf people don't prioritize cleaning, then they do not often clean their homes.\nIf people hire a maid or cleaning service, then they have tidy houses.\nIf people don't care about cleanliness, then they do not prioritize cleaning.\nEither Jack does hire a maid or cleaning service and does not often clean his home, or he does not hire a maid or cleaning service nor often clean his home.",
        "premises-FOL": [
            "all x. (-CleanOften(x, Home) -> -Have(x, TidyHouse))\nall x. (-Prioritize(x, Cleaning) -> -CleanOften(x, Home))\nall x. (Hire(x, Maid) | Hire(x, CleaningService) -> Have(x, TidyHouse))\nall x. (-CareAbout(x, Cleanliness) -> -Prioritize(x, Cleaning))\n-(Hire(x, Maid) | Hire(x, CleaningService)) \u2295 -CleanOften(Jack, Home))"
        ],
        "conclusion": "Jack is overburdened and lives in the suburbs.",
        "conclusion-FOL": "-Prioritize(Jack, Cleaning) | -CareAbout(Jack, Cleanliness)",
        "label": "ERROR"
    },
    {
        "premises": "The bottle not falling is either standing upright or toppled over. \nThe bottle not falling is not standing upright.",
        "premises-FOL": [
            "-Falling(Bottle) -> (((Upright(Bottle) & -ToppledOver(Bottle)) | (-Upright(Bottle) & ToppledOver(Bottle))))\n-Falling(Bottle) -> -Upright(Bottle)"
        ],
        "conclusion": "The bottle not falling is toppled over.",
        "conclusion-FOL": "-Falling(Bottle) -> ToppleOver(Bottle)",
        "label": "ERROR"
    },
    {
        "premises": "Everyone who chooses what they want to do with their time has flexible schedules.\nEveryone with a lot of free time chooses what they want to do with their time.\nPeople either have a lot of free time or they invest in a career in which they are willing to spend the rest of their lives.\nIf people invest in a career in which they are willing to spend the rest of their lives, then they are hardworking individuals with high ambitions and goals for the future.  \nIf people are hardworking individuals with high ambitions and goals for the future, then they are not short sighted.\nJohn is not either a hardworking individual with high ambitions and goals for the future or has a flexible schedule.",
        "premises-FOL": [
            "all x. (ChooseWhatToDoWith(x, Time) -> FlexibleSchedule(x))\nall x. (Have(x, LotsOfFreetime) -> ChooseWhatToDoWith(x, Time))\nall x. (Have(x, LotsOfFreetime) \u2295 (exists y. (InvestIn(x, y) & Career(y) & WillingToSpendIn(RestOfLife, y))))\nall x. (exists y. (InvestIn(x, y) & Career(y) & WillingToSpendIn(RestOfLife, y)) -> Hardworking(x))\nall x. (Hardworking(x) & HaveFor(x, HighAmbition, Future) & HaveFor(x, Goal, Future) -> -ShortSighted(x))\n-((Hardworking(John) & HaveFor(John, HighAmbition, Future) & HaveFor(John, Goal, Future)) \u2295 FlexibleSchedule(John))"
        ],
        "conclusion": "John is short sighted.",
        "conclusion-FOL": "Organized(John)",
        "label": "ERROR"
    },
    {
        "premises": "Everyone who chooses what they want to do with their time has flexible schedules.\nEveryone with a lot of free time chooses what they want to do with their time.\nPeople either have a lot of free time or they invest in a career in which they are willing to spend the rest of their lives.\nIf people invest in a career in which they are willing to spend the rest of their lives, then they are hardworking individuals with high ambitions and goals for the future.  \nIf people are hardworking individuals with high ambitions and goals for the future, then they are not short sighted.\nJohn is not either a hardworking individual with high ambitions and goals for the future or has a flexible schedule.",
        "premises-FOL": [
            "all x. (ChooseWhatToDoWith(x, Time) -> FlexibleSchedule(x))\nall x. (Have(x, LotsOfFreetime) -> ChooseWhatToDoWith(x, Time))\nall x. (Have(x, LotsOfFreetime) \u2295 (exists y. (InvestIn(x, y) & Career(y) & WillingToSpendIn(RestOfLife, y))))\nall x. (exists y. (InvestIn(x, y) & Career(y) & WillingToSpendIn(RestOfLife, y)) -> Hardworking(x))\nall x. (Hardworking(x) & HaveFor(x, HighAmbition, Future) & HaveFor(x, Goal, Future) -> -ShortSighted(x))\n-((Hardworking(John) & HaveFor(John, HighAmbition, Future) & HaveFor(John, Goal, Future)) \u2295 FlexibleSchedule(John))"
        ],
        "conclusion": "John chooses what he want to do with his time.",
        "conclusion-FOL": "ChooseWhatToDoWith(John, Time)",
        "label": "ERROR"
    },
    {
        "premises": "Everyone who chooses what they want to do with their time has flexible schedules.\nEveryone with a lot of free time chooses what they want to do with their time.\nPeople either have a lot of free time or they invest in a career in which they are willing to spend the rest of their lives.\nIf people invest in a career in which they are willing to spend the rest of their lives, then they are hardworking individuals with high ambitions and goals for the future.  \nIf people are hardworking individuals with high ambitions and goals for the future, then they are not short sighted.\nJohn is not either a hardworking individual with high ambitions and goals for the future or has a flexible schedule.",
        "premises-FOL": [
            "all x. (ChooseWhatToDoWith(x, Time) -> FlexibleSchedule(x))\nall x. (Have(x, LotsOfFreetime) -> ChooseWhatToDoWith(x, Time))\nall x. (Have(x, LotsOfFreetime) \u2295 (exists y. (InvestIn(x, y) & Career(y) & WillingToSpendIn(RestOfLife, y))))\nall x. (exists y. (InvestIn(x, y) & Career(y) & WillingToSpendIn(RestOfLife, y)) -> Hardworking(x))\nall x. (Hardworking(x) & HaveFor(x, HighAmbition, Future) & HaveFor(x, Goal, Future) -> -ShortSighted(x))\n-((Hardworking(John) & HaveFor(John, HighAmbition, Future) & HaveFor(John, Goal, Future)) \u2295 FlexibleSchedule(John))"
        ],
        "conclusion": "John is either a hardworking individual with high ambitions and goals for the future or is short sighted.",
        "conclusion-FOL": "(Hardworking(John) & HaveFor(John, HighAmbition, Future) & HaveFor(John, Goal, Future)) \u2295 ShortSighted(John)",
        "label": "ERROR"
    },
    {
        "premises": "Ableton has an office in Germany.\nAbleton has an office in the USA.\nUSA and Germany are different countries.\nAny company that has offices in different countries is a multinational company.\nAbleton makes music software.",
        "premises-FOL": [
            "OfficeIn(Ableton, Germany)\nOfficeIn(Ableton, UnitedStates)\n-SameCountry(Germany, UnitedStates)\nall x. all y. all z. (OfficeIn(x, y) & OfficeIn(x, z) & (-SameCountry(y, z)) -> MultinationalCompany(x))\nMakesMusicSoftware(Ableton)"
        ],
        "conclusion": "Ableton is a multinational company.",
        "conclusion-FOL": "MultinationalCompany(Ableton)",
        "label": "ERROR"
    },
    {
        "premises": "Ableton has an office in Germany.\nAbleton has an office in the USA.\nUSA and Germany are different countries.\nAny company that has offices in different countries is a multinational company.\nAbleton makes music software.",
        "premises-FOL": [
            "OfficeIn(Ableton, Germany)\nOfficeIn(Ableton, UnitedStates)\n-SameCountry(Germany, UnitedStates)\nall x. all y. all z. (OfficeIn(x, y) & OfficeIn(x, z) & (-SameCountry(y, z)) -> MultinationalCompany(x))\nMakesMusicSoftware(Ableton)"
        ],
        "conclusion": "Ableton makes AI software.",
        "conclusion-FOL": "MakesAISoftware(Ableton)",
        "label": "ERROR"
    },
    {
        "premises": "Ableton has an office in Germany.\nAbleton has an office in the USA.\nUSA and Germany are different countries.\nAny company that has offices in different countries is a multinational company.\nAbleton makes music software.",
        "premises-FOL": [
            "OfficeIn(Ableton, Germany)\nOfficeIn(Ableton, UnitedStates)\n-SameCountry(Germany, UnitedStates)\nall x. all y. all z. (OfficeIn(x, y) & OfficeIn(x, z) & (-SameCountry(y, z)) -> MultinationalCompany(x))\nMakesMusicSoftware(Ableton)"
        ],
        "conclusion": "Ableton does not have an office in Germany.",
        "conclusion-FOL": "-OfficeIn(Ableton, Germany)",
        "label": "ERROR"
    },
    {
        "premises": "Those who can fly over a vast distance glide in the air. \nFlightless birds cannot fly over a vast distance. \nPenguins are flightless birds. \nNonflying birds in Antarctica are penguins. \nFido is a penguin, or flies over a vast distance. ",
        "premises-FOL": [
            "all x. (FlyOver(x, VastDistance) -> GlideInAir(x))\nall x. (Flightless(x) & Bird(x) -> -FlyOver(x, VastDistance))\nall x. (Penguin(x) -> Flightless(x) & Bird(x))\nall x. (NonFlying(x) & Bird(x) & In(x, Antarctica) -> Penguin(x))\nPenguin(Fido) | FlyOver(Fido, VastDistance)"
        ],
        "conclusion": "Fido is a flightless bird",
        "conclusion-FOL": "Flightless(Fido) & Bird(Fido)",
        "label": "ERROR"
    },
    {
        "premises": "Those who can fly over a vast distance glide in the air. \nFlightless birds cannot fly over a vast distance. \nPenguins are flightless birds. \nNonflying birds in Antarctica are penguins. \nFido is a penguin, or flies over a vast distance. ",
        "premises-FOL": [
            "all x. (FlyOver(x, VastDistance) -> GlideInAir(x))\nall x. (Flightless(x) & Bird(x) -> -FlyOver(x, VastDistance))\nall x. (Penguin(x) -> Flightless(x) & Bird(x))\nall x. (NonFlying(x) & Bird(x) & In(x, Antarctica) -> Penguin(x))\nPenguin(Fido) | FlyOver(Fido, VastDistance)"
        ],
        "conclusion": "Fido is not a nonflying bird in Antarctica, and he cannot glid in the air.",
        "conclusion-FOL": "-(NonFlying(Fido) & Bird(Fido) & In(Fido, Antarctica)) & -GlideInAir(Fido)",
        "label": "ERROR"
    },
    {
        "premises": "Those who can fly over a vast distance glide in the air. \nFlightless birds cannot fly over a vast distance. \nPenguins are flightless birds. \nNonflying birds in Antarctica are penguins. \nFido is a penguin, or flies over a vast distance. ",
        "premises-FOL": [
            "all x. (FlyOver(x, VastDistance) -> GlideInAir(x))\nall x. (Flightless(x) & Bird(x) -> -FlyOver(x, VastDistance))\nall x. (Penguin(x) -> Flightless(x) & Bird(x))\nall x. (NonFlying(x) & Bird(x) & In(x, Antarctica) -> Penguin(x))\nPenguin(Fido) | FlyOver(Fido, VastDistance)"
        ],
        "conclusion": "If Fido either can fly over a vast distance or cannot fly over a vast distance, then Fido is a nonflying bird in Antartica.",
        "conclusion-FOL": "(FlyOver(Fido, VastDistance) \u2295 -FlyOver(Fido, VastDistance)) -> (NonFlying(Fido) & Bird(Fido) & In(Fido, Antarctica))",
        "label": "ERROR"
    },
    {
        "premises": "All members of the university faculty are professors.\nAll principal investigators are members of the university faculty.\nNo professor is also an undergraduate student.\nAnyone pursuing a bachelor's degree is an undergraduate student.\nLeon is not pursuing a bachelor's degree, and he is not a principal investigator.\nIf Leon is not pursuing a bachelor's degree, then he is a professor.",
        "premises-FOL": [
            "all x. (MemberOf(x, UniversityFaculty) -> Professor(x))\nall x. (PrincipalInvestigator(x) -> MemberOf(x, UniversityFaculty))\nall x. (Professor(x) -> -UndergraduateStudent(x))\nall x. (Pursuing(x, Bachelor) -> UndergraduateStudent(x))\n-(((Pursuing(Leon, Bachelor) & -PrincipalInvestigator(Leon)) | (-Pursuing(Leon, Bachelor) & PrincipalInvestigator(Leon))))\n-Pursuing(Leon, Bachelor) -> Professor(Leon)"
        ],
        "conclusion": "Leon is a member of university faculty.",
        "conclusion-FOL": "MemberOf(Leon, UniversityFaculty)",
        "label": "ERROR"
    },
    {
        "premises": "All members of the university faculty are professors.\nAll principal investigators are members of the university faculty.\nNo professor is also an undergraduate student.\nAnyone pursuing a bachelor's degree is an undergraduate student.\nLeon is not pursuing a bachelor's degree, and he is not a principal investigator.\nIf Leon is not pursuing a bachelor's degree, then he is a professor.",
        "premises-FOL": [
            "all x. (MemberOf(x, UniversityFaculty) -> Professor(x))\nall x. (PrincipalInvestigator(x) -> MemberOf(x, UniversityFaculty))\nall x. (Professor(x) -> -UndergraduateStudent(x))\nall x. (Pursuing(x, Bachelor) -> UndergraduateStudent(x))\n-(((Pursuing(Leon, Bachelor) & -PrincipalInvestigator(Leon)) | (-Pursuing(Leon, Bachelor) & PrincipalInvestigator(Leon))))\n-Pursuing(Leon, Bachelor) -> Professor(Leon)"
        ],
        "conclusion": "Leon is neither an undergraduate student nor a principal investigator.",
        "conclusion-FOL": "-UndergraduateStudent(Leon) & -PrincipalInvestigator(Leon)",
        "label": "ERROR"
    },
    {
        "premises": "All members of the university faculty are professors.\nAll principal investigators are members of the university faculty.\nNo professor is also an undergraduate student.\nAnyone pursuing a bachelor's degree is an undergraduate student.\nLeon is not pursuing a bachelor's degree, and he is not a principal investigator.\nIf Leon is not pursuing a bachelor's degree, then he is a professor.",
        "premises-FOL": [
            "all x. (MemberOf(x, UniversityFaculty) -> Professor(x))\nall x. (PrincipalInvestigator(x) -> MemberOf(x, UniversityFaculty))\nall x. (Professor(x) -> -UndergraduateStudent(x))\nall x. (Pursuing(x, Bachelor) -> UndergraduateStudent(x))\n-(((Pursuing(Leon, Bachelor) & -PrincipalInvestigator(Leon)) | (-Pursuing(Leon, Bachelor) & PrincipalInvestigator(Leon))))\n-Pursuing(Leon, Bachelor) -> Professor(Leon)"
        ],
        "conclusion": "If leon is not a principal investigator, then Leon is an undergraduate student.",
        "conclusion-FOL": "-PrincipalInvestigator(Leon) -> UndergraduateStudent(Leon)",
        "label": "ERROR"
    },
    {
        "premises": "A cutman is responsible for preventing and treating physical damage to a fighter.\nCutmen appear in boxing matches, kickboxing matches, or mixed martial arts matches bout. \nCutmen handle swelling, nosebleeds and lacerations. \nJack is a cutman.",
        "premises-FOL": [
            "all x. (Cutman(x) -> Prevent(x, PhysicalDamageToAFighter) & Treat(x, PhysicalDamageToAFighter))\nall x. (Cutman(x) -> AppearIn(x, BoxingMatch) | AppearIn(x, KickboxingMatch) | AppearIn(x, MixedMartialArtsMatchBout))\nall x. (Cutman(x) -> Handle(x, Swelling) & Handle(x, Nosebleed) & Handle(x, Laceration))\nCutman(Jack)"
        ],
        "conclusion": "No cutmen appear in boxing matches.",
        "conclusion-FOL": "-(exists x. (Cutman(x) & AppearIn(x, BoxingMatch)))",
        "label": "ERROR"
    },
    {
        "premises": "A cutman is responsible for preventing and treating physical damage to a fighter.\nCutmen appear in boxing matches, kickboxing matches, or mixed martial arts matches bout. \nCutmen handle swelling, nosebleeds and lacerations. \nJack is a cutman.",
        "premises-FOL": [
            "all x. (Cutman(x) -> Prevent(x, PhysicalDamageToAFighter) & Treat(x, PhysicalDamageToAFighter))\nall x. (Cutman(x) -> AppearIn(x, BoxingMatch) | AppearIn(x, KickboxingMatch) | AppearIn(x, MixedMartialArtsMatchBout))\nall x. (Cutman(x) -> Handle(x, Swelling) & Handle(x, Nosebleed) & Handle(x, Laceration))\nCutman(Jack)"
        ],
        "conclusion": "If someone is not a cutman, then they cannot handle nosebleeds.",
        "conclusion-FOL": "all x. (-Cutman(x) -> -Handle(x, Nosebleed))",
        "label": "ERROR"
    },
    {
        "premises": "A cutman is responsible for preventing and treating physical damage to a fighter.\nCutmen appear in boxing matches, kickboxing matches, or mixed martial arts matches bout. \nCutmen handle swelling, nosebleeds and lacerations. \nJack is a cutman.",
        "premises-FOL": [
            "all x. (Cutman(x) -> Prevent(x, PhysicalDamageToAFighter) & Treat(x, PhysicalDamageToAFighter))\nall x. (Cutman(x) -> AppearIn(x, BoxingMatch) | AppearIn(x, KickboxingMatch) | AppearIn(x, MixedMartialArtsMatchBout))\nall x. (Cutman(x) -> Handle(x, Swelling) & Handle(x, Nosebleed) & Handle(x, Laceration))\nCutman(Jack)"
        ],
        "conclusion": "Jack is responsible for treating physical damage to a fighter.",
        "conclusion-FOL": "Treat(Jack, PhysicalDamageToAFighter)",
        "label": "ERROR"
    },
    {
        "premises": "The Mona Lisa is a world's best-known painting.\nThe Mona Lisa is a portrait painted by Leonardo da Vinci.\nLeonardo da Vinci was a scientist and painter.\nPainting genres can be history, portrait, animal, landscape, and still life.",
        "premises-FOL": [
            "Painting(MonaLisa) & TheWorldsBestKnown(MonaLisa)\nPaintedBy(MonaLisa, LeonardodaVinci) & Portrait(MonaLisa)\nScientist(LeonardodaVinci) & Painter(LeonardodaVinci)\nall x. (Painting(x) -> (History(x) | Portrait(x) | Animal(x) | Landscape(x) | StillLife(x)))"
        ],
        "conclusion": "A world's best-known artwork is painted by a scientist.",
        "conclusion-FOL": "exists x. exists y. (Painting(x) & TheWorldsBestKnown(x) & PaintedBy(x, y) & Scientist(y))",
        "label": "ERROR"
    },
    {
        "premises": "The Mona Lisa is a world's best-known painting.\nThe Mona Lisa is a portrait painted by Leonardo da Vinci.\nLeonardo da Vinci was a scientist and painter.\nPainting genres can be history, portrait, animal, landscape, and still life.",
        "premises-FOL": [
            "Painting(MonaLisa) & TheWorldsBestKnown(MonaLisa)\nPaintedBy(MonaLisa, LeonardodaVinci) & Portrait(MonaLisa)\nScientist(LeonardodaVinci) & Painter(LeonardodaVinci)\nall x. (Painting(x) -> (History(x) | Portrait(x) | Animal(x) | Landscape(x) | StillLife(x)))"
        ],
        "conclusion": "Leonardo da Vinci has artworks in the landscape genre.",
        "conclusion-FOL": "exists x. (PaintedBy(x, LeonardodaVinci) & Landscape(x))",
        "label": "ERROR"
    },
    {
        "premises": "The Mona Lisa is a world's best-known painting.\nThe Mona Lisa is a portrait painted by Leonardo da Vinci.\nLeonardo da Vinci was a scientist and painter.\nPainting genres can be history, portrait, animal, landscape, and still life.",
        "premises-FOL": [
            "Painting(MonaLisa) & TheWorldsBestKnown(MonaLisa)\nPaintedBy(MonaLisa, LeonardodaVinci) & Portrait(MonaLisa)\nScientist(LeonardodaVinci) & Painter(LeonardodaVinci)\nall x. (Painting(x) -> (History(x) | Portrait(x) | Animal(x) | Landscape(x) | StillLife(x)))"
        ],
        "conclusion": "No world's best-known artworks are portraits.",
        "conclusion-FOL": "all x. (WorldsBestKnown(x)  -> -Portrait(x))",
        "label": "ERROR"
    },
    {
        "premises": "No professional tennis umpires are professional tennis players.\nIf you are a World Tour player, then you are a professional tennis player.\nAll Grand Slam champions are World Tour players.\nAll Grand Slam umpires are professional tennis umpires.\nNadal is a World Tour player or a Grand Slam champion",
        "premises-FOL": [
            "all x. (ProfessionalTennisUmpire(x) -> -ProfessionalTennisPlayer(x))\nall x. (WorldTourPlayer(x) -> ProfessionalTennisPlayer(x))\nall x. (GrandSlamChampion(x) -> WorldTourPlayer(x))\nall x. (GrandSlamUmpire(x) -> ProfessionalTennisUmpire(x))\nWorldTourPlayer(Nadal) | GrandSlamChampion(Nadal)"
        ],
        "conclusion": "Nadal is a Grand Slam umpire.",
        "conclusion-FOL": "GrandSlamUmpire(Nadal)",
        "label": "ERROR"
    },
    {
        "premises": "No professional tennis umpires are professional tennis players.\nIf you are a World Tour player, then you are a professional tennis player.\nAll Grand Slam champions are World Tour players.\nAll Grand Slam umpires are professional tennis umpires.\nNadal is a World Tour player or a Grand Slam champion",
        "premises-FOL": [
            "all x. (ProfessionalTennisUmpire(x) -> -ProfessionalTennisPlayer(x))\nall x. (WorldTourPlayer(x) -> ProfessionalTennisPlayer(x))\nall x. (GrandSlamChampion(x) -> WorldTourPlayer(x))\nall x. (GrandSlamUmpire(x) -> ProfessionalTennisUmpire(x))\nWorldTourPlayer(Nadal) | GrandSlamChampion(Nadal)"
        ],
        "conclusion": "Nadal is not a Grand Slam umpire.",
        "conclusion-FOL": "-GrandSlamUmpire(Nadal)",
        "label": "ERROR"
    },
    {
        "premises": "No professional tennis umpires are professional tennis players.\nIf you are a World Tour player, then you are a professional tennis player.\nAll Grand Slam champions are World Tour players.\nAll Grand Slam umpires are professional tennis umpires.\nNadal is a World Tour player or a Grand Slam champion",
        "premises-FOL": [
            "all x. (ProfessionalTennisUmpire(x) -> -ProfessionalTennisPlayer(x))\nall x. (WorldTourPlayer(x) -> ProfessionalTennisPlayer(x))\nall x. (GrandSlamChampion(x) -> WorldTourPlayer(x))\nall x. (GrandSlamUmpire(x) -> ProfessionalTennisUmpire(x))\nWorldTourPlayer(Nadal) | GrandSlamChampion(Nadal)"
        ],
        "conclusion": "Nadal is a Grand Slam champion.",
        "conclusion-FOL": "GrandSlamChampion(Nadal)",
        "label": "ERROR"
    },
    {
        "premises": "No professional tennis umpires are professional tennis players.\nIf you are a World Tour player, then you are a professional tennis player.\nAll Grand Slam champions are World Tour players.\nAll Grand Slam umpires are professional tennis umpires.\nNadal is a World Tour player or a Grand Slam champion",
        "premises-FOL": [
            "all x. (ProfessionalTennisUmpire(x) -> -ProfessionalTennisPlayer(x))\nall x. (WorldTourPlayer(x) -> ProfessionalTennisPlayer(x))\nall x. (GrandSlamChampion(x) -> WorldTourPlayer(x))\nall x. (GrandSlamUmpire(x) -> ProfessionalTennisUmpire(x))\nWorldTourPlayer(Nadal) | GrandSlamChampion(Nadal)"
        ],
        "conclusion": "Nadal is neither a Grand Slam umpire nor a professional tennis umpire.",
        "conclusion-FOL": "-(GrandSlamUmpire(Nadal) | ProfessionalTennisUmpire(Nadal))",
        "label": "ERROR"
    },
    {
        "premises": "No professional tennis umpires are professional tennis players.\nIf you are a World Tour player, then you are a professional tennis player.\nAll Grand Slam champions are World Tour players.\nAll Grand Slam umpires are professional tennis umpires.\nNadal is a World Tour player or a Grand Slam champion",
        "premises-FOL": [
            "all x. (ProfessionalTennisUmpire(x) -> -ProfessionalTennisPlayer(x))\nall x. (WorldTourPlayer(x) -> ProfessionalTennisPlayer(x))\nall x. (GrandSlamChampion(x) -> WorldTourPlayer(x))\nall x. (GrandSlamUmpire(x) -> ProfessionalTennisUmpire(x))\nWorldTourPlayer(Nadal) | GrandSlamChampion(Nadal)"
        ],
        "conclusion": "If Nadal is a professional tennis umpire, then Nadal is a Grand Slam Umpire.",
        "conclusion-FOL": "ProfessionalTennisUmpire(Nadal) -> GrandSlamUmpire(Nadal)",
        "label": "ERROR"
    },
    {
        "premises": "No professional tennis umpires are professional tennis players.\nIf you are a World Tour player, then you are a professional tennis player.\nAll Grand Slam champions are World Tour players.\nAll Grand Slam umpires are professional tennis umpires.\nNadal is a World Tour player or a Grand Slam champion",
        "premises-FOL": [
            "all x. (ProfessionalTennisUmpire(x) -> -ProfessionalTennisPlayer(x))\nall x. (WorldTourPlayer(x) -> ProfessionalTennisPlayer(x))\nall x. (GrandSlamChampion(x) -> WorldTourPlayer(x))\nall x. (GrandSlamUmpire(x) -> ProfessionalTennisUmpire(x))\nWorldTourPlayer(Nadal) | GrandSlamChampion(Nadal)"
        ],
        "conclusion": "If Nadal is a Grand Slam umpire or a professional tennis player, then Nadal is a Grand Slam umpire.",
        "conclusion-FOL": "GrandSlamUmpire(Nadal) | ProfessionalTennisPlayer(Nadal) -> GrandSlamUmpire(Nadal)",
        "label": "ERROR"
    },
    {
        "premises": "Businesses are either sanctioned or unsanctioned.\nSanctioned businesses are limited.\nUnsanctioned businesses are free.\nThe Crude Oil Data Exchange is a business that isn't free.",
        "premises-FOL": [
            "all x. (Buisness(x) -> Sanctioned(x) \u2295 -Sanctioned(x))\nall x. (Buisness(x) & Sanctioned(x) -> Limited(x))\nall x. (Buisness(x) & -Sanctioned(x) -> Free(x))\nBuisness(CrudeOilDataExchange) & -Free(CrudeOilDataExchange)"
        ],
        "conclusion": "Crude Oil Data Exchange is sanctioned.",
        "conclusion-FOL": "Sanctioned(CrudeOilDataExchange)",
        "label": "ERROR"
    },
    {
        "premises": "Businesses are either sanctioned or unsanctioned.\nSanctioned businesses are limited.\nUnsanctioned businesses are free.\nThe Crude Oil Data Exchange is a business that isn't free.",
        "premises-FOL": [
            "all x. (Buisness(x) -> Sanctioned(x) \u2295 -Sanctioned(x))\nall x. (Buisness(x) & Sanctioned(x) -> Limited(x))\nall x. (Buisness(x) & -Sanctioned(x) -> Free(x))\nBuisness(CrudeOilDataExchange) & -Free(CrudeOilDataExchange)"
        ],
        "conclusion": "Crude Oil Data Exchange is unsanctioned.",
        "conclusion-FOL": "-Sanctioned(CrudeOilDataExchange)",
        "label": "ERROR"
    },
    {
        "premises": "Businesses are either sanctioned or unsanctioned.\nSanctioned businesses are limited.\nUnsanctioned businesses are free.\nThe Crude Oil Data Exchange is a business that isn't free.",
        "premises-FOL": [
            "all x. (Buisness(x) -> Sanctioned(x) \u2295 -Sanctioned(x))\nall x. (Buisness(x) & Sanctioned(x) -> Limited(x))\nall x. (Buisness(x) & -Sanctioned(x) -> Free(x))\nBuisness(CrudeOilDataExchange) & -Free(CrudeOilDataExchange)"
        ],
        "conclusion": "Crude Oil Data Exchange is limited.",
        "conclusion-FOL": "Limited(CrudeOilDataExchange)",
        "label": "ERROR"
    },
    {
        "premises": "When something is depressing, it is sad.\nThe end of a relationship is depressing. ",
        "premises-FOL": [
            "all x. (Depressing(x) -> Sad(x))\nDepressing(v)"
        ],
        "conclusion": "The end of a relationship is invigorating",
        "conclusion-FOL": "Invigorating(v)",
        "label": "ERROR"
    },
    {
        "premises": "Palstaves are a type of early bronze axe.\nPalstaves are found in northern, western, and southwestern Europe and are cast in molds.\nJohn Evans is an archeologist who popularized the term \"palstave.\"\nPaalstabs are not a type of axe but rather a digging shovel.",
        "premises-FOL": [
            "EarlyBronzeAge(Palstave) & Axe(Palstave)\nFoundIn(Palstave, NorthernEurope) | FoundIn(Palstave, WesternEurope) | FoundIn(Palstave, SouthWesternEurope)) & CastIn(Palstave, Molds)\nArcheologist(JohnEvans) & Popularize(JohnEvans, TermPalstave)\n-Axe(Paalstab) & DiggingShovel(Paalstab)"
        ],
        "conclusion": "John Evans Popularized the term paalstab.",
        "conclusion-FOL": "Popularized(JohnEvans, TermPalstave)",
        "label": "ERROR"
    },
    {
        "premises": "Palstaves are a type of early bronze axe.\nPalstaves are found in northern, western, and southwestern Europe and are cast in molds.\nJohn Evans is an archeologist who popularized the term \"palstave.\"\nPaalstabs are not a type of axe but rather a digging shovel.",
        "premises-FOL": [
            "EarlyBronzeAge(Palstave) & Axe(Palstave)\nFoundIn(Palstave, NorthernEurope) | FoundIn(Palstave, WesternEurope) | FoundIn(Palstave, SouthWesternEurope)) & CastIn(Palstave, Molds)\nArcheologist(JohnEvans) & Popularize(JohnEvans, TermPalstave)\n-Axe(Paalstab) & DiggingShovel(Paalstab)"
        ],
        "conclusion": "There is an axe that is found in Western Europe.",
        "conclusion-FOL": "exists x. (Axe(x) & FoundIn(x, WesternEurope))",
        "label": "ERROR"
    },
    {
        "premises": "Palstaves are a type of early bronze axe.\nPalstaves are found in northern, western, and southwestern Europe and are cast in molds.\nJohn Evans is an archeologist who popularized the term \"palstave.\"\nPaalstabs are not a type of axe but rather a digging shovel.",
        "premises-FOL": [
            "EarlyBronzeAge(Palstave) & Axe(Palstave)\nFoundIn(Palstave, NorthernEurope) | FoundIn(Palstave, WesternEurope) | FoundIn(Palstave, SouthWesternEurope)) & CastIn(Palstave, Molds)\nArcheologist(JohnEvans) & Popularize(JohnEvans, TermPalstave)\n-Axe(Paalstab) & DiggingShovel(Paalstab)"
        ],
        "conclusion": "Archeologists haven't popularized anything.",
        "conclusion-FOL": "all x. all y. (Archeologist(x) -> -Popularize(x, y))",
        "label": "ERROR"
    },
    {
        "premises": "Koei Tecmo is a Japanese video game and anime holding company.\nHolding companies hold several companies.\nTecmo was disbanded in Japan, while Koei survived but was renamed.\nVideo game holding companies are holding companies.",
        "premises-FOL": [
            "Japanese(Koeitecmo) & VideoGameHoldingCompany(Koeitecmo) & AnimeHoldingCompany(Koeitecmo) & HoldingCompany(x) \nall x. (HoldingCompany(x) -> exists y.(Company(y) & Holds(x, y)))\nDisbandsIn(Tecmo, Japan) & Survives(Koei) & Renames(Koei)\nall x. (VideoGameHoldingCompany(x) -> HoldingCompany(x))"
        ],
        "conclusion": "Koei Tecmo holds another company.",
        "conclusion-FOL": "exists x. (Company(x) & Holds(Koeitecmo, x))",
        "label": "ERROR"
    },
    {
        "premises": "Koei Tecmo is a Japanese video game and anime holding company.\nHolding companies hold several companies.\nTecmo was disbanded in Japan, while Koei survived but was renamed.\nVideo game holding companies are holding companies.",
        "premises-FOL": [
            "Japanese(Koeitecmo) & VideoGameHoldingCompany(Koeitecmo) & AnimeHoldingCompany(Koeitecmo) & HoldingCompany(x) \nall x. (HoldingCompany(x) -> exists y.(Company(y) & Holds(x, y)))\nDisbandsIn(Tecmo, Japan) & Survives(Koei) & Renames(Koei)\nall x. (VideoGameHoldingCompany(x) -> HoldingCompany(x))"
        ],
        "conclusion": "Tecmo holds another company.",
        "conclusion-FOL": "exists x. (Company(x) & Holds(Tecmo, x))",
        "label": "ERROR"
    },
    {
        "premises": "Koei Tecmo is a Japanese video game and anime holding company.\nHolding companies hold several companies.\nTecmo was disbanded in Japan, while Koei survived but was renamed.\nVideo game holding companies are holding companies.",
        "premises-FOL": [
            "Japanese(Koeitecmo) & VideoGameHoldingCompany(Koeitecmo) & AnimeHoldingCompany(Koeitecmo) & HoldingCompany(x) \nall x. (HoldingCompany(x) -> exists y.(Company(y) & Holds(x, y)))\nDisbandsIn(Tecmo, Japan) & Survives(Koei) & Renames(Koei)\nall x. (VideoGameHoldingCompany(x) -> HoldingCompany(x))"
        ],
        "conclusion": "Koei Tecmo holds anime.",
        "conclusion-FOL": "AnimeHoldingCompany(Koeitecmo)",
        "label": "ERROR"
    },
    {
        "premises": "The PlayStation EyeToy is a camera accessory for the PlayStation 2 system. \nThe PlayStation Eye is a camera accessory for the PlayStation 3 system.\nThe PlayStation Camera is a camera accessory for the PlayStation 4 and the PlayStation 5 systems.\nCamera accessories for a system are compatible with that system.\nPlaystation 2, 3,4, and 5 are all different.\nOnly the PlayStation Camera camera system is compatible with different systems.",
        "premises-FOL": [
            "System(PlayStationTwo) & CameraAccessoryFor(PlayStationEyeToy, PlayStationTwo)\nSystem(PlayStationThree) & CameraAccessoryFor(PlayStationEye, PlayStationThree)  \nSystem(PlayStationFour) & System(PlayStationFive) & CameraAccessoryFor(PlayStationCamera, PlayStationFour) & CameraAccessoryFor(PlayStationCamera, PlayStationFive)\nall x. all y. (CameraAccessoryFor(x, y) & System(y) -> CompatibleWith(x, y))\n-(PlayStationTwo=PlayStationThree) & -(PlayStationTwo=PlayStationFour) & -(PlayStationTwo=PlayStationFive) & -(PlayStationThree=PlayStationFour) & -(PlayStationThree=PlayStationFive) & -(PlayStationFour=PlayStationFive)\nall x. exists y. exists z. (System(y) & System(z) & -(y=z) & CompatibleWith(x, y) & CompatibleWith(x, z) -> x=PlaystationCamera)"
        ],
        "conclusion": "The Playstation Eye is compatible with the PlayStation 2 and the PlayStation 3.",
        "conclusion-FOL": "Compatible(PlayStationEye, PlayStationTwo) & Compatible(PlayStationEye, PlayStationThree)",
        "label": "ERROR"
    },
    {
        "premises": "The PlayStation EyeToy is a camera accessory for the PlayStation 2 system. \nThe PlayStation Eye is a camera accessory for the PlayStation 3 system.\nThe PlayStation Camera is a camera accessory for the PlayStation 4 and the PlayStation 5 systems.\nCamera accessories for a system are compatible with that system.\nPlaystation 2, 3,4, and 5 are all different.\nOnly the PlayStation Camera camera system is compatible with different systems.",
        "premises-FOL": [
            "System(PlayStationTwo) & CameraAccessoryFor(PlayStationEyeToy, PlayStationTwo)\nSystem(PlayStationThree) & CameraAccessoryFor(PlayStationEye, PlayStationThree)  \nSystem(PlayStationFour) & System(PlayStationFive) & CameraAccessoryFor(PlayStationCamera, PlayStationFour) & CameraAccessoryFor(PlayStationCamera, PlayStationFive)\nall x. all y. (CameraAccessoryFor(x, y) & System(y) -> CompatibleWith(x, y))\n-(PlayStationTwo=PlayStationThree) & -(PlayStationTwo=PlayStationFour) & -(PlayStationTwo=PlayStationFive) & -(PlayStationThree=PlayStationFour) & -(PlayStationThree=PlayStationFive) & -(PlayStationFour=PlayStationFive)\nall x. exists y. exists z. (System(y) & System(z) & -(y=z) & CompatibleWith(x, y) & CompatibleWith(x, z) -> x=PlaystationCamera)"
        ],
        "conclusion": "The Playstation EyeToy is compatible with the PlayStation 2.",
        "conclusion-FOL": "Compatible(PlayStationEyeToy, PlayStationTwo)",
        "label": "ERROR"
    },
    {
        "premises": "The PlayStation EyeToy is a camera accessory for the PlayStation 2 system. \nThe PlayStation Eye is a camera accessory for the PlayStation 3 system.\nThe PlayStation Camera is a camera accessory for the PlayStation 4 and the PlayStation 5 systems.\nCamera accessories for a system are compatible with that system.\nPlaystation 2, 3,4, and 5 are all different.\nOnly the PlayStation Camera camera system is compatible with different systems.",
        "premises-FOL": [
            "System(PlayStationTwo) & CameraAccessoryFor(PlayStationEyeToy, PlayStationTwo)\nSystem(PlayStationThree) & CameraAccessoryFor(PlayStationEye, PlayStationThree)  \nSystem(PlayStationFour) & System(PlayStationFive) & CameraAccessoryFor(PlayStationCamera, PlayStationFour) & CameraAccessoryFor(PlayStationCamera, PlayStationFive)\nall x. all y. (CameraAccessoryFor(x, y) & System(y) -> CompatibleWith(x, y))\n-(PlayStationTwo=PlayStationThree) & -(PlayStationTwo=PlayStationFour) & -(PlayStationTwo=PlayStationFive) & -(PlayStationThree=PlayStationFour) & -(PlayStationThree=PlayStationFive) & -(PlayStationFour=PlayStationFive)\nall x. exists y. exists z. (System(y) & System(z) & -(y=z) & CompatibleWith(x, y) & CompatibleWith(x, z) -> x=PlaystationCamera)"
        ],
        "conclusion": "The Playstation Camera can be used for all Playstation consoles.",
        "conclusion-FOL": "Compatible(PlayStationCamera, PlayStationTwo) & Compatible(PlayStationCamera, PlayStationThree) & Compatible(PlayStationCamera, PlayStationFour) & Compatible(PlayStationCamera, PlayStationFive)",
        "label": "ERROR"
    },
    {
        "premises": "Adam Buska is a European football player.\nIf a European plays football, they play what Americans call soccer.",
        "premises-FOL": [
            "FootballPlayer(AdamBuska) & European(AdamBuska)\nall x. (FootballPlayer(x) & European(x) -> exists y. (Call(American, y, Soccer) & Play(x, y)))"
        ],
        "conclusion": "Adam Buska plays what Americans call soccer.",
        "conclusion-FOL": "exists y. (Call(American, y, Soccer) & Play(AdamBuska, y))",
        "label": "ERROR"
    },
    {
        "premises": "If a game is one of the top-3 best selling video-games, then it is multiplatform.\nIf a game has sold more than 100 million copies, then it is one of the top-3 best-selling video games.\nSome games that support Windows are developed by Nintendo.\nAll multiplatform games can be played on a wide range of devices.\nPokemon Diamond version is neither developed by Nintendo nor can be played on a wide range of devices.",
        "premises-FOL": [
            "all x. (ATopThreeBestSellingVideoGame(x) -> Multiplatform(x))\nall x. (SoldMoreThanOneZeroZeroMillionCopies(x) -> ATopThreeBestSellingVideoGame(x))\nexists x. ((SupportsWindows(x) & AGameDevelopedByNintendo(x)))\nall x. (Multiplatform(x) -> CanBePlayedOnAWideRangeOfDevices(x))\n-(DevelopedByNintendo(PokemonDiamond) | CanBePlayedOnAWideRangeOfDevices(PokemonDiamond))"
        ],
        "conclusion": "Pokemon Diamond version supports Windows.",
        "conclusion-FOL": "Game(PokemonDiamond) & SupportsWindows(PokemonDiamond)",
        "label": "ERROR"
    },
    {
        "premises": "If a game is one of the top-3 best selling video-games, then it is multiplatform.\nIf a game has sold more than 100 million copies, then it is one of the top-3 best-selling video games.\nSome games that support Windows are developed by Nintendo.\nAll multiplatform games can be played on a wide range of devices.\nPokemon Diamond version is neither developed by Nintendo nor can be played on a wide range of devices.",
        "premises-FOL": [
            "all x. (ATopThreeBestSellingVideoGame(x) -> Multiplatform(x))\nall x. (SoldMoreThanOneZeroZeroMillionCopies(x) -> ATopThreeBestSellingVideoGame(x))\nexists x. ((SupportsWindows(x) & AGameDevelopedByNintendo(x)))\nall x. (Multiplatform(x) -> CanBePlayedOnAWideRangeOfDevices(x))\n-(DevelopedByNintendo(PokemonDiamond) | CanBePlayedOnAWideRangeOfDevices(PokemonDiamond))"
        ],
        "conclusion": "Pokemon Diamond version supports Windows and has sold more than 100 million copies.",
        "conclusion-FOL": "(Game(PokemonDiamond) & SupportsWindows(PokemonDiamond)) & (Game(PokemonDiamond) & SoldMoreThanOneZeroZeroMillionCopies(PokemonDiamond))",
        "label": "ERROR"
    },
    {
        "premises": "If a game is one of the top-3 best selling video-games, then it is multiplatform.\nIf a game has sold more than 100 million copies, then it is one of the top-3 best-selling video games.\nSome games that support Windows are developed by Nintendo.\nAll multiplatform games can be played on a wide range of devices.\nPokemon Diamond version is neither developed by Nintendo nor can be played on a wide range of devices.",
        "premises-FOL": [
            "all x. (ATopThreeBestSellingVideoGame(x) -> Multiplatform(x))\nall x. (SoldMoreThanOneZeroZeroMillionCopies(x) -> ATopThreeBestSellingVideoGame(x))\nexists x. ((SupportsWindows(x) & AGameDevelopedByNintendo(x)))\nall x. (Multiplatform(x) -> CanBePlayedOnAWideRangeOfDevices(x))\n-(DevelopedByNintendo(PokemonDiamond) | CanBePlayedOnAWideRangeOfDevices(PokemonDiamond))"
        ],
        "conclusion": "If Pokemon Diamond version either supports Windows or has sold more than 100 million copies, then Pokemon Diamond version either is both multiplatform and one of the top-3 best selling video games, or is neither multiplatform nor one of the top-3 best selling video games.",
        "conclusion-FOL": "((((Game(PokemonDiamond) & SupportsWindows(PokemonDiamond)) & -((Game(PokemonDiamond) v (SoldMoreThanOneZeroZeroMillionCopies(PokemonDiamond))) | (-((Game(PokemonDiamond) & SupportsWindows(PokemonDiamond)) & ((Game(PokemonDiamond) v (SoldMoreThanOneZeroZeroMillionCopies(PokemonDiamond))))) -> (((Multiplatform(PokemonDiamond) & (Game(PokemonDiamond) & ATopThreeBestSellingVideoGame(PokemonDiamond))) & -(-Multiplatform(PokemonDiamond) & -(Game(PokemonDiamond) & ATopThreeBestSellingVideoGame(PokemonDiamond))) | (-(Multiplatform(PokemonDiamond) & (Game(PokemonDiamond) & ATopThreeBestSellingVideoGame(PokemonDiamond))) & (-Multiplatform(PokemonDiamond) & -(Game(PokemonDiamond) & ATopThreeBestSellingVideoGame(PokemonDiamond)))))",
        "label": "ERROR"
    },
    {
        "premises": "China is one of the BRICS, and its economy is emerging.\nIf someone is from China, then they are from a country of BRICS.\nIndia is one of the BRICS, and its economy is emerging.\nIf someone is from India, then they are in a country of BRICS.\nAll people from China are Chinese people.\nAll people from India are Indian people.\nThere is a person from India.",
        "premises-FOL": [
            "exists x. (BRIC(x) & -(x=China) & BRIC(China) & Emerging(ChinaEconomy))\nall x. (From(x, China) -> From(x, Bric))\nBRIC(India) & Emerging(IndiaEconomy)\nall x. (From(x, India) -> From(x, Bric))\nall x. (From(x, China) -> Chinese(x))\nall x. (From(x, India) -> Indian(x))\nexists x. (From(x, India))"
        ],
        "conclusion": "No people from BRICS are Indian people.",
        "conclusion-FOL": "all x. (From(x, CountryOfBRICS) -> -IndianPeople(x))",
        "label": "ERROR"
    },
    {
        "premises": "China is one of the BRICS, and its economy is emerging.\nIf someone is from China, then they are from a country of BRICS.\nIndia is one of the BRICS, and its economy is emerging.\nIf someone is from India, then they are in a country of BRICS.\nAll people from China are Chinese people.\nAll people from India are Indian people.\nThere is a person from India.",
        "premises-FOL": [
            "exists x. (BRIC(x) & -(x=China) & BRIC(China) & Emerging(ChinaEconomy))\nall x. (From(x, China) -> From(x, Bric))\nBRIC(India) & Emerging(IndiaEconomy)\nall x. (From(x, India) -> From(x, Bric))\nall x. (From(x, China) -> Chinese(x))\nall x. (From(x, India) -> Indian(x))\nexists x. (From(x, India))"
        ],
        "conclusion": "India's economy is not emerging.",
        "conclusion-FOL": "EmergingEconomy(India)",
        "label": "ERROR"
    },
    {
        "premises": "China is one of the BRICS, and its economy is emerging.\nIf someone is from China, then they are from a country of BRICS.\nIndia is one of the BRICS, and its economy is emerging.\nIf someone is from India, then they are in a country of BRICS.\nAll people from China are Chinese people.\nAll people from India are Indian people.\nThere is a person from India.",
        "premises-FOL": [
            "exists x. (BRIC(x) & -(x=China) & BRIC(China) & Emerging(ChinaEconomy))\nall x. (From(x, China) -> From(x, Bric))\nBRIC(India) & Emerging(IndiaEconomy)\nall x. (From(x, India) -> From(x, Bric))\nall x. (From(x, China) -> Chinese(x))\nall x. (From(x, India) -> Indian(x))\nexists x. (From(x, India))"
        ],
        "conclusion": "There is an Indian people from BRICS.",
        "conclusion-FOL": "exists x. (IndianPeople(x) & From(x, CountryOfBRICS))",
        "label": "ERROR"
    },
    {
        "premises": "Daveed Diggs is an actor and film producer.\nDaveed Diggs played two roles in the musical Hamilton on Broadway.\nOne of the actors from Hamilton won the best actor award.\nThe actor playing Thomas Jefferson won the best actor award.\nDaveed Diggs played Thomas Jefferson.\nMusicals on Broadway are not films.",
        "premises-FOL": [
            "Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)\nexists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)\nexists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))\nexists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))\nPlays(DaveedDiggs, ThomasJefferson)\nall x. ((Musical(x) & OnBroadway(x)) -> -Film(x))"
        ],
        "conclusion": "Hamilton is a film.",
        "conclusion-FOL": "Film(Hamilton)",
        "label": "ERROR"
    },
    {
        "premises": "Daveed Diggs is an actor and film producer.\nDaveed Diggs played two roles in the musical Hamilton on Broadway.\nOne of the actors from Hamilton won the best actor award.\nThe actor playing Thomas Jefferson won the best actor award.\nDaveed Diggs played Thomas Jefferson.\nMusicals on Broadway are not films.",
        "premises-FOL": [
            "Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)\nexists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)\nexists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))\nexists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))\nPlays(DaveedDiggs, ThomasJefferson)\nall x. ((Musical(x) & OnBroadway(x)) -> -Film(x))"
        ],
        "conclusion": "Daveed Diggs won the best actor award.",
        "conclusion-FOL": "Wins(DaveedDiggs, BestActorAward)",
        "label": "ERROR"
    },
    {
        "premises": "Daveed Diggs is an actor and film producer.\nDaveed Diggs played two roles in the musical Hamilton on Broadway.\nOne of the actors from Hamilton won the best actor award.\nThe actor playing Thomas Jefferson won the best actor award.\nDaveed Diggs played Thomas Jefferson.\nMusicals on Broadway are not films.",
        "premises-FOL": [
            "Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)\nexists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)\nexists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))\nexists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))\nPlays(DaveedDiggs, ThomasJefferson)\nall x. ((Musical(x) & OnBroadway(x)) -> -Film(x))"
        ],
        "conclusion": "Hamilton won two awards.",
        "conclusion-FOL": "exists x. exists y.(Wins(Hamilton, x) & (-(x=y)) & Wins(Hamilton, y))",
        "label": "ERROR"
    },
    {
        "premises": "Ernest Pohl was a Polish football player. \nA football player in the Polish First Division has scored over 180 goals. \nErnest Pohl scored more than 180 goals in the Polish First Division. \nG\u00f3rnik Zabrze's stadium was named after a soccer player from Ruda \u015al\u0105ska. \nErnest Pohl is from Ruda \u015al\u0105ska. ",
        "premises-FOL": [
            "Polish(ErnestPohl) & FootballPlayer(ErnestPohl)\nexists x. (FootballPlayer(x) & In(x, PolishFirstDivision) & ScoredOver(x, OneEightZeroGoals))\nIn(ErnestPohl, PolishFirstDivision) & ScoredOver(ErnestPohl, OneEightZeroGoals)\nexists x. exists y. (GornikZabrzes(x) & Stadium(x) & NamedAfter(x, y) & SoccerPlayer(y) & From(y, RudaSlaska))\nFrom(ErnestPohl, RudaSlaska))"
        ],
        "conclusion": "Ernest Pohl has not scored more than 180 goals.",
        "conclusion-FOL": "-ScoredOver(ErnestPohl, OneEightZeroGoals)",
        "label": "ERROR"
    },
    {
        "premises": "Ernest Pohl was a Polish football player. \nA football player in the Polish First Division has scored over 180 goals. \nErnest Pohl scored more than 180 goals in the Polish First Division. \nG\u00f3rnik Zabrze's stadium was named after a soccer player from Ruda \u015al\u0105ska. \nErnest Pohl is from Ruda \u015al\u0105ska. ",
        "premises-FOL": [
            "Polish(ErnestPohl) & FootballPlayer(ErnestPohl)\nexists x. (FootballPlayer(x) & In(x, PolishFirstDivision) & ScoredOver(x, OneEightZeroGoals))\nIn(ErnestPohl, PolishFirstDivision) & ScoredOver(ErnestPohl, OneEightZeroGoals)\nexists x. exists y. (GornikZabrzes(x) & Stadium(x) & NamedAfter(x, y) & SoccerPlayer(y) & From(y, RudaSlaska))\nFrom(ErnestPohl, RudaSlaska))"
        ],
        "conclusion": "G\u00f3rnik Zabrze's stadium was named after Ernest Pohl.",
        "conclusion-FOL": "all x. (GornikZabrzes(x) & Stadium(x) -> NamedAfter(x, ErnestPohl))",
        "label": "ERROR"
    },
    {
        "premises": "Ann J. Land was a member of the Philadelphia City Council and the Democratic Party.\nAnn J. Land ran unopposed for the Philadelphia City Council in 1980.\nPeople who run unopposed for the Philadelphia City Council are elected to the positions they run for in the same year.\nMichael Nutter was a political challenger.\nAnn J. Land defeated Michael Nutter and ran for the Philadelphia City Council in 1987.",
        "premises-FOL": [
            "MemberOf(AnnJLand, PhiladelphiaCityCouncil) & MemberOf(AnnJLand, DemocraticParty)\nRunUnopposedFor(Ann, PhiladelphiaCityCouncil, YearOneNineEightZero)\nall x. all y. (RunUnopposedFor(x, PhiladelphiaCityCouncil, y) -> ElectedTo(x, PhiladelphiaCityCouncil, y))\nPoliticalChallenger(MichaelNutter)\nDefeat(AnnJLand, MichaelNutter) & RunFor(AnnJLand, PhiladelphiaCityCouncil, YearOneNineEightSeven)"
        ],
        "conclusion": "Ann J. Land was elected to the Philadelphia City Council in 1980.",
        "conclusion-FOL": "ElectedTo(Ann, PhiladelphiaCityCouncil, YearOneNineEightZero)",
        "label": "ERROR"
    },
    {
        "premises": "Ann J. Land was a member of the Philadelphia City Council and the Democratic Party.\nAnn J. Land ran unopposed for the Philadelphia City Council in 1980.\nPeople who run unopposed for the Philadelphia City Council are elected to the positions they run for in the same year.\nMichael Nutter was a political challenger.\nAnn J. Land defeated Michael Nutter and ran for the Philadelphia City Council in 1987.",
        "premises-FOL": [
            "MemberOf(AnnJLand, PhiladelphiaCityCouncil) & MemberOf(AnnJLand, DemocraticParty)\nRunUnopposedFor(Ann, PhiladelphiaCityCouncil, YearOneNineEightZero)\nall x. all y. (RunUnopposedFor(x, PhiladelphiaCityCouncil, y) -> ElectedTo(x, PhiladelphiaCityCouncil, y))\nPoliticalChallenger(MichaelNutter)\nDefeat(AnnJLand, MichaelNutter) & RunFor(AnnJLand, PhiladelphiaCityCouncil, YearOneNineEightSeven)"
        ],
        "conclusion": "Ann J. Land was elected to the Philadelphia City Council in 1987.",
        "conclusion-FOL": "ElectedTo(Ann, PhiladelphiaCityCouncil, YearOneNineEightSeven)",
        "label": "ERROR"
    },
    {
        "premises": "Ann J. Land was a member of the Philadelphia City Council and the Democratic Party.\nAnn J. Land ran unopposed for the Philadelphia City Council in 1980.\nPeople who run unopposed for the Philadelphia City Council are elected to the positions they run for in the same year.\nMichael Nutter was a political challenger.\nAnn J. Land defeated Michael Nutter and ran for the Philadelphia City Council in 1987.",
        "premises-FOL": [
            "MemberOf(AnnJLand, PhiladelphiaCityCouncil) & MemberOf(AnnJLand, DemocraticParty)\nRunUnopposedFor(Ann, PhiladelphiaCityCouncil, YearOneNineEightZero)\nall x. all y. (RunUnopposedFor(x, PhiladelphiaCityCouncil, y) -> ElectedTo(x, PhiladelphiaCityCouncil, y))\nPoliticalChallenger(MichaelNutter)\nDefeat(AnnJLand, MichaelNutter) & RunFor(AnnJLand, PhiladelphiaCityCouncil, YearOneNineEightSeven)"
        ],
        "conclusion": "There was some member of the Democratic Party elected to the Philadelphia City Council in 1980.",
        "conclusion-FOL": "exists x. (MemberOf(x, DemocraticParty) & ElectedTo(x, PhiladelphiaCouncil, YearOneNineEightZero))",
        "label": "ERROR"
    },
    {
        "premises": "Aberdeen won the cup in the 2013 final.\nRangers won the cup in the 2014 final.\nAberdeen and Rangers are different teams.\nDifferent teams cannot win the cup in the same year's final.",
        "premises-FOL": [
            "WonCup(Aberdeen, YearTwoZeroOneThreeFinal)\nWonCup(Rangers, YearTwoZeroOneFourFinal)\n-(Aberdeen=Rangers)\nall x. all y. all z. all w. (-(x=y) & WonCup(x, z) & WonCup(y, w) -> -(z=w))"
        ],
        "conclusion": "Rangers won the cup in 2015.",
        "conclusion-FOL": "WonCup(Rangers, YearTwoZeroOneFiveFinal)",
        "label": "ERROR"
    },
    {
        "premises": "Aberdeen won the cup in the 2013 final.\nRangers won the cup in the 2014 final.\nAberdeen and Rangers are different teams.\nDifferent teams cannot win the cup in the same year's final.",
        "premises-FOL": [
            "WonCup(Aberdeen, YearTwoZeroOneThreeFinal)\nWonCup(Rangers, YearTwoZeroOneFourFinal)\n-(Aberdeen=Rangers)\nall x. all y. all z. all w. (-(x=y) & WonCup(x, z) & WonCup(y, w) -> -(z=w))"
        ],
        "conclusion": "Rangers won the cup in 2013.",
        "conclusion-FOL": "WonCup(Rangers, YearTwoZeroOneThreeFinal)",
        "label": "ERROR"
    },
    {
        "premises": "Aberdeen won the cup in the 2013 final.\nRangers won the cup in the 2014 final.\nAberdeen and Rangers are different teams.\nDifferent teams cannot win the cup in the same year's final.",
        "premises-FOL": [
            "WonCup(Aberdeen, YearTwoZeroOneThreeFinal)\nWonCup(Rangers, YearTwoZeroOneFourFinal)\n-(Aberdeen=Rangers)\nall x. all y. all z. all w. (-(x=y) & WonCup(x, z) & WonCup(y, w) -> -(z=w))"
        ],
        "conclusion": "Aberdeen has once won a cup.",
        "conclusion-FOL": "exists x. (WonCup(Aberdeen, x))",
        "label": "ERROR"
    },
    {
        "premises": "All young working professionals who have regular 9-5 jobs have stable jobs.\nSome people living in Manhattan are young professionals with regular 9-5 jobs.\nAll people who have stable jobs are people who work regularly.\nPeople who work regularly do not frequently disobey their bosses.\nMary either frequently disobeys her bosses and works regularly, or that she neither frequently disobeys her bosses nor works regularly.",
        "premises-FOL": [
            "all x. (YoungWorkingProfessional(x) & Have(x, RegularNineToFiveJob) -> Have(x, StableJob))\nexists x. (LiveIn(x, Manhattan) & YoungWorkingProfessional(x) & Have(x, RegularNineToFiveJob))\nall x. (Have(x, StableJob) -> WorkRegularly(x))\nall x. (WorkRegularly(x) -> -DisobeyFrequently(x, Boss))\n-(((DisobeyFrequently(Mary, Boss) & -WorkRegularly(Mary)) | (-DisobeyFrequently(Mary, Boss) & WorkRegularly(Mary))))"
        ],
        "conclusion": "Mary lives in Manhattan.",
        "conclusion-FOL": "LiveIn(Mary, Manhattan)",
        "label": "ERROR"
    },
    {
        "premises": "All young working professionals who have regular 9-5 jobs have stable jobs.\nSome people living in Manhattan are young professionals with regular 9-5 jobs.\nAll people who have stable jobs are people who work regularly.\nPeople who work regularly do not frequently disobey their bosses.\nMary either frequently disobeys her bosses and works regularly, or that she neither frequently disobeys her bosses nor works regularly.",
        "premises-FOL": [
            "all x. (YoungWorkingProfessional(x) & Have(x, RegularNineToFiveJob) -> Have(x, StableJob))\nexists x. (LiveIn(x, Manhattan) & YoungWorkingProfessional(x) & Have(x, RegularNineToFiveJob))\nall x. (Have(x, StableJob) -> WorkRegularly(x))\nall x. (WorkRegularly(x) -> -DisobeyFrequently(x, Boss))\n-(((DisobeyFrequently(Mary, Boss) & -WorkRegularly(Mary)) | (-DisobeyFrequently(Mary, Boss) & WorkRegularly(Mary))))"
        ],
        "conclusion": "Mary lives in Manhattan and is a young working professional who has a regular 9-5 job.",
        "conclusion-FOL": "LiveIn(Mary, Manhattan) & YoungWorkingProfessional(Mary) & Have(Mary, RegularNine-FiveJob)",
        "label": "ERROR"
    },
    {
        "premises": "All young working professionals who have regular 9-5 jobs have stable jobs.\nSome people living in Manhattan are young professionals with regular 9-5 jobs.\nAll people who have stable jobs are people who work regularly.\nPeople who work regularly do not frequently disobey their bosses.\nMary either frequently disobeys her bosses and works regularly, or that she neither frequently disobeys her bosses nor works regularly.",
        "premises-FOL": [
            "all x. (YoungWorkingProfessional(x) & Have(x, RegularNineToFiveJob) -> Have(x, StableJob))\nexists x. (LiveIn(x, Manhattan) & YoungWorkingProfessional(x) & Have(x, RegularNineToFiveJob))\nall x. (Have(x, StableJob) -> WorkRegularly(x))\nall x. (WorkRegularly(x) -> -DisobeyFrequently(x, Boss))\n-(((DisobeyFrequently(Mary, Boss) & -WorkRegularly(Mary)) | (-DisobeyFrequently(Mary, Boss) & WorkRegularly(Mary))))"
        ],
        "conclusion": "If Mary is a young working professional who has a regular 9-5 job, then Mary does not live in Manhattan.",
        "conclusion-FOL": "YoungWorkingProfessional(Mary) & Have(Mary, RegularNine-FiveJob) -> -LiveIn(Mary, Manhattan)",
        "label": "ERROR"
    },
    {
        "premises": "All brain study designs are either block designs or event-related designs. \nAll event-related brain study designs are brain image acquisition.\nAll brain image acquisition in brain study designs is preceded by data processing.\nNothing in brain study designs preceded by data processing analyzes data.\nPicture memory is a type of brain study design that is not either event-related or analyzing data.",
        "premises-FOL": [
            "all x. (BrainStudy(x) -> (BlockDesign(x) \u2295 Event-RelatedDesign(x)))\nall x. ((BrainStudy(x) & EventRelatedDesign(x)) -> BrainImageAcquisition(x))\nall x. ((BrainStudy(x) & BrainImageAcquisition(x)) -> PrecededBy(x, DataProcessing))\nall x. ((BrainStudy(x) & PrecededBy(x, DataProcessing)) -> -Analyze(x, Data))\nBrainStudy(PictureMemory) & (-(((EventRelatedDesign(PictureMemory) & -AnalyzingData(PictureMemory)) | (-EventRelatedDesign(PictureMemory) & AnalyzingData(PictureMemory)))))"
        ],
        "conclusion": "Picture memory is preceded by data processing.",
        "conclusion-FOL": "PrecededBy(PictureMemory, DataProcessing)",
        "label": "ERROR"
    },
    {
        "premises": "All brain study designs are either block designs or event-related designs. \nAll event-related brain study designs are brain image acquisition.\nAll brain image acquisition in brain study designs is preceded by data processing.\nNothing in brain study designs preceded by data processing analyzes data.\nPicture memory is a type of brain study design that is not either event-related or analyzing data.",
        "premises-FOL": [
            "all x. (BrainStudy(x) -> (BlockDesign(x) \u2295 Event-RelatedDesign(x)))\nall x. ((BrainStudy(x) & EventRelatedDesign(x)) -> BrainImageAcquisition(x))\nall x. ((BrainStudy(x) & BrainImageAcquisition(x)) -> PrecededBy(x, DataProcessing))\nall x. ((BrainStudy(x) & PrecededBy(x, DataProcessing)) -> -Analyze(x, Data))\nBrainStudy(PictureMemory) & (-(((EventRelatedDesign(PictureMemory) & -AnalyzingData(PictureMemory)) | (-EventRelatedDesign(PictureMemory) & AnalyzingData(PictureMemory)))))"
        ],
        "conclusion": "Picture memory is a block design.",
        "conclusion-FOL": "BlockDesign(PictureMemory)",
        "label": "ERROR"
    },
    {
        "premises": "All brain study designs are either block designs or event-related designs. \nAll event-related brain study designs are brain image acquisition.\nAll brain image acquisition in brain study designs is preceded by data processing.\nNothing in brain study designs preceded by data processing analyzes data.\nPicture memory is a type of brain study design that is not either event-related or analyzing data.",
        "premises-FOL": [
            "all x. (BrainStudy(x) -> (BlockDesign(x) \u2295 Event-RelatedDesign(x)))\nall x. ((BrainStudy(x) & EventRelatedDesign(x)) -> BrainImageAcquisition(x))\nall x. ((BrainStudy(x) & BrainImageAcquisition(x)) -> PrecededBy(x, DataProcessing))\nall x. ((BrainStudy(x) & PrecededBy(x, DataProcessing)) -> -Analyze(x, Data))\nBrainStudy(PictureMemory) & (-(((EventRelatedDesign(PictureMemory) & -AnalyzingData(PictureMemory)) | (-EventRelatedDesign(PictureMemory) & AnalyzingData(PictureMemory)))))"
        ],
        "conclusion": "Picture memory is either a block design or analyzing data.",
        "conclusion-FOL": "((BlockDesign(PictureMemory) & -Analyze(PictureMemory, Data)) | (-BlockDesign(PictureMemory) & Analyze(PictureMemory, Data)))",
        "label": "ERROR"
    },
    {
        "premises": "All brain study designs are either block designs or event-related designs. \nAll event-related brain study designs are brain image acquisition.\nAll brain image acquisition in brain study designs is preceded by data processing.\nNothing in brain study designs preceded by data processing analyzes data.\nPicture memory is a type of brain study design that is not either event-related or analyzing data.",
        "premises-FOL": [
            "all x. (BrainStudy(x) -> (BlockDesign(x) \u2295 Event-RelatedDesign(x)))\nall x. ((BrainStudy(x) & EventRelatedDesign(x)) -> BrainImageAcquisition(x))\nall x. ((BrainStudy(x) & BrainImageAcquisition(x)) -> PrecededBy(x, DataProcessing))\nall x. ((BrainStudy(x) & PrecededBy(x, DataProcessing)) -> -Analyze(x, Data))\nBrainStudy(PictureMemory) & (-(((EventRelatedDesign(PictureMemory) & -AnalyzingData(PictureMemory)) | (-EventRelatedDesign(PictureMemory) & AnalyzingData(PictureMemory)))))"
        ],
        "conclusion": "If picture memory is not analyzing data, then picture memory is a block design and analyzing data.",
        "conclusion-FOL": "-Analyze(PictureMemory, Data) -> (BlockDesign(PictureMemory) & Analyze(PictureMemory, Data))",
        "label": "ERROR"
    },
    {
        "premises": "The USS Lyon was a US Navy ship involved in WWII.\nAll ships involved in WWII are currently decommissioned or in a museum.",
        "premises-FOL": [
            "USNavyShip(TheUSSLyon) & InvolvedIn(TheUSSLyon, wWII)\nall x. (InvolvedIn(x, wWII) -> (CurrentlyDecommissioned(x) | In(x, Museum)))"
        ],
        "conclusion": "The USS Lyon is currently decommissioned.",
        "conclusion-FOL": "CurrentlyDecommissioned(TheUSSLyon)",
        "label": "ERROR"
    },
    {
        "premises": "All disposables are designed to be used only once.\nSome items used in Tom's house are eco-friendly.\nEvery item used in Tom's house is either disposable or reusable. \nIf something is made from metal, then it is not made from plastic. \nAll reusable items used in Tom's house are made from metal.\nThe chopsticks used in Tom's house are either made from metals and plastics, or that they are neither made from metals nor plastics.",
        "premises-FOL": [
            "all x. (Disposable(x) -> DesignedToBeOnlyUsedOnce(x))\nexists x. (EcoFriendly(x))\nall x. (UsedIn(x, TomsHouse) -> ((Disposable(x) & -Reusable(x)) | (-Disposable(x) & Reusable(x))))\nall x. (MadeFrom(x, Metal) -> -MadeFrom(x, Plastic))\nall x. (Reusable(x) -> MadeFrom(x, Metal))\n-(((MadeFrom(ChopsticksUsedInTomsHouse, Metal) & -MadeFrom(ChopsticksUsedInTomsHouse, Plastic)) | (-MadeFrom(ChopsticksUsedInTomsHouse, Metal) & MadeFrom(ChopsticksUsedInTomsHouse, Plastic))))"
        ],
        "conclusion": "The chopsticks used in Tom's house are eco-friendly.",
        "conclusion-FOL": "EcoFriendly(Chopsticks)",
        "label": "ERROR"
    },
    {
        "premises": "All disposables are designed to be used only once.\nSome items used in Tom's house are eco-friendly.\nEvery item used in Tom's house is either disposable or reusable. \nIf something is made from metal, then it is not made from plastic. \nAll reusable items used in Tom's house are made from metal.\nThe chopsticks used in Tom's house are either made from metals and plastics, or that they are neither made from metals nor plastics.",
        "premises-FOL": [
            "all x. (Disposable(x) -> DesignedToBeOnlyUsedOnce(x))\nexists x. (EcoFriendly(x))\nall x. (UsedIn(x, TomsHouse) -> ((Disposable(x) & -Reusable(x)) | (-Disposable(x) & Reusable(x))))\nall x. (MadeFrom(x, Metal) -> -MadeFrom(x, Plastic))\nall x. (Reusable(x) -> MadeFrom(x, Metal))\n-(((MadeFrom(ChopsticksUsedInTomsHouse, Metal) & -MadeFrom(ChopsticksUsedInTomsHouse, Plastic)) | (-MadeFrom(ChopsticksUsedInTomsHouse, Metal) & MadeFrom(ChopsticksUsedInTomsHouse, Plastic))))"
        ],
        "conclusion": "The chopsticks used in Tom's house are eco-friendly or designed to be used only once.",
        "conclusion-FOL": "EcoFriendly(Chopsticks) | DesignedToBeOnlyUsedOnce(Chopsticks)",
        "label": "ERROR"
    },
    {
        "premises": "All disposables are designed to be used only once.\nSome items used in Tom's house are eco-friendly.\nEvery item used in Tom's house is either disposable or reusable. \nIf something is made from metal, then it is not made from plastic. \nAll reusable items used in Tom's house are made from metal.\nThe chopsticks used in Tom's house are either made from metals and plastics, or that they are neither made from metals nor plastics.",
        "premises-FOL": [
            "all x. (Disposable(x) -> DesignedToBeOnlyUsedOnce(x))\nexists x. (EcoFriendly(x))\nall x. (UsedIn(x, TomsHouse) -> ((Disposable(x) & -Reusable(x)) | (-Disposable(x) & Reusable(x))))\nall x. (MadeFrom(x, Metal) -> -MadeFrom(x, Plastic))\nall x. (Reusable(x) -> MadeFrom(x, Metal))\n-(((MadeFrom(ChopsticksUsedInTomsHouse, Metal) & -MadeFrom(ChopsticksUsedInTomsHouse, Plastic)) | (-MadeFrom(ChopsticksUsedInTomsHouse, Metal) & MadeFrom(ChopsticksUsedInTomsHouse, Plastic))))"
        ],
        "conclusion": "If chopsticks used in Tom's house are made from plastic or designed to be used only once, then they are made from plastic and are eco-friendly.",
        "conclusion-FOL": "MadeFrom(Chopsticks, Plastic) | DesignedBeOnlyUsedOnce(Chopsticks) -> MadeFrom(Chopsticks, Plastic) & EcoFriendly(Chopsticks)",
        "label": "ERROR"
    },
    {
        "premises": "Anything lazy is unproductive.\nNo one unproductive is energetic.\nIf something is a sloth, then it is lazy.\nSome animals are sloths.\nSid is neither an energetic person nor a sloth.",
        "premises-FOL": [
            "all x. (Lazy(x) -> Unproductive(x))\nall x. (Unproductive(x) -> -Energetic(x))\nall x. (Sloth(x) -> Lazy(x))\nexists x. (Animal(x) & Sloth(x))\n-Energetic(Sid) & -Sloth(Sid))"
        ],
        "conclusion": "Sid is an animal.",
        "conclusion-FOL": "Animal(Sid)",
        "label": "ERROR"
    },
    {
        "premises": "Anything lazy is unproductive.\nNo one unproductive is energetic.\nIf something is a sloth, then it is lazy.\nSome animals are sloths.\nSid is neither an energetic person nor a sloth.",
        "premises-FOL": [
            "all x. (Lazy(x) -> Unproductive(x))\nall x. (Unproductive(x) -> -Energetic(x))\nall x. (Sloth(x) -> Lazy(x))\nexists x. (Animal(x) & Sloth(x))\n-Energetic(Sid) & -Sloth(Sid))"
        ],
        "conclusion": "Sid is an energetic person and an animal.",
        "conclusion-FOL": "Energetic(Sid) & Animal(Sid)",
        "label": "ERROR"
    },
    {
        "premises": "Anything lazy is unproductive.\nNo one unproductive is energetic.\nIf something is a sloth, then it is lazy.\nSome animals are sloths.\nSid is neither an energetic person nor a sloth.",
        "premises-FOL": [
            "all x. (Lazy(x) -> Unproductive(x))\nall x. (Unproductive(x) -> -Energetic(x))\nall x. (Sloth(x) -> Lazy(x))\nexists x. (Animal(x) & Sloth(x))\n-Energetic(Sid) & -Sloth(Sid))"
        ],
        "conclusion": "If Sid is either an animal or unproductive, then Sid is not an energetic person.",
        "conclusion-FOL": "((Animal(Sid) & -Unproductive(Sid)) | (-Animal(Sid) & Unproductive(Sid)))) -> -Energetic(Sid)",
        "label": "ERROR"
    },
    {
        "premises": "European soccer clubs can attend UCL, UEL, and UECL.\nA soccer club eligible to attend UCL has a higher ranking than a soccer club eligible to attend UEL.\nA soccer club eligible to attend UEL has a higher ranking than a soccer club eligible to attend UECL.\nManchester United and Machester City are both European soccer clubs.\nManchester United is eligible to attend UEL next season.\nManchester City is eligible to attend UCL next season.",
        "premises-FOL": [
            "all x. (EuropeanSoccerClub(x) -> Attend(x, Ucl) | Attend(x, Uel) | Attend(x, Uecl))\nall x. all y. (EuropeanSoccerClub(x) & EuropeanSoccerClub(y) & Attend(x, Ucl) & Attend(y, Uel) -> HigherRank(x, y))\nall x. all y. (EuropeanSoccerClub(x) & EuropeanSoccerClub(y) & Attend(x, Uel) & Attend(y, Uecl) -> HigherRank(x, y))\nEuropeanSoccerClub(ManchesterUnited) & EuropeanSoccerClub(ManchesterCity)\nAttend(Manchesterunited, Uel)\nAttend(Manchestercity, Ucl)"
        ],
        "conclusion": "Manchester City has a higher ranking than Manchester United.",
        "conclusion-FOL": "HigherRank(ManchesterCity, ManchesterUnited)",
        "label": "ERROR"
    },
    {
        "premises": "If a person coaches a football club, the person is a football coach.\nIf a person has a position in a club in a year, and the club is in NFL in the same year, the person plays in NFL.\nMinnesota Vikings is a football club.\nDennis Green coached Minnesota Vikings.\nCris Carter had 13 touchdown receptions.\nMinnesota Vikings were in the National Football League in 1997.\nJohn Randle was Minnesota Vikings defensive tackle in 1997.",
        "premises-FOL": [
            "all x. all y. ((Coach(x, y) & FootballClub(y)) -> FootballCoach(x))\nall w. all x. all y. all z. ((PlayPositionFor(x, w, y, z) & InNFL(y, z)) -> PlayInNFL(x))\nFootballClub(MinnesotaVikings)\nCoach(DennisGreen, MinnesotaVikings)\nReceiveTD(CrisCarter, NumOneThree)\nInNFL(MinnesotaVikings, YrOneNineNineSeven)\nPlayPositionFor(JohnRandle, DefensiveTackle, MinnesotaVikings, YrOneNineNineSeven)"
        ],
        "conclusion": "Dennis Green is a football coach.",
        "conclusion-FOL": "FootballCoach(DennisGreen)",
        "label": "ERROR"
    },
    {
        "premises": "If a person coaches a football club, the person is a football coach.\nIf a person has a position in a club in a year, and the club is in NFL in the same year, the person plays in NFL.\nMinnesota Vikings is a football club.\nDennis Green coached Minnesota Vikings.\nCris Carter had 13 touchdown receptions.\nMinnesota Vikings were in the National Football League in 1997.\nJohn Randle was Minnesota Vikings defensive tackle in 1997.",
        "premises-FOL": [
            "all x. all y. ((Coach(x, y) & FootballClub(y)) -> FootballCoach(x))\nall w. all x. all y. all z. ((PlayPositionFor(x, w, y, z) & InNFL(y, z)) -> PlayInNFL(x))\nFootballClub(MinnesotaVikings)\nCoach(DennisGreen, MinnesotaVikings)\nReceiveTD(CrisCarter, NumOneThree)\nInNFL(MinnesotaVikings, YrOneNineNineSeven)\nPlayPositionFor(JohnRandle, DefensiveTackle, MinnesotaVikings, YrOneNineNineSeven)"
        ],
        "conclusion": "John Randle didn't play in the National Football League.",
        "conclusion-FOL": "-PlayInNFL(JohnRandle)",
        "label": "ERROR"
    },
    {
        "premises": "If a person coaches a football club, the person is a football coach.\nIf a person has a position in a club in a year, and the club is in NFL in the same year, the person plays in NFL.\nMinnesota Vikings is a football club.\nDennis Green coached Minnesota Vikings.\nCris Carter had 13 touchdown receptions.\nMinnesota Vikings were in the National Football League in 1997.\nJohn Randle was Minnesota Vikings defensive tackle in 1997.",
        "premises-FOL": [
            "all x. all y. ((Coach(x, y) & FootballClub(y)) -> FootballCoach(x))\nall w. all x. all y. all z. ((PlayPositionFor(x, w, y, z) & InNFL(y, z)) -> PlayInNFL(x))\nFootballClub(MinnesotaVikings)\nCoach(DennisGreen, MinnesotaVikings)\nReceiveTD(CrisCarter, NumOneThree)\nInNFL(MinnesotaVikings, YrOneNineNineSeven)\nPlayPositionFor(JohnRandle, DefensiveTackle, MinnesotaVikings, YrOneNineNineSeven)"
        ],
        "conclusion": "Cris Carter played for Minnesota Vikings.",
        "conclusion-FOL": "PlayPositionFor(CrisCarter, Wr, MinnesotaVikings, YearOneNineNineSeven)",
        "label": "ERROR"
    },
    {
        "premises": "All classrooms in William L. Harkness Hall that are used for lectures are booked during the day. \nNone of the classrooms in William L. Harkness Hall are private study spots.\nAll classrooms in William L. Harkness Hall are used for lectures or used for office hours.\nIf a classroom in William L. Harkness Hall is booked in the evening, then it is not freely usable at night.\nIf a classroom in William L. Harkness Hall is used for office hours, then it is booked in the evening.\nRoom 116 is a classroom in William L. Harkness Hall that is either both used for lecture and used for office hours or not used for either.",
        "premises-FOL": [
            "all x. (ClassroomIn(x, WilliamLHarknessHall) & UsedFor(x, Lecture) -> BookedDuring(x, Day))\nall x. (ClassroomIn(x, WilliamLHarknessHall) & -PrivateStudySpot(x))\nall x. (ClassroomIn(x, WilliamLHarknessHall) & (UsedFor(x, Lecture) | UsedFor(x, OfficeHours)))\nall x. (ClassroomIn(x, WilliamLHarknessHall) & BookedIn(x, Evening) -> -FreelyUsableAtNight(x))\nall x. (ClassroomIn(x, WilliamLHarknessHall) & UsedFor(x, OfficeHours) -> BookedIn(x, Evening))\nClassroomIn(OneOneSix, WilliamLHarknessHall) & -(((UsedFor(OneOneSix, Lecture) & -UsedFor(OneOneSix, OfficeHours)) | (-UsedFor(OneOneSix, Lecture) & UsedFor(OneOneSix, OfficeHours))))"
        ],
        "conclusion": "Room 116 is a private study spot.",
        "conclusion-FOL": "PrivateStudySpot(RoomOneOneSix)",
        "label": "ERROR"
    },
    {
        "premises": "All classrooms in William L. Harkness Hall that are used for lectures are booked during the day. \nNone of the classrooms in William L. Harkness Hall are private study spots.\nAll classrooms in William L. Harkness Hall are used for lectures or used for office hours.\nIf a classroom in William L. Harkness Hall is booked in the evening, then it is not freely usable at night.\nIf a classroom in William L. Harkness Hall is used for office hours, then it is booked in the evening.\nRoom 116 is a classroom in William L. Harkness Hall that is either both used for lecture and used for office hours or not used for either.",
        "premises-FOL": [
            "all x. (ClassroomIn(x, WilliamLHarknessHall) & UsedFor(x, Lecture) -> BookedDuring(x, Day))\nall x. (ClassroomIn(x, WilliamLHarknessHall) & -PrivateStudySpot(x))\nall x. (ClassroomIn(x, WilliamLHarknessHall) & (UsedFor(x, Lecture) | UsedFor(x, OfficeHours)))\nall x. (ClassroomIn(x, WilliamLHarknessHall) & BookedIn(x, Evening) -> -FreelyUsableAtNight(x))\nall x. (ClassroomIn(x, WilliamLHarknessHall) & UsedFor(x, OfficeHours) -> BookedIn(x, Evening))\nClassroomIn(OneOneSix, WilliamLHarknessHall) & -(((UsedFor(OneOneSix, Lecture) & -UsedFor(OneOneSix, OfficeHours)) | (-UsedFor(OneOneSix, Lecture) & UsedFor(OneOneSix, OfficeHours))))"
        ],
        "conclusion": "If Room 116 is either both booked during the day and freely usable at night, or neither, then it is either used for office hours or for private study spots.",
        "conclusion-FOL": "-(((BookedDuring(RoomOneOneSix, Day) & -FreelyUsableAtNight(RoomOneOneSix)) | (-BookedDuring(RoomOneOneSix, Day) & FreelyUsableAtNight(RoomOneOneSix))) -> (((UsedFor(RoomOneOneSix, OfficeHour) & -PrivateStudySpot(RoomOneOneSix)) | (-UsedFor(RoomOneOneSix, OfficeHour) & PrivateStudySpot(RoomOneOneSix))))",
        "label": "ERROR"
    },
    {
        "premises": "All classrooms in William L. Harkness Hall that are used for lectures are booked during the day. \nNone of the classrooms in William L. Harkness Hall are private study spots.\nAll classrooms in William L. Harkness Hall are used for lectures or used for office hours.\nIf a classroom in William L. Harkness Hall is booked in the evening, then it is not freely usable at night.\nIf a classroom in William L. Harkness Hall is used for office hours, then it is booked in the evening.\nRoom 116 is a classroom in William L. Harkness Hall that is either both used for lecture and used for office hours or not used for either.",
        "premises-FOL": [
            "all x. (ClassroomIn(x, WilliamLHarknessHall) & UsedFor(x, Lecture) -> BookedDuring(x, Day))\nall x. (ClassroomIn(x, WilliamLHarknessHall) & -PrivateStudySpot(x))\nall x. (ClassroomIn(x, WilliamLHarknessHall) & (UsedFor(x, Lecture) | UsedFor(x, OfficeHours)))\nall x. (ClassroomIn(x, WilliamLHarknessHall) & BookedIn(x, Evening) -> -FreelyUsableAtNight(x))\nall x. (ClassroomIn(x, WilliamLHarknessHall) & UsedFor(x, OfficeHours) -> BookedIn(x, Evening))\nClassroomIn(OneOneSix, WilliamLHarknessHall) & -(((UsedFor(OneOneSix, Lecture) & -UsedFor(OneOneSix, OfficeHours)) | (-UsedFor(OneOneSix, Lecture) & UsedFor(OneOneSix, OfficeHours))))"
        ],
        "conclusion": "If Room 116 is not both a private study spot and freely useable at night, then it is either used for lectures or booked during the day.",
        "conclusion-FOL": "-(PrivateStudySpot(RoomOneOneSix) & FreelyUsableAtNight(RoomOneOneSix)) -> (UsedFor(RoomOneOneSix, Lecture) | BookedIn(RoomOneOneSix, Evening))",
        "label": "ERROR"
    },
    {
        "premises": "Shafaq-Asiman is a large complex of offshore geological structures in the Caspian Sea.\nBaku is northwest of Shafaq-Asiman.\nIf place A is northwest of place B, then place B is southeast of place A.",
        "premises-FOL": [
            "LargeComplex(Shafaq-Asiman) & LargeComplex(Shafaq-Asiman) & Offshore(Shafaq-Asiman) & GeologicalStructures(Shafaq-Asiman) & In(Shafaq-Asiman, Caspiansea)\nNorthwestOf(Baku, Shafaq-Asiman)\nall x. all y. (NorthwestOf(x, y) -> SoutheastOf(y, x))"
        ],
        "conclusion": "Baku is southeast of Shafaq-Asiman.",
        "conclusion-FOL": "SoutheastOf(Baku, Shafaq-Asiman)",
        "label": "ERROR"
    },
    {
        "premises": "Shafaq-Asiman is a large complex of offshore geological structures in the Caspian Sea.\nBaku is northwest of Shafaq-Asiman.\nIf place A is northwest of place B, then place B is southeast of place A.",
        "premises-FOL": [
            "LargeComplex(Shafaq-Asiman) & LargeComplex(Shafaq-Asiman) & Offshore(Shafaq-Asiman) & GeologicalStructures(Shafaq-Asiman) & In(Shafaq-Asiman, Caspiansea)\nNorthwestOf(Baku, Shafaq-Asiman)\nall x. all y. (NorthwestOf(x, y) -> SoutheastOf(y, x))"
        ],
        "conclusion": "A large complex is southeast of Baku.",
        "conclusion-FOL": "exists x. (LargeComplex(x) & SoutheastOf(x, Baku))",
        "label": "ERROR"
    },
    {
        "premises": "Shafaq-Asiman is a large complex of offshore geological structures in the Caspian Sea.\nBaku is northwest of Shafaq-Asiman.\nIf place A is northwest of place B, then place B is southeast of place A.",
        "premises-FOL": [
            "LargeComplex(Shafaq-Asiman) & LargeComplex(Shafaq-Asiman) & Offshore(Shafaq-Asiman) & GeologicalStructures(Shafaq-Asiman) & In(Shafaq-Asiman, Caspiansea)\nNorthwestOf(Baku, Shafaq-Asiman)\nall x. all y. (NorthwestOf(x, y) -> SoutheastOf(y, x))"
        ],
        "conclusion": "Baku is not northwest of offshore geological structures.",
        "conclusion-FOL": "all x. (GeologicalStructures(x) & Offshore(x) -> -NorthwestOf(Baku, x))",
        "label": "ERROR"
    },
    {
        "premises": "Herodicus was a Greek physician, dietician, sophist, and gymnast.\nHerodicus was born in the city of Selymbria.\nSelymbria is a colony of the city-state Megara.\nOne of the tutors of Hippocrates was Herodicus.\nMassages were recommended by Herodicus.\nSome of the theories of Herodicus are considered to be the foundation of sports medicine.",
        "premises-FOL": [
            "Greek(Herodicus) & Physician(Herodicus) & Dietician(Herodicus) & Sophist(Herodicus) & Gymnast(Herodicus)\nBorn(Herodicus, Selymbia) & City(Selymbia)\nColony(Selymbia, Megara) & CityState(Megara)\nTutor(Herodicus, Hippocrates)\nRecommend(Herodicus, Massages)\nexists x. exists y. (Theory(x) & From(x, Herodicus) & FoundationOf(x, SportsMedicine) & (-(x=y)) & Theory(y) & From(y, Herodicus) & FoundationOf(y, SportsMedicine))"
        ],
        "conclusion": "Herodicus tutored Hippocrates.",
        "conclusion-FOL": "Tutor(Herodicus, Hippocrates)",
        "label": "ERROR"
    },
    {
        "premises": "Herodicus was a Greek physician, dietician, sophist, and gymnast.\nHerodicus was born in the city of Selymbria.\nSelymbria is a colony of the city-state Megara.\nOne of the tutors of Hippocrates was Herodicus.\nMassages were recommended by Herodicus.\nSome of the theories of Herodicus are considered to be the foundation of sports medicine.",
        "premises-FOL": [
            "Greek(Herodicus) & Physician(Herodicus) & Dietician(Herodicus) & Sophist(Herodicus) & Gymnast(Herodicus)\nBorn(Herodicus, Selymbia) & City(Selymbia)\nColony(Selymbia, Megara) & CityState(Megara)\nTutor(Herodicus, Hippocrates)\nRecommend(Herodicus, Massages)\nexists x. exists y. (Theory(x) & From(x, Herodicus) & FoundationOf(x, SportsMedicine) & (-(x=y)) & Theory(y) & From(y, Herodicus) & FoundationOf(y, SportsMedicine))"
        ],
        "conclusion": "Herodicus was tutored by Hippocrates.",
        "conclusion-FOL": "Tutor(Hippocrates, Herodicus)",
        "label": "ERROR"
    },
    {
        "premises": "Herodicus was a Greek physician, dietician, sophist, and gymnast.\nHerodicus was born in the city of Selymbria.\nSelymbria is a colony of the city-state Megara.\nOne of the tutors of Hippocrates was Herodicus.\nMassages were recommended by Herodicus.\nSome of the theories of Herodicus are considered to be the foundation of sports medicine.",
        "premises-FOL": [
            "Greek(Herodicus) & Physician(Herodicus) & Dietician(Herodicus) & Sophist(Herodicus) & Gymnast(Herodicus)\nBorn(Herodicus, Selymbia) & City(Selymbia)\nColony(Selymbia, Megara) & CityState(Megara)\nTutor(Herodicus, Hippocrates)\nRecommend(Herodicus, Massages)\nexists x. exists y. (Theory(x) & From(x, Herodicus) & FoundationOf(x, SportsMedicine) & (-(x=y)) & Theory(y) & From(y, Herodicus) & FoundationOf(y, SportsMedicine))"
        ],
        "conclusion": "Herodicus was born in a city-state.",
        "conclusion-FOL": "exists x. (Born(Herodicus, x) & CityState(x))",
        "label": "ERROR"
    },
    {
        "premises": "Herodicus was a Greek physician, dietician, sophist, and gymnast.\nHerodicus was born in the city of Selymbria.\nSelymbria is a colony of the city-state Megara.\nOne of the tutors of Hippocrates was Herodicus.\nMassages were recommended by Herodicus.\nSome of the theories of Herodicus are considered to be the foundation of sports medicine.",
        "premises-FOL": [
            "Greek(Herodicus) & Physician(Herodicus) & Dietician(Herodicus) & Sophist(Herodicus) & Gymnast(Herodicus)\nBorn(Herodicus, Selymbia) & City(Selymbia)\nColony(Selymbia, Megara) & CityState(Megara)\nTutor(Herodicus, Hippocrates)\nRecommend(Herodicus, Massages)\nexists x. exists y. (Theory(x) & From(x, Herodicus) & FoundationOf(x, SportsMedicine) & (-(x=y)) & Theory(y) & From(y, Herodicus) & FoundationOf(y, SportsMedicine))"
        ],
        "conclusion": "Herodicus did not recommend massages.",
        "conclusion-FOL": "-Recommend(Herodicus, Massages)",
        "label": "ERROR"
    },
    {
        "premises": "Herodicus was a Greek physician, dietician, sophist, and gymnast.\nHerodicus was born in the city of Selymbria.\nSelymbria is a colony of the city-state Megara.\nOne of the tutors of Hippocrates was Herodicus.\nMassages were recommended by Herodicus.\nSome of the theories of Herodicus are considered to be the foundation of sports medicine.",
        "premises-FOL": [
            "Greek(Herodicus) & Physician(Herodicus) & Dietician(Herodicus) & Sophist(Herodicus) & Gymnast(Herodicus)\nBorn(Herodicus, Selymbia) & City(Selymbia)\nColony(Selymbia, Megara) & CityState(Megara)\nTutor(Herodicus, Hippocrates)\nRecommend(Herodicus, Massages)\nexists x. exists y. (Theory(x) & From(x, Herodicus) & FoundationOf(x, SportsMedicine) & (-(x=y)) & Theory(y) & From(y, Herodicus) & FoundationOf(y, SportsMedicine))"
        ],
        "conclusion": "Herodicus was born in a colony of a city-state.",
        "conclusion-FOL": "exists x. exists y. (Born(Herodicus, x) & Colony(x, y) & CityState(y))",
        "label": "ERROR"
    },
    {
        "premises": "None of the kids in our family love the opera.\nAll of the adults in our family love the opera.\nIf someone in our family is a scientist, then they are an adult.\nSome students in our family are kids.\nBilly is a kid in our family.",
        "premises-FOL": [
            "all x. ((Kid(x) & In(x, OurFamily)) -> -Love(x, Opera))\nall x. ((Adult(x) & In(x, OurFamily)) -> Love(x, Opera))\nall x. ((Scientist(x) & In(x, OurFamily)) -> Adult(x))\nexists x. (Student(x) & In(x, OurFamily) & Kid(x))\nKid(Billy) & In(Billy, OurFamily) "
        ],
        "conclusion": "Billy is a student.",
        "conclusion-FOL": "Student(Billy)",
        "label": "ERROR"
    },
    {
        "premises": "None of the kids in our family love the opera.\nAll of the adults in our family love the opera.\nIf someone in our family is a scientist, then they are an adult.\nSome students in our family are kids.\nBilly is a kid in our family.",
        "premises-FOL": [
            "all x. ((Kid(x) & In(x, OurFamily)) -> -Love(x, Opera))\nall x. ((Adult(x) & In(x, OurFamily)) -> Love(x, Opera))\nall x. ((Scientist(x) & In(x, OurFamily)) -> Adult(x))\nexists x. (Student(x) & In(x, OurFamily) & Kid(x))\nKid(Billy) & In(Billy, OurFamily) "
        ],
        "conclusion": "Billy is a student and a scientist.",
        "conclusion-FOL": "Student(Billy)  & Scientist(Billy)",
        "label": "ERROR"
    },
    {
        "premises": "None of the kids in our family love the opera.\nAll of the adults in our family love the opera.\nIf someone in our family is a scientist, then they are an adult.\nSome students in our family are kids.\nBilly is a kid in our family.",
        "premises-FOL": [
            "all x. ((Kid(x) & In(x, OurFamily)) -> -Love(x, Opera))\nall x. ((Adult(x) & In(x, OurFamily)) -> Love(x, Opera))\nall x. ((Scientist(x) & In(x, OurFamily)) -> Adult(x))\nexists x. (Student(x) & In(x, OurFamily) & Kid(x))\nKid(Billy) & In(Billy, OurFamily) "
        ],
        "conclusion": "If Billy is a student or a scientist, then Billy is a student and a kid.",
        "conclusion-FOL": "(Student(Billy) | Scientist(Billy)) -> (Student(Billy) & Kid(Billy))",
        "label": "ERROR"
    },
    {
        "premises": "Brian Winter is a Scottish football referee.\nAfter being injured, Brian Winter retired in 2012.\nBrian Winter was appointed as a referee observer after his retirement.\nSome football referees become referee observers.\nThe son of Brian Winter, Andy Winter, is a football player who plays for Hamilton Academical.",
        "premises-FOL": [
            "Scottish(BrianWinter) & FootballReferee(BrianWinter)\nRetired(BrianWinter) & RetiredIn(BrianWinter, YrTwoZeroOneTwo)\nRefereeObserver(BrianWinter)\nexists x. (FootballReferee(x) & RefereeObserver(x))\nSonOf(AndyWinter, BrianWinter) & FootballPlayer(AndyWinter) & PlaysFor(AndyWinter, HamiltonAcademical)"
        ],
        "conclusion": "There is a son of a referee observer that plays football.",
        "conclusion-FOL": "exists x. exists y.(SonOf(x, y) & RefereeObserver(y) & FootballPlayer(x))",
        "label": "ERROR"
    },
    {
        "premises": "Brian Winter is a Scottish football referee.\nAfter being injured, Brian Winter retired in 2012.\nBrian Winter was appointed as a referee observer after his retirement.\nSome football referees become referee observers.\nThe son of Brian Winter, Andy Winter, is a football player who plays for Hamilton Academical.",
        "premises-FOL": [
            "Scottish(BrianWinter) & FootballReferee(BrianWinter)\nRetired(BrianWinter) & RetiredIn(BrianWinter, YrTwoZeroOneTwo)\nRefereeObserver(BrianWinter)\nexists x. (FootballReferee(x) & RefereeObserver(x))\nSonOf(AndyWinter, BrianWinter) & FootballPlayer(AndyWinter) & PlaysFor(AndyWinter, HamiltonAcademical)"
        ],
        "conclusion": "Brian Winter was not a referee observer.",
        "conclusion-FOL": "-RefereeObserver(Brianwinter)",
        "label": "ERROR"
    },
    {
        "premises": "Brian Winter is a Scottish football referee.\nAfter being injured, Brian Winter retired in 2012.\nBrian Winter was appointed as a referee observer after his retirement.\nSome football referees become referee observers.\nThe son of Brian Winter, Andy Winter, is a football player who plays for Hamilton Academical.",
        "premises-FOL": [
            "Scottish(BrianWinter) & FootballReferee(BrianWinter)\nRetired(BrianWinter) & RetiredIn(BrianWinter, YrTwoZeroOneTwo)\nRefereeObserver(BrianWinter)\nexists x. (FootballReferee(x) & RefereeObserver(x))\nSonOf(AndyWinter, BrianWinter) & FootballPlayer(AndyWinter) & PlaysFor(AndyWinter, HamiltonAcademical)"
        ],
        "conclusion": "Brian Winter is retired.",
        "conclusion-FOL": "Retired(Brianwinter)",
        "label": "ERROR"
    },
    {
        "premises": "Brian Winter is a Scottish football referee.\nAfter being injured, Brian Winter retired in 2012.\nBrian Winter was appointed as a referee observer after his retirement.\nSome football referees become referee observers.\nThe son of Brian Winter, Andy Winter, is a football player who plays for Hamilton Academical.",
        "premises-FOL": [
            "Scottish(BrianWinter) & FootballReferee(BrianWinter)\nRetired(BrianWinter) & RetiredIn(BrianWinter, YrTwoZeroOneTwo)\nRefereeObserver(BrianWinter)\nexists x. (FootballReferee(x) & RefereeObserver(x))\nSonOf(AndyWinter, BrianWinter) & FootballPlayer(AndyWinter) & PlaysFor(AndyWinter, HamiltonAcademical)"
        ],
        "conclusion": "Andy Winter is a referee.",
        "conclusion-FOL": "Referee(Andywinter)",
        "label": "ERROR"
    },
    {
        "premises": "Everyone at 'Board Game night' is interested in puzzles, or they are bad at chess, or both.\nIf a person at 'Board Game night' is bad at chess, then they don't play a lot of chess.\nThere is a person at 'Board Game night' who is either a planner or a creative person.\nErica is at 'Board Game night,' and she is someone who plays a lot of chess.\nIf Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or she is neither of these things.",
        "premises-FOL": [
            "all x. (At(x, BoardGameNight) -> (InterestedIn(x, Puzzle) | BadAt(x, Chess)))\nall x. ((At(x, BoardGameNight) & BadAt(x, Chess)) -> -PlaysOften(x, Chess))\nexists x. (At(x, BoardGameNight) & (Planner(x) | Creative(x)))\nAt(Erica, BoardGameNight) & PlaysOften(Erica, Chess)\n(At(Erica, BoardGameNight) & (-(BadAt(Erica, Chess) | Creative(Erica)))) -> -(Planner(Erica) \u2295  Creative(Erica))"
        ],
        "conclusion": "Erica plans.",
        "conclusion-FOL": "Planner(Erica)",
        "label": "ERROR"
    },
    {
        "premises": "Everyone at 'Board Game night' is interested in puzzles, or they are bad at chess, or both.\nIf a person at 'Board Game night' is bad at chess, then they don't play a lot of chess.\nThere is a person at 'Board Game night' who is either a planner or a creative person.\nErica is at 'Board Game night,' and she is someone who plays a lot of chess.\nIf Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or she is neither of these things.",
        "premises-FOL": [
            "all x. (At(x, BoardGameNight) -> (InterestedIn(x, Puzzle) | BadAt(x, Chess)))\nall x. ((At(x, BoardGameNight) & BadAt(x, Chess)) -> -PlaysOften(x, Chess))\nexists x. (At(x, BoardGameNight) & (Planner(x) | Creative(x)))\nAt(Erica, BoardGameNight) & PlaysOften(Erica, Chess)\n(At(Erica, BoardGameNight) & (-(BadAt(Erica, Chess) | Creative(Erica)))) -> -(Planner(Erica) \u2295  Creative(Erica))"
        ],
        "conclusion": "Erica is interested in puzzles and is creative.",
        "conclusion-FOL": "InterestedIn(Erica, Puzzle) & Creative(Erica)",
        "label": "ERROR"
    },
    {
        "premises": "Everyone at 'Board Game night' is interested in puzzles, or they are bad at chess, or both.\nIf a person at 'Board Game night' is bad at chess, then they don't play a lot of chess.\nThere is a person at 'Board Game night' who is either a planner or a creative person.\nErica is at 'Board Game night,' and she is someone who plays a lot of chess.\nIf Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or she is neither of these things.",
        "premises-FOL": [
            "all x. (At(x, BoardGameNight) -> (InterestedIn(x, Puzzle) | BadAt(x, Chess)))\nall x. ((At(x, BoardGameNight) & BadAt(x, Chess)) -> -PlaysOften(x, Chess))\nexists x. (At(x, BoardGameNight) & (Planner(x) | Creative(x)))\nAt(Erica, BoardGameNight) & PlaysOften(Erica, Chess)\n(At(Erica, BoardGameNight) & (-(BadAt(Erica, Chess) | Creative(Erica)))) -> -(Planner(Erica) \u2295  Creative(Erica))"
        ],
        "conclusion": "Erica is either interested in puzzles or is creative.",
        "conclusion-FOL": "((InterestedIn(Erica, Puzzle) & -Creative(Erica)) | (-InterestedIn(Erica, Puzzle) & Creative(Erica)))",
        "label": "ERROR"
    },
    {
        "premises": "Everyone at 'Board Game night' is interested in puzzles, or they are bad at chess, or both.\nIf a person at 'Board Game night' is bad at chess, then they don't play a lot of chess.\nThere is a person at 'Board Game night' who is either a planner or a creative person.\nErica is at 'Board Game night,' and she is someone who plays a lot of chess.\nIf Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or she is neither of these things.",
        "premises-FOL": [
            "all x. (At(x, BoardGameNight) -> (InterestedIn(x, Puzzle) | BadAt(x, Chess)))\nall x. ((At(x, BoardGameNight) & BadAt(x, Chess)) -> -PlaysOften(x, Chess))\nexists x. (At(x, BoardGameNight) & (Planner(x) | Creative(x)))\nAt(Erica, BoardGameNight) & PlaysOften(Erica, Chess)\n(At(Erica, BoardGameNight) & (-(BadAt(Erica, Chess) | Creative(Erica)))) -> -(Planner(Erica) \u2295  Creative(Erica))"
        ],
        "conclusion": "If Erica plans ahead or plays a lot of chess matches, then Erica is not interested in puzzles and creative.",
        "conclusion-FOL": "Planner(Erica) | PlaysOften(Erica, Chess))) -> (-(InterestedIn(Erica, Puzzle) & Creative(Erica))",
        "label": "ERROR"
    },
    {
        "premises": "Everyone at 'Board Game night' is interested in puzzles, or they are bad at chess, or both.\nIf a person at 'Board Game night' is bad at chess, then they don't play a lot of chess.\nThere is a person at 'Board Game night' who is either a planner or a creative person.\nErica is at 'Board Game night,' and she is someone who plays a lot of chess.\nIf Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or she is neither of these things.",
        "premises-FOL": [
            "all x. (At(x, BoardGameNight) -> (InterestedIn(x, Puzzle) | BadAt(x, Chess)))\nall x. ((At(x, BoardGameNight) & BadAt(x, Chess)) -> -PlaysOften(x, Chess))\nexists x. (At(x, BoardGameNight) & (Planner(x) | Creative(x)))\nAt(Erica, BoardGameNight) & PlaysOften(Erica, Chess)\n(At(Erica, BoardGameNight) & (-(BadAt(Erica, Chess) | Creative(Erica)))) -> -(Planner(Erica) \u2295  Creative(Erica))"
        ],
        "conclusion": "If Erica is creative, then Erica is not interested in puzzles and creative.",
        "conclusion-FOL": "Creative(Erica)) -> (-(InterestedIn(Erica, Puzzle) & Creative(Erica))",
        "label": "ERROR"
    },
    {
        "premises": "Everyone at 'Board Game night' is interested in puzzles, or they are bad at chess, or both.\nIf a person at 'Board Game night' is bad at chess, then they don't play a lot of chess.\nThere is a person at 'Board Game night' who is either a planner or a creative person.\nErica is at 'Board Game night,' and she is someone who plays a lot of chess.\nIf Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or she is neither of these things.",
        "premises-FOL": [
            "all x. (At(x, BoardGameNight) -> (InterestedIn(x, Puzzle) | BadAt(x, Chess)))\nall x. ((At(x, BoardGameNight) & BadAt(x, Chess)) -> -PlaysOften(x, Chess))\nexists x. (At(x, BoardGameNight) & (Planner(x) | Creative(x)))\nAt(Erica, BoardGameNight) & PlaysOften(Erica, Chess)\n(At(Erica, BoardGameNight) & (-(BadAt(Erica, Chess) | Creative(Erica)))) -> -(Planner(Erica) \u2295  Creative(Erica))"
        ],
        "conclusion": "If Erica is interested in puzzles and is creative, then Erica is not creative.",
        "conclusion-FOL": "InterestedIn(Erica, Puzzle) & Creative(Erica)) -> -Creative(Erica)",
        "label": "ERROR"
    },
    {
        "premises": "Everyone at 'Board Game night' is interested in puzzles, or they are bad at chess, or both.\nIf a person at 'Board Game night' is bad at chess, then they don't play a lot of chess.\nThere is a person at 'Board Game night' who is either a planner or a creative person.\nErica is at 'Board Game night,' and she is someone who plays a lot of chess.\nIf Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or she is neither of these things.",
        "premises-FOL": [
            "all x. (At(x, BoardGameNight) -> (InterestedIn(x, Puzzle) | BadAt(x, Chess)))\nall x. ((At(x, BoardGameNight) & BadAt(x, Chess)) -> -PlaysOften(x, Chess))\nexists x. (At(x, BoardGameNight) & (Planner(x) | Creative(x)))\nAt(Erica, BoardGameNight) & PlaysOften(Erica, Chess)\n(At(Erica, BoardGameNight) & (-(BadAt(Erica, Chess) | Creative(Erica)))) -> -(Planner(Erica) \u2295  Creative(Erica))"
        ],
        "conclusion": "If Erica either plays a lot of chess matches or is creative, then Erica is neither interested in puzzles nor a person who plays a lot of chess matches.",
        "conclusion-FOL": "((PlaysOften(Erica, Chess) & -InterestedIn(Erica, Puzzle)) | (-PlaysOften(Erica, Chess) & InterestedIn(Erica, Puzzle))) -> -(InterestedIn(Erica, Puzzle) | PlaysOften(Erica, Chess))",
        "label": "ERROR"
    },
    {
        "premises": "Everyone at 'Board Game night' is interested in puzzles, or they are bad at chess, or both.\nIf a person at 'Board Game night' is bad at chess, then they don't play a lot of chess.\nThere is a person at 'Board Game night' who is either a planner or a creative person.\nErica is at 'Board Game night,' and she is someone who plays a lot of chess.\nIf Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or she is neither of these things.",
        "premises-FOL": [
            "all x. (At(x, BoardGameNight) -> (InterestedIn(x, Puzzle) | BadAt(x, Chess)))\nall x. ((At(x, BoardGameNight) & BadAt(x, Chess)) -> -PlaysOften(x, Chess))\nexists x. (At(x, BoardGameNight) & (Planner(x) | Creative(x)))\nAt(Erica, BoardGameNight) & PlaysOften(Erica, Chess)\n(At(Erica, BoardGameNight) & (-(BadAt(Erica, Chess) | Creative(Erica)))) -> -(Planner(Erica) \u2295  Creative(Erica))"
        ],
        "conclusion": "If Erica is interested in puzzles and plays a lot of chess matches, then Erica is either a person who plays a lot of chess matches or a person that is creative.",
        "conclusion-FOL": "((PlaysOften(Erica, Chess) & -InterestedIn(Erica, Puzzle)) | (-PlaysOften(Erica, Chess) & InterestedIn(Erica, Puzzle)))) -> -(InterestedIn(Erica, Puzzle) | PlaysOften(Erica, Chess)",
        "label": "ERROR"
    },
    {
        "premises": "Everyone at 'Board Game night' is interested in puzzles, or they are bad at chess, or both.\nIf a person at 'Board Game night' is bad at chess, then they don't play a lot of chess.\nThere is a person at 'Board Game night' who is either a planner or a creative person.\nErica is at 'Board Game night,' and she is someone who plays a lot of chess.\nIf Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or she is neither of these things.",
        "premises-FOL": [
            "all x. (At(x, BoardGameNight) -> (InterestedIn(x, Puzzle) | BadAt(x, Chess)))\nall x. ((At(x, BoardGameNight) & BadAt(x, Chess)) -> -PlaysOften(x, Chess))\nexists x. (At(x, BoardGameNight) & (Planner(x) | Creative(x)))\nAt(Erica, BoardGameNight) & PlaysOften(Erica, Chess)\n(At(Erica, BoardGameNight) & (-(BadAt(Erica, Chess) | Creative(Erica)))) -> -(Planner(Erica) \u2295  Creative(Erica))"
        ],
        "conclusion": "If Erica plans ahead or is interested in puzzles, then Erica is creative.",
        "conclusion-FOL": "Planner(Erica) | InterestedIn(Erica, Puzzle) -> Creative(Erica)",
        "label": "ERROR"
    },
    {
        "premises": "Everyone at 'Board Game night' is interested in puzzles, or they are bad at chess, or both.\nIf a person at 'Board Game night' is bad at chess, then they don't play a lot of chess.\nThere is a person at 'Board Game night' who is either a planner or a creative person.\nErica is at 'Board Game night,' and she is someone who plays a lot of chess.\nIf Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or she is neither of these things.",
        "premises-FOL": [
            "all x. (At(x, BoardGameNight) -> (InterestedIn(x, Puzzle) | BadAt(x, Chess)))\nall x. ((At(x, BoardGameNight) & BadAt(x, Chess)) -> -PlaysOften(x, Chess))\nexists x. (At(x, BoardGameNight) & (Planner(x) | Creative(x)))\nAt(Erica, BoardGameNight) & PlaysOften(Erica, Chess)\n(At(Erica, BoardGameNight) & (-(BadAt(Erica, Chess) | Creative(Erica)))) -> -(Planner(Erica) \u2295  Creative(Erica))"
        ],
        "conclusion": "If Erica is either bad at chess or interested in puzzles, then Erica is not a person who plays a lot of chess matches and creative.",
        "conclusion-FOL": "((BadAt(Erica, Chess) & -InterestedIn(Erica, Puzzle)) | (-BadAt(Erica, Chess) & InterestedIn(Erica, Puzzle))) -> -(PlaysOften(Erica, Chess) & Creative(Erica))",
        "label": "ERROR"
    },
    {
        "premises": "Soccer players have a right foot and a left foot.\nTop soccer players are soccer players who can use both the left foot and right foot very efficiently.\nIf a soccer player can score many goals using the left foot, they can use that foot very efficiently.\nIf a soccer player can score many goals using the right foot, they can use that foot very efficiently.\nCristiano Ronaldo is a soccer player.\nCristiano Ronaldo can use his right foot very efficiently.\nCristiano Ronaldo has scored many goals using his left foot.",
        "premises-FOL": [
            "all x. (SoccerPlayer(x) -> Have(x, LeftFoot) & Have(x, RightFoot))\nall x. (SoccerPlayer(x) & UseEfficiently(x, LeftFoot) & UseEfficiently(x, RightFoot) -> TopSoccerPlayer(x))\nall x. (SoccerPlayer(x) & ScoreUsing(x, ManyGoals, LeftFoot) -> UseEfficiently(x, LeftFoot))\nall x. (SoccerPlayer(x) & ScoreUsing(x, ManyGoals, RightFoot) -> UseEfficiently(x, RightFoot))\nSoccerPlayer(Ronaldo)\nUseEfficiently(Ronaldo, RightFoot)\nScoreUsing(Ronaldo, ManyGoals, LeftFoot)"
        ],
        "conclusion": "Cristiano Ronaldo is a top soccer player.",
        "conclusion-FOL": "TopSoccerPlayer(Ronaldo)",
        "label": "ERROR"
    },
    {
        "premises": "Soccer players have a right foot and a left foot.\nTop soccer players are soccer players who can use both the left foot and right foot very efficiently.\nIf a soccer player can score many goals using the left foot, they can use that foot very efficiently.\nIf a soccer player can score many goals using the right foot, they can use that foot very efficiently.\nCristiano Ronaldo is a soccer player.\nCristiano Ronaldo can use his right foot very efficiently.\nCristiano Ronaldo has scored many goals using his left foot.",
        "premises-FOL": [
            "all x. (SoccerPlayer(x) -> Have(x, LeftFoot) & Have(x, RightFoot))\nall x. (SoccerPlayer(x) & UseEfficiently(x, LeftFoot) & UseEfficiently(x, RightFoot) -> TopSoccerPlayer(x))\nall x. (SoccerPlayer(x) & ScoreUsing(x, ManyGoals, LeftFoot) -> UseEfficiently(x, LeftFoot))\nall x. (SoccerPlayer(x) & ScoreUsing(x, ManyGoals, RightFoot) -> UseEfficiently(x, RightFoot))\nSoccerPlayer(Ronaldo)\nUseEfficiently(Ronaldo, RightFoot)\nScoreUsing(Ronaldo, ManyGoals, LeftFoot)"
        ],
        "conclusion": "Cristiano Ronaldo is not a top soccer player.",
        "conclusion-FOL": "-TopSoccerPlayer(Ronaldo)",
        "label": "ERROR"
    },
    {
        "premises": "The National Lobster Hatchery is a hatchery located in Padstow, England.\nThe National Lobster Hatchery is open to visitors.\nA hatchery is either for profit or for conservation.\nIf a hatchery is for conservation, it might release animals into the wild.\nThe National Lobster Hatchery is not for profit.",
        "premises-FOL": [
            "Hatchery(NationalLobsterHatchery) & LocatedIn(NationalLobsterHatchery, PadstowEngland)\nOpenToVisitor(NationalLobsterHatchery)\nall x. (Hatchery(x) -> ((ForConservation(x) & -ForProfit(x)) | (-ForConservation(x) & ForProfit(x))))\nexists x. (Hatchery(x) & ForConservation(x) & ReleaseAnimalToWild(x))\n-ForProfit(NationalLobsterHatchery)"
        ],
        "conclusion": "The National Lobster Hatchery is for conservation.",
        "conclusion-FOL": "ForConservation(NationalLobsterhatchery)",
        "label": "ERROR"
    },
    {
        "premises": "The National Lobster Hatchery is a hatchery located in Padstow, England.\nThe National Lobster Hatchery is open to visitors.\nA hatchery is either for profit or for conservation.\nIf a hatchery is for conservation, it might release animals into the wild.\nThe National Lobster Hatchery is not for profit.",
        "premises-FOL": [
            "Hatchery(NationalLobsterHatchery) & LocatedIn(NationalLobsterHatchery, PadstowEngland)\nOpenToVisitor(NationalLobsterHatchery)\nall x. (Hatchery(x) -> ((ForConservation(x) & -ForProfit(x)) | (-ForConservation(x) & ForProfit(x))))\nexists x. (Hatchery(x) & ForConservation(x) & ReleaseAnimalToWild(x))\n-ForProfit(NationalLobsterHatchery)"
        ],
        "conclusion": "All hatcheries are open to visitors.",
        "conclusion-FOL": "all x. (Hatchery(x) -> OpenToVisitors(x))",
        "label": "ERROR"
    },
    {
        "premises": "The National Lobster Hatchery is a hatchery located in Padstow, England.\nThe National Lobster Hatchery is open to visitors.\nA hatchery is either for profit or for conservation.\nIf a hatchery is for conservation, it might release animals into the wild.\nThe National Lobster Hatchery is not for profit.",
        "premises-FOL": [
            "Hatchery(NationalLobsterHatchery) & LocatedIn(NationalLobsterHatchery, PadstowEngland)\nOpenToVisitor(NationalLobsterHatchery)\nall x. (Hatchery(x) -> ((ForConservation(x) & -ForProfit(x)) | (-ForConservation(x) & ForProfit(x))))\nexists x. (Hatchery(x) & ForConservation(x) & ReleaseAnimalToWild(x))\n-ForProfit(NationalLobsterHatchery)"
        ],
        "conclusion": "The National Lobster Hatchery releases animals into the wild.",
        "conclusion-FOL": "ReleaseAnimalToWild(NationalLobsterhatchery)",
        "label": "ERROR"
    },
    {
        "premises": "Rhos Aelwyd F.C. is a Welsh football club.\nRhos Aelwyd F.C. is the only football club located in Ponciau. \nThe Premier Division was won in June 2005 by a team from Ponciau. \nThe winner of the Premier Division in October 2009 was promoted to the Cymru Alliance.\nThe Premier Division in October 2009 was won by the same team that won in June 2005. ",
        "premises-FOL": [
            "all x. (Rhosaelwydfc(x) -> FootballClub(x) & Welsh(x))\nall x. (FootballClub(x) & LocatedIn(x, Ponciau) <-> Rhosaelwydfc(x))\nexists x. (LocatedIn(x, Ponciau) & WonPremierDivisionDuring(x, YearTwoZeroZeroFiveMonthJune))\nall x. (WonPremierDivisionDuring(x, YearTwoZeroZeroNineMonthOctober) -> PromotedTo(x, CymruAlliance))\nall x. (WonPremierDivisionDuring(x, YearTwoZeroZeroNineMonthOctober) <-> WonPremierDivisionDuring(x, yTwoZeroZeroFiveMonthJune))"
        ],
        "conclusion": "Rhos Aelwyd F.C. won Premier Division in June 2005.",
        "conclusion-FOL": "exists x. (Rhosaelwydfc(x) & WonPremierDivisionDuring(x, YearTwoZeroZeroFiveMonthJune))",
        "label": "ERROR"
    },
    {
        "premises": "Rhos Aelwyd F.C. is a Welsh football club.\nRhos Aelwyd F.C. is the only football club located in Ponciau. \nThe Premier Division was won in June 2005 by a team from Ponciau. \nThe winner of the Premier Division in October 2009 was promoted to the Cymru Alliance.\nThe Premier Division in October 2009 was won by the same team that won in June 2005. ",
        "premises-FOL": [
            "all x. (Rhosaelwydfc(x) -> FootballClub(x) & Welsh(x))\nall x. (FootballClub(x) & LocatedIn(x, Ponciau) <-> Rhosaelwydfc(x))\nexists x. (LocatedIn(x, Ponciau) & WonPremierDivisionDuring(x, YearTwoZeroZeroFiveMonthJune))\nall x. (WonPremierDivisionDuring(x, YearTwoZeroZeroNineMonthOctober) -> PromotedTo(x, CymruAlliance))\nall x. (WonPremierDivisionDuring(x, YearTwoZeroZeroNineMonthOctober) <-> WonPremierDivisionDuring(x, yTwoZeroZeroFiveMonthJune))"
        ],
        "conclusion": "Rhos Aelwyd F.C. was promoted to the Cymru Alliance.",
        "conclusion-FOL": "exists x. (Rhosaelwydfc(x) & PromotedTo(x, CymruAlliance))",
        "label": "ERROR"
    },
    {
        "premises": "A Unix operating system used in the lab computers is a piece of software.\nAll versions of MacOS used in the lab computer are based on Unix operating systems.\nA lab computer uses either MacOS or Linux. \nAll Linux computers in the lab are convenient.\nAll software used in the lab computers is written with code.\nIf something is convenient in the lab computer, then it is popular.\nBurger is used in the lab computer, and it is written with code and a new version of MacOS.\nPyTorch is used in the lab computer, and PyTorch is neither a Linux system nor a piece of software.",
        "premises-FOL": [
            "all x. (UsedIn(x, LabComputer) & UnixOperatingSystem(x) -> Software(x))\nall x. (UsedIn(x, LabComputer) & MacOS(x) -> UnixOperatingSystem(x))\nall x. (UsedIn(x, LabComputer) -> ((MacOS(x) & -Linux(x)) | (-MacOS(x) & Linux(x))))\nall x. (UsedIn(x, LabComputer) & Linux(x) -> Convenient(x))\nall x. (UsedIn(x, LabComputer) & Software(x) -> WrittenWithCode(x))\nall x. (UsedIn(x, LabComputer) & Convenient(x) -> Popular(x))\nUsedIn(Burger, LabComputer) & WrittenWithCode(Burger) & MacOS(Burger))\nUsedIn(Pytorch, LabComputer) & -(((Linux(Pytorch) & -Software(Pytorch)) | (-Linux(Pytorch) & Software(Pytorch))))"
        ],
        "conclusion": "Burger is popular.",
        "conclusion-FOL": "Popular(Burger)",
        "label": "ERROR"
    },
    {
        "premises": "A Unix operating system used in the lab computers is a piece of software.\nAll versions of MacOS used in the lab computer are based on Unix operating systems.\nA lab computer uses either MacOS or Linux. \nAll Linux computers in the lab are convenient.\nAll software used in the lab computers is written with code.\nIf something is convenient in the lab computer, then it is popular.\nBurger is used in the lab computer, and it is written with code and a new version of MacOS.\nPyTorch is used in the lab computer, and PyTorch is neither a Linux system nor a piece of software.",
        "premises-FOL": [
            "all x. (UsedIn(x, LabComputer) & UnixOperatingSystem(x) -> Software(x))\nall x. (UsedIn(x, LabComputer) & MacOS(x) -> UnixOperatingSystem(x))\nall x. (UsedIn(x, LabComputer) -> ((MacOS(x) & -Linux(x)) | (-MacOS(x) & Linux(x))))\nall x. (UsedIn(x, LabComputer) & Linux(x) -> Convenient(x))\nall x. (UsedIn(x, LabComputer) & Software(x) -> WrittenWithCode(x))\nall x. (UsedIn(x, LabComputer) & Convenient(x) -> Popular(x))\nUsedIn(Burger, LabComputer) & WrittenWithCode(Burger) & MacOS(Burger))\nUsedIn(Pytorch, LabComputer) & -(((Linux(Pytorch) & -Software(Pytorch)) | (-Linux(Pytorch) & Software(Pytorch))))"
        ],
        "conclusion": "Burger is not popular.",
        "conclusion-FOL": "-Popular(Burger)",
        "label": "ERROR"
    },
    {
        "premises": "A Unix operating system used in the lab computers is a piece of software.\nAll versions of MacOS used in the lab computer are based on Unix operating systems.\nA lab computer uses either MacOS or Linux. \nAll Linux computers in the lab are convenient.\nAll software used in the lab computers is written with code.\nIf something is convenient in the lab computer, then it is popular.\nBurger is used in the lab computer, and it is written with code and a new version of MacOS.\nPyTorch is used in the lab computer, and PyTorch is neither a Linux system nor a piece of software.",
        "premises-FOL": [
            "all x. (UsedIn(x, LabComputer) & UnixOperatingSystem(x) -> Software(x))\nall x. (UsedIn(x, LabComputer) & MacOS(x) -> UnixOperatingSystem(x))\nall x. (UsedIn(x, LabComputer) -> ((MacOS(x) & -Linux(x)) | (-MacOS(x) & Linux(x))))\nall x. (UsedIn(x, LabComputer) & Linux(x) -> Convenient(x))\nall x. (UsedIn(x, LabComputer) & Software(x) -> WrittenWithCode(x))\nall x. (UsedIn(x, LabComputer) & Convenient(x) -> Popular(x))\nUsedIn(Burger, LabComputer) & WrittenWithCode(Burger) & MacOS(Burger))\nUsedIn(Pytorch, LabComputer) & -(((Linux(Pytorch) & -Software(Pytorch)) | (-Linux(Pytorch) & Software(Pytorch))))"
        ],
        "conclusion": "PyTorch is popular and written with code.",
        "conclusion-FOL": "Popular(Pytorch) & WrittenWithCode(Pytorch)",
        "label": "ERROR"
    },
    {
        "premises": "A Unix operating system used in the lab computers is a piece of software.\nAll versions of MacOS used in the lab computer are based on Unix operating systems.\nA lab computer uses either MacOS or Linux. \nAll Linux computers in the lab are convenient.\nAll software used in the lab computers is written with code.\nIf something is convenient in the lab computer, then it is popular.\nBurger is used in the lab computer, and it is written with code and a new version of MacOS.\nPyTorch is used in the lab computer, and PyTorch is neither a Linux system nor a piece of software.",
        "premises-FOL": [
            "all x. (UsedIn(x, LabComputer) & UnixOperatingSystem(x) -> Software(x))\nall x. (UsedIn(x, LabComputer) & MacOS(x) -> UnixOperatingSystem(x))\nall x. (UsedIn(x, LabComputer) -> ((MacOS(x) & -Linux(x)) | (-MacOS(x) & Linux(x))))\nall x. (UsedIn(x, LabComputer) & Linux(x) -> Convenient(x))\nall x. (UsedIn(x, LabComputer) & Software(x) -> WrittenWithCode(x))\nall x. (UsedIn(x, LabComputer) & Convenient(x) -> Popular(x))\nUsedIn(Burger, LabComputer) & WrittenWithCode(Burger) & MacOS(Burger))\nUsedIn(Pytorch, LabComputer) & -(((Linux(Pytorch) & -Software(Pytorch)) | (-Linux(Pytorch) & Software(Pytorch))))"
        ],
        "conclusion": "PyTorch is not popular and it is not written with code.",
        "conclusion-FOL": "-(Popular(Pytorch) & WrittenWithCode(Pytorch))",
        "label": "ERROR"
    },
    {
        "premises": "Roads are made of either concrete or asphalt.\nRoads made of concrete last longer than roads made with asphalt.\nRoads made of asphalt are smoother than roads made of concrete.\nEveryone prefers the smoother of two roads. \nThe first road is made of concrete, and the second road is made of asphalt.",
        "premises-FOL": [
            "all x. (Road(x) -> (((MadeOf(x, Concrete) & -MadeOf(x, Asphalt)) | (-MadeOf(x, Concrete) & MadeOf(x, Asphalt))))\nall x. all y. (Road(x) & MadeOf(x, Concrete) & Road(y) & MadeOf(y, Asphalt) -> LastLonger(x, y))\nall x. all y. (Road(x) & MadeOf(x, Asphalt) & Road(y) & MadeOf(y, Concrete) -> Smoother(x, y))\nall x. all y. all z. (Road(x) & Road(y) & Smoother(x, y) -> Prefer(z, x))\nRoad(FirstRoad) & MadeOf(SecondRoad, Concrete) & Road(FirstRoad) & MadeOf(SecondRoad, Asphalt)"
        ],
        "conclusion": "The first road will last longer than the second road.",
        "conclusion-FOL": "LastLonger(FirstRoad, SecondRoad)",
        "label": "ERROR"
    },
    {
        "premises": "Roads are made of either concrete or asphalt.\nRoads made of concrete last longer than roads made with asphalt.\nRoads made of asphalt are smoother than roads made of concrete.\nEveryone prefers the smoother of two roads. \nThe first road is made of concrete, and the second road is made of asphalt.",
        "premises-FOL": [
            "all x. (Road(x) -> (((MadeOf(x, Concrete) & -MadeOf(x, Asphalt)) | (-MadeOf(x, Concrete) & MadeOf(x, Asphalt))))\nall x. all y. (Road(x) & MadeOf(x, Concrete) & Road(y) & MadeOf(y, Asphalt) -> LastLonger(x, y))\nall x. all y. (Road(x) & MadeOf(x, Asphalt) & Road(y) & MadeOf(y, Concrete) -> Smoother(x, y))\nall x. all y. all z. (Road(x) & Road(y) & Smoother(x, y) -> Prefer(z, x))\nRoad(FirstRoad) & MadeOf(SecondRoad, Concrete) & Road(FirstRoad) & MadeOf(SecondRoad, Asphalt)"
        ],
        "conclusion": "The second road is not smoother than the first one.",
        "conclusion-FOL": "-Smoother(FirstRoad, SecondRoad)",
        "label": "ERROR"
    },
    {
        "premises": "Roads are made of either concrete or asphalt.\nRoads made of concrete last longer than roads made with asphalt.\nRoads made of asphalt are smoother than roads made of concrete.\nEveryone prefers the smoother of two roads. \nThe first road is made of concrete, and the second road is made of asphalt.",
        "premises-FOL": [
            "all x. (Road(x) -> (((MadeOf(x, Concrete) & -MadeOf(x, Asphalt)) | (-MadeOf(x, Concrete) & MadeOf(x, Asphalt))))\nall x. all y. (Road(x) & MadeOf(x, Concrete) & Road(y) & MadeOf(y, Asphalt) -> LastLonger(x, y))\nall x. all y. (Road(x) & MadeOf(x, Asphalt) & Road(y) & MadeOf(y, Concrete) -> Smoother(x, y))\nall x. all y. all z. (Road(x) & Road(y) & Smoother(x, y) -> Prefer(z, x))\nRoad(FirstRoad) & MadeOf(SecondRoad, Concrete) & Road(FirstRoad) & MadeOf(SecondRoad, Asphalt)"
        ],
        "conclusion": "John prefers the second road.",
        "conclusion-FOL": "Prefer(John, SecondRoad)",
        "label": "ERROR"
    },
    {
        "premises": "Camp Davern is a traditional summer camp for boys and girls.\nCamp Davern was established in the year 1946.\nCamp Davern was operated by the YMCA until the year 2015.\nCamp Davern is an old summer camp.",
        "premises-FOL": [
            "TraditionalSummerCamp(CampDavern) & ForBoysAndGirls(CampDavern)\nEstablishedIn(CampDavern, YearOneNineFourSix)\nOperatedUntil(yMCA, CampDavern, YearTwoZeroOneFive)\nOld(CampDavern)"
        ],
        "conclusion": "One of Ontario's oldest summer camps is a traditional summer camp for boys and girls.",
        "conclusion-FOL": "exists x. (Old(x) & TraditionalSummerCamp(x) & ForBoysAndGirls(x))",
        "label": "ERROR"
    },
    {
        "premises": "Camp Davern is a traditional summer camp for boys and girls.\nCamp Davern was established in the year 1946.\nCamp Davern was operated by the YMCA until the year 2015.\nCamp Davern is an old summer camp.",
        "premises-FOL": [
            "TraditionalSummerCamp(CampDavern) & ForBoysAndGirls(CampDavern)\nEstablishedIn(CampDavern, YearOneNineFourSix)\nOperatedUntil(yMCA, CampDavern, YearTwoZeroOneFive)\nOld(CampDavern)"
        ],
        "conclusion": "A traditional summer camp for boys and girls was operated by the YMCA until the year 2015.",
        "conclusion-FOL": "exists x. (TraditionalSummerCamp(x) & ForBoysAndGirls(x) & OperatedUntil(YMCA, x, YearTwoZeroOneFive))",
        "label": "ERROR"
    },
    {
        "premises": "Camp Davern is a traditional summer camp for boys and girls.\nCamp Davern was established in the year 1946.\nCamp Davern was operated by the YMCA until the year 2015.\nCamp Davern is an old summer camp.",
        "premises-FOL": [
            "TraditionalSummerCamp(CampDavern) & ForBoysAndGirls(CampDavern)\nEstablishedIn(CampDavern, YearOneNineFourSix)\nOperatedUntil(yMCA, CampDavern, YearTwoZeroOneFive)\nOld(CampDavern)"
        ],
        "conclusion": "Camp Davern was established in 1989.",
        "conclusion-FOL": "EstablishedIn(Campdavern, YearOneNineEightNine)",
        "label": "ERROR"
    },
    {
        "premises": "If Emily's friends publish journals, then they do not work in the entertainment industry.\nAll of Emily's friends who are award-winning novelists publish journals.\nEmily's friends work in the entertainment industry or are highly acclaimed in their profession.\nIf Emily's friends are highly acclaimed in their profession, then they often hold tenured and high-ranking positions at their workplace.\nIf Emily's friends are highly acclaimed in their profession, then they often receive glowing feedback and recommendations from their colleagues.\nTaylor is Emily's friend.\nIt is not true that Taylor both holds highly acclaimed in her profession and often holds tenured and high-ranking positions at her workplace.",
        "premises-FOL": [
            "all x. (EmilysFriend(x) & Publish(x, Journal) -> -WorkIn(x, EntertainmentIndustry))\nall x. (EmilysFriend(x) & AwardWinningNovelist(x) -> Publish(x, Journal))\nall x. (EmilysFriend(x) -> WorkIn(x, EntertainmentIndustry) | HighlyAcclaimedIn(x, TheirProfession))\nall x. (EmilysFriend(x) & HighlyAcclaimedIn(x, TheirProfession) -> exists y. (HoldAt(x, y, WorkPlace) & Tenured(y) & HighRanking(y) & Position(y)))\nall x. (EmilysFriend(x) & HighlyAcclaimedIn(x, TheirProfession) -> ReceiveFrom(x, GlowingFeedback, Colleague) & ReceiveFrom(x, GlowingRecommendation, Colleague))\nEmilysFriends(Taylor) \n-(HighlyAcclaimedIn(Taylor, TheirProfession) & (exists y. (HoldAt(Taylor, y, WorkPlace) & Tenured(y) & HighRanking(y) & Position(y)))"
        ],
        "conclusion": "Taylor is Emily's friend and she often holds tenured and high-ranking positions at her workplace.",
        "conclusion-FOL": "EmilysFriends(Taylor) & (exists y. (HoldAt(Taylor, y, WorkPlace) & Tenured(y) & HighRanking(y) & Position(y)))",
        "label": "ERROR"
    },
    {
        "premises": "If Emily's friends publish journals, then they do not work in the entertainment industry.\nAll of Emily's friends who are award-winning novelists publish journals.\nEmily's friends work in the entertainment industry or are highly acclaimed in their profession.\nIf Emily's friends are highly acclaimed in their profession, then they often hold tenured and high-ranking positions at their workplace.\nIf Emily's friends are highly acclaimed in their profession, then they often receive glowing feedback and recommendations from their colleagues.\nTaylor is Emily's friend.\nIt is not true that Taylor both holds highly acclaimed in her profession and often holds tenured and high-ranking positions at her workplace.",
        "premises-FOL": [
            "all x. (EmilysFriend(x) & Publish(x, Journal) -> -WorkIn(x, EntertainmentIndustry))\nall x. (EmilysFriend(x) & AwardWinningNovelist(x) -> Publish(x, Journal))\nall x. (EmilysFriend(x) -> WorkIn(x, EntertainmentIndustry) | HighlyAcclaimedIn(x, TheirProfession))\nall x. (EmilysFriend(x) & HighlyAcclaimedIn(x, TheirProfession) -> exists y. (HoldAt(x, y, WorkPlace) & Tenured(y) & HighRanking(y) & Position(y)))\nall x. (EmilysFriend(x) & HighlyAcclaimedIn(x, TheirProfession) -> ReceiveFrom(x, GlowingFeedback, Colleague) & ReceiveFrom(x, GlowingRecommendation, Colleague))\nEmilysFriends(Taylor) \n-(HighlyAcclaimedIn(Taylor, TheirProfession) & (exists y. (HoldAt(Taylor, y, WorkPlace) & Tenured(y) & HighRanking(y) & Position(y)))"
        ],
        "conclusion": "Taylor is Emily's friend and she often receives glowing feedback and recommendations from their colleagues and is an award-winning novelist.",
        "conclusion-FOL": "EmilysFriends(Taylor) & (Receive(Taylor, GlowingFeedback, Colleague) & Receive(Taylor, GlowingRecommendation, Colleague) & AwardWinningNovelist(Taylor))",
        "label": "ERROR"
    },
    {
        "premises": "If Emily's friends publish journals, then they do not work in the entertainment industry.\nAll of Emily's friends who are award-winning novelists publish journals.\nEmily's friends work in the entertainment industry or are highly acclaimed in their profession.\nIf Emily's friends are highly acclaimed in their profession, then they often hold tenured and high-ranking positions at their workplace.\nIf Emily's friends are highly acclaimed in their profession, then they often receive glowing feedback and recommendations from their colleagues.\nTaylor is Emily's friend.\nIt is not true that Taylor both holds highly acclaimed in her profession and often holds tenured and high-ranking positions at her workplace.",
        "premises-FOL": [
            "all x. (EmilysFriend(x) & Publish(x, Journal) -> -WorkIn(x, EntertainmentIndustry))\nall x. (EmilysFriend(x) & AwardWinningNovelist(x) -> Publish(x, Journal))\nall x. (EmilysFriend(x) -> WorkIn(x, EntertainmentIndustry) | HighlyAcclaimedIn(x, TheirProfession))\nall x. (EmilysFriend(x) & HighlyAcclaimedIn(x, TheirProfession) -> exists y. (HoldAt(x, y, WorkPlace) & Tenured(y) & HighRanking(y) & Position(y)))\nall x. (EmilysFriend(x) & HighlyAcclaimedIn(x, TheirProfession) -> ReceiveFrom(x, GlowingFeedback, Colleague) & ReceiveFrom(x, GlowingRecommendation, Colleague))\nEmilysFriends(Taylor) \n-(HighlyAcclaimedIn(Taylor, TheirProfession) & (exists y. (HoldAt(Taylor, y, WorkPlace) & Tenured(y) & HighRanking(y) & Position(y)))"
        ],
        "conclusion": "Taylor is Emily's friend and she does not both publish journals and is an award-winning novelist.",
        "conclusion-FOL": "EmilysFriends(Taylor) & -(Publish(Taylor, Journal) & AwardWinningNovelist(Taylor))",
        "label": "ERROR"
    },
    {
        "premises": "Thick as Thieves is a young adult fantasy novel written by Megan Whalen Turner.\nThick as Thieves was published by Greenwillow Books.\nIf a book was published by a company, then the author of that book worked with the company that published the book.\nThe fictional Mede Empire is where Thick as Thieves is set.\nThe Mede Empire plots to swallow up some nearby countries.\nAttolia and Sounis are countries near the Mede Empire.\nThick as Thieves was sold both as a hardcover and an e-book.",
        "premises-FOL": [
            "YoungAdultFantasy(ThickAsTheives) & Novel(ThickAsTheives) & WrittenBy(ThickAsTheives, MeganWhalenTurner)\nPublishedBy(ThickAsTheives, GreenWillowBooks)\nall x. all y. all z. ((WrittenBy(x, y) & PublishedBy(x, z)) -> WorkedWith(y, z))\nFictional(MedeEmpire) & SetIn(ThickAsTheives, MedeEmpire)\nexists x. exists y. ((Country(x) & Near(x, MedeEmpire) & PlotsToSwallowUp(MedeEmpire, x)) & (-(x=y) & Near(y, MedeEmpire) & PlotsToSwallowUp(MedeEmpire, y)))\nCountry(Attolia) & Near(Attolia, MedeEmpire) & Country(Sounis) & Near(Sounis, MedeEmpire)\nSoldAs(ThickAsTheives, HardCover) & SoldAs(ThickAsTheives, SoftCover)"
        ],
        "conclusion": "Megan Whalen Turner worked with Greenwillow Books.",
        "conclusion-FOL": "WorkedWith(WhalenTurner, GreenWillowbooks)",
        "label": "ERROR"
    },
    {
        "premises": "Thick as Thieves is a young adult fantasy novel written by Megan Whalen Turner.\nThick as Thieves was published by Greenwillow Books.\nIf a book was published by a company, then the author of that book worked with the company that published the book.\nThe fictional Mede Empire is where Thick as Thieves is set.\nThe Mede Empire plots to swallow up some nearby countries.\nAttolia and Sounis are countries near the Mede Empire.\nThick as Thieves was sold both as a hardcover and an e-book.",
        "premises-FOL": [
            "YoungAdultFantasy(ThickAsTheives) & Novel(ThickAsTheives) & WrittenBy(ThickAsTheives, MeganWhalenTurner)\nPublishedBy(ThickAsTheives, GreenWillowBooks)\nall x. all y. all z. ((WrittenBy(x, y) & PublishedBy(x, z)) -> WorkedWith(y, z))\nFictional(MedeEmpire) & SetIn(ThickAsTheives, MedeEmpire)\nexists x. exists y. ((Country(x) & Near(x, MedeEmpire) & PlotsToSwallowUp(MedeEmpire, x)) & (-(x=y) & Near(y, MedeEmpire) & PlotsToSwallowUp(MedeEmpire, y)))\nCountry(Attolia) & Near(Attolia, MedeEmpire) & Country(Sounis) & Near(Sounis, MedeEmpire)\nSoldAs(ThickAsTheives, HardCover) & SoldAs(ThickAsTheives, SoftCover)"
        ],
        "conclusion": "The Mede Empire plans to swallow up Attolia.",
        "conclusion-FOL": "PlotsToSwallowUp(MedeEmpire, Attolia)",
        "label": "ERROR"
    },
    {
        "premises": "Thick as Thieves is a young adult fantasy novel written by Megan Whalen Turner.\nThick as Thieves was published by Greenwillow Books.\nIf a book was published by a company, then the author of that book worked with the company that published the book.\nThe fictional Mede Empire is where Thick as Thieves is set.\nThe Mede Empire plots to swallow up some nearby countries.\nAttolia and Sounis are countries near the Mede Empire.\nThick as Thieves was sold both as a hardcover and an e-book.",
        "premises-FOL": [
            "YoungAdultFantasy(ThickAsTheives) & Novel(ThickAsTheives) & WrittenBy(ThickAsTheives, MeganWhalenTurner)\nPublishedBy(ThickAsTheives, GreenWillowBooks)\nall x. all y. all z. ((WrittenBy(x, y) & PublishedBy(x, z)) -> WorkedWith(y, z))\nFictional(MedeEmpire) & SetIn(ThickAsTheives, MedeEmpire)\nexists x. exists y. ((Country(x) & Near(x, MedeEmpire) & PlotsToSwallowUp(MedeEmpire, x)) & (-(x=y) & Near(y, MedeEmpire) & PlotsToSwallowUp(MedeEmpire, y)))\nCountry(Attolia) & Near(Attolia, MedeEmpire) & Country(Sounis) & Near(Sounis, MedeEmpire)\nSoldAs(ThickAsTheives, HardCover) & SoldAs(ThickAsTheives, SoftCover)"
        ],
        "conclusion": "Thick as Thieves is not set in the Mede Empire.",
        "conclusion-FOL": "-SetIn(ThickAsTheives, MedeEmpire)",
        "label": "ERROR"
    },
    {
        "premises": "Thick as Thieves is a young adult fantasy novel written by Megan Whalen Turner.\nThick as Thieves was published by Greenwillow Books.\nIf a book was published by a company, then the author of that book worked with the company that published the book.\nThe fictional Mede Empire is where Thick as Thieves is set.\nThe Mede Empire plots to swallow up some nearby countries.\nAttolia and Sounis are countries near the Mede Empire.\nThick as Thieves was sold both as a hardcover and an e-book.",
        "premises-FOL": [
            "YoungAdultFantasy(ThickAsTheives) & Novel(ThickAsTheives) & WrittenBy(ThickAsTheives, MeganWhalenTurner)\nPublishedBy(ThickAsTheives, GreenWillowBooks)\nall x. all y. all z. ((WrittenBy(x, y) & PublishedBy(x, z)) -> WorkedWith(y, z))\nFictional(MedeEmpire) & SetIn(ThickAsTheives, MedeEmpire)\nexists x. exists y. ((Country(x) & Near(x, MedeEmpire) & PlotsToSwallowUp(MedeEmpire, x)) & (-(x=y) & Near(y, MedeEmpire) & PlotsToSwallowUp(MedeEmpire, y)))\nCountry(Attolia) & Near(Attolia, MedeEmpire) & Country(Sounis) & Near(Sounis, MedeEmpire)\nSoldAs(ThickAsTheives, HardCover) & SoldAs(ThickAsTheives, SoftCover)"
        ],
        "conclusion": "Megan Whalen Turner did not work with Greenwillow Books.",
        "conclusion-FOL": "-WorkedWith(Megan, GreenWillowbooks)",
        "label": "ERROR"
    },
    {
        "premises": "WeTab is a MeeGo-based tablet computer.\nWeTab was announced by Neofonie.\nNeofonie is a German producer.\nGermans live in Germany or abroad. ",
        "premises-FOL": [
            "MeeGoBased(WeTab) & TabletComputer(WeTab)\nall x. (AnnouncedBy(WeTab, Neofonie))\nGerman(Neofonie) & Producer(Neofonie)\nall x. (German(x) -> ((LiveIn(x, German) & -LiveAbroad(x)) | (-LiveIn(x, German) & LiveAbroad(x))))"
        ],
        "conclusion": "There is a tablet computer announced by a German producer.",
        "conclusion-FOL": "exists x. exists y. (TabletComputer(x) & German(y) & Producer(y) & AnnouncedBy(x, y))",
        "label": "ERROR"
    },
    {
        "premises": "WeTab is a MeeGo-based tablet computer.\nWeTab was announced by Neofonie.\nNeofonie is a German producer.\nGermans live in Germany or abroad. ",
        "premises-FOL": [
            "MeeGoBased(WeTab) & TabletComputer(WeTab)\nall x. (AnnouncedBy(WeTab, Neofonie))\nGerman(Neofonie) & Producer(Neofonie)\nall x. (German(x) -> ((LiveIn(x, German) & -LiveAbroad(x)) | (-LiveIn(x, German) & LiveAbroad(x))))"
        ],
        "conclusion": "Neofonie doesn't speak English or German.",
        "conclusion-FOL": "-Speak(Neofonie, English) & -Speak(Neofonie, German)",
        "label": "ERROR"
    },
    {
        "premises": "Some employees in James's town who work in business analysis are good at math. \nAll of the employees in James's town who work in business analysis are working for this company. \nNone of the employees in James's town who work for this company are from China. \nAll of the employees in James's town working in software engineering are from China. \nLeif is an employee in James's town, and he is working in software engineering.  ",
        "premises-FOL": [
            "exists x. exists y. (EmployeeIn(x, JamesSTown) & WorkIn(x, BusinessAnalysis) & GoodAt(x, Math) & (-(x=y)) & EmployeeIn(y, JamesSTown) & WorkIn(y, BusinessAnalysis) & GoodAt(y, Math))\nall x. ((EmployeeIn(x, JamesSTown) & WorkIn(x, BusinessAnalysis)) -> WorkFor(x, ThisCompany))\nall x. ((EmployeeIn(x, JamesSTown) & WorkFor(x, ThisCompany)) -> -From(x, China))\nall x. (EmployeeIn(x, JamesSTown) & WorkIn(x, SoftwareEngineering) -> From(x, China))\nEmployeeIn(Leif, JamesSTown) & WorkIn(Leif, SoftwareEngineering)"
        ],
        "conclusion": "Leif is good at math.",
        "conclusion-FOL": "EmployeesInJamesSTown(Leif) & GoodAt(Leif, Math)",
        "label": "ERROR"
    },
    {
        "premises": "Some employees in James's town who work in business analysis are good at math. \nAll of the employees in James's town who work in business analysis are working for this company. \nNone of the employees in James's town who work for this company are from China. \nAll of the employees in James's town working in software engineering are from China. \nLeif is an employee in James's town, and he is working in software engineering.  ",
        "premises-FOL": [
            "exists x. exists y. (EmployeeIn(x, JamesSTown) & WorkIn(x, BusinessAnalysis) & GoodAt(x, Math) & (-(x=y)) & EmployeeIn(y, JamesSTown) & WorkIn(y, BusinessAnalysis) & GoodAt(y, Math))\nall x. ((EmployeeIn(x, JamesSTown) & WorkIn(x, BusinessAnalysis)) -> WorkFor(x, ThisCompany))\nall x. ((EmployeeIn(x, JamesSTown) & WorkFor(x, ThisCompany)) -> -From(x, China))\nall x. (EmployeeIn(x, JamesSTown) & WorkIn(x, SoftwareEngineering) -> From(x, China))\nEmployeeIn(Leif, JamesSTown) & WorkIn(Leif, SoftwareEngineering)"
        ],
        "conclusion": "Leif is not both good at math and working in business analysis.",
        "conclusion-FOL": "-(GoodAt(Leif, Math) & WorkIn(Leif, BusinessAnalysis))",
        "label": "ERROR"
    },
    {
        "premises": "Some employees in James's town who work in business analysis are good at math. \nAll of the employees in James's town who work in business analysis are working for this company. \nNone of the employees in James's town who work for this company are from China. \nAll of the employees in James's town working in software engineering are from China. \nLeif is an employee in James's town, and he is working in software engineering.  ",
        "premises-FOL": [
            "exists x. exists y. (EmployeeIn(x, JamesSTown) & WorkIn(x, BusinessAnalysis) & GoodAt(x, Math) & (-(x=y)) & EmployeeIn(y, JamesSTown) & WorkIn(y, BusinessAnalysis) & GoodAt(y, Math))\nall x. ((EmployeeIn(x, JamesSTown) & WorkIn(x, BusinessAnalysis)) -> WorkFor(x, ThisCompany))\nall x. ((EmployeeIn(x, JamesSTown) & WorkFor(x, ThisCompany)) -> -From(x, China))\nall x. (EmployeeIn(x, JamesSTown) & WorkIn(x, SoftwareEngineering) -> From(x, China))\nEmployeeIn(Leif, JamesSTown) & WorkIn(Leif, SoftwareEngineering)"
        ],
        "conclusion": "If Leif is not both good at math and in business analysis, then he is neither working in this company nor working in software engineering.",
        "conclusion-FOL": "-(GoodAt(Leif, Math) & WorkIn(Leif, BusinessAnalysis)) -> (-WorkFor(x, ThisCompany) & -WorkIn(x, SoftwareEngineering))",
        "label": "ERROR"
    },
    {
        "premises": "The party provides five kinds of fruits: strawberry, orange, blueberry, grape, and cherry.\nIf the fruit had the lowest remaining weight at the end of the party, then it means it was the most popular fruit.\nAt the end of the party, strawberries had the lowest remaining weight.\nAt the end of the party, the number of leftover blueberries was lower than that of cherries.\nBenjamin only ate oranges and grapes at the party.",
        "premises-FOL": [
            "Provide(Party, Strawberry) & Provide(Party, Orange) & Provide(Party, Blueberry) & Provide(Party, Grape) & Provide(Party, Cherry) \nall x. (LowestWeightRemainingAt(x, EndOfParty) -> MostPopular(x)) \nLowestWeightRemainingAt(Strawberries, EndOfParty)\nLowerWeightAt(Blueberry, Cherry, EndOfParty)\nEat(Benjamin, Orange) & Eat(Benjamin, Grape) & -Eat(Benjamin, Blueberry) & -Eat(Benjamin, Cherry) & -Eat(Benjamin, Strawberry)"
        ],
        "conclusion": "Blueberries were the most popular fruit at the party.",
        "conclusion-FOL": "MostPopular(Blueberry)",
        "label": "ERROR"
    },
    {
        "premises": "The party provides five kinds of fruits: strawberry, orange, blueberry, grape, and cherry.\nIf the fruit had the lowest remaining weight at the end of the party, then it means it was the most popular fruit.\nAt the end of the party, strawberries had the lowest remaining weight.\nAt the end of the party, the number of leftover blueberries was lower than that of cherries.\nBenjamin only ate oranges and grapes at the party.",
        "premises-FOL": [
            "Provide(Party, Strawberry) & Provide(Party, Orange) & Provide(Party, Blueberry) & Provide(Party, Grape) & Provide(Party, Cherry) \nall x. (LowestWeightRemainingAt(x, EndOfParty) -> MostPopular(x)) \nLowestWeightRemainingAt(Strawberries, EndOfParty)\nLowerWeightAt(Blueberry, Cherry, EndOfParty)\nEat(Benjamin, Orange) & Eat(Benjamin, Grape) & -Eat(Benjamin, Blueberry) & -Eat(Benjamin, Cherry) & -Eat(Benjamin, Strawberry)"
        ],
        "conclusion": "Cherries were the most popular fruit at the party.",
        "conclusion-FOL": "MostPopular(Cherry)",
        "label": "ERROR"
    },
    {
        "premises": "The party provides five kinds of fruits: strawberry, orange, blueberry, grape, and cherry.\nIf the fruit had the lowest remaining weight at the end of the party, then it means it was the most popular fruit.\nAt the end of the party, strawberries had the lowest remaining weight.\nAt the end of the party, the number of leftover blueberries was lower than that of cherries.\nBenjamin only ate oranges and grapes at the party.",
        "premises-FOL": [
            "Provide(Party, Strawberry) & Provide(Party, Orange) & Provide(Party, Blueberry) & Provide(Party, Grape) & Provide(Party, Cherry) \nall x. (LowestWeightRemainingAt(x, EndOfParty) -> MostPopular(x)) \nLowestWeightRemainingAt(Strawberries, EndOfParty)\nLowerWeightAt(Blueberry, Cherry, EndOfParty)\nEat(Benjamin, Orange) & Eat(Benjamin, Grape) & -Eat(Benjamin, Blueberry) & -Eat(Benjamin, Cherry) & -Eat(Benjamin, Strawberry)"
        ],
        "conclusion": "Benjamin ate blueberries at the party.",
        "conclusion-FOL": "Eat(Blueberry, Benjamin)",
        "label": "ERROR"
    },
    {
        "premises": "All students who attend in person have registered for the conference. \nStudents either attend the conference in person or remotely. \nNo students from China attend the conference remotely. \nJames attends the conference, but he does not attend the conference remotely.\nJack attends the conference, and he is a student from China.",
        "premises-FOL": [
            "all x. (AttendInPerson(x) -> Registered(x))\nall x. (Attend(x) -> (((AttendInPerson(x) & -AttendRemotely(x)) | (-AttendInPerson(x) & AttendRemotely(x)))))\nall x. ((Attend(x) & FromChina(x)) -> -AttendRemotely(x))\nAttend(James) & (-AttendRemotely(James))\nFromChina(Jack) & Attend(Jack)"
        ],
        "conclusion": "James attends the conference but not in person.",
        "conclusion-FOL": "Attend(James) & (-AttendInPerson(James))",
        "label": "ERROR"
    },
    {
        "premises": "All students who attend in person have registered for the conference. \nStudents either attend the conference in person or remotely. \nNo students from China attend the conference remotely. \nJames attends the conference, but he does not attend the conference remotely.\nJack attends the conference, and he is a student from China.",
        "premises-FOL": [
            "all x. (AttendInPerson(x) -> Registered(x))\nall x. (Attend(x) -> (((AttendInPerson(x) & -AttendRemotely(x)) | (-AttendInPerson(x) & AttendRemotely(x)))))\nall x. ((Attend(x) & FromChina(x)) -> -AttendRemotely(x))\nAttend(James) & (-AttendRemotely(James))\nFromChina(Jack) & Attend(Jack)"
        ],
        "conclusion": "Jack attends the conference in person.",
        "conclusion-FOL": "Attend(Jack) & AttendInPerson(Jack)",
        "label": "ERROR"
    },
    {
        "premises": "All students who attend in person have registered for the conference. \nStudents either attend the conference in person or remotely. \nNo students from China attend the conference remotely. \nJames attends the conference, but he does not attend the conference remotely.\nJack attends the conference, and he is a student from China.",
        "premises-FOL": [
            "all x. (AttendInPerson(x) -> Registered(x))\nall x. (Attend(x) -> (((AttendInPerson(x) & -AttendRemotely(x)) | (-AttendInPerson(x) & AttendRemotely(x)))))\nall x. ((Attend(x) & FromChina(x)) -> -AttendRemotely(x))\nAttend(James) & (-AttendRemotely(James))\nFromChina(Jack) & Attend(Jack)"
        ],
        "conclusion": "Jack has registered for the conference.",
        "conclusion-FOL": "Registered(Jack)",
        "label": "ERROR"
    },
    {
        "premises": "David Ha'ivri is a political strategist. \nIf you are born in Israel to at least one Israeli parent, you receive Israeli citizenship at birth. \nDavid Ha'ivri emigrated to the United States from Israel, where he was born to Israeli parents. \nSeveral Zionist leaders have been elected to the Shomron Regional Municipal council. \nDavid Ha'ivri is a Zionist leader.",
        "premises-FOL": [
            "PoliticalStrategist(DavidHaivri)\nall x. exists y. (BornInIsrael(x) & ParentOf(y, x) & Israeli(y) -> Israeli(x))\nexists x. (EmigratedTo(DavidHaivri, America) & BornInIsrael(DavidHaivri) & ParentOf(DavidHaivri, x) & Israeli(x))\nexists x. (ZionistLeader(x) & ElectedTo(x, ShomronMunicipalCouncil))\nZionstLeader(DavidHaivri)"
        ],
        "conclusion": "David Ha'ivri is an Israeli citizen.",
        "conclusion-FOL": "IsraeliCitizen(DavidHaivri)",
        "label": "ERROR"
    },
    {
        "premises": "David Ha'ivri is a political strategist. \nIf you are born in Israel to at least one Israeli parent, you receive Israeli citizenship at birth. \nDavid Ha'ivri emigrated to the United States from Israel, where he was born to Israeli parents. \nSeveral Zionist leaders have been elected to the Shomron Regional Municipal council. \nDavid Ha'ivri is a Zionist leader.",
        "premises-FOL": [
            "PoliticalStrategist(DavidHaivri)\nall x. exists y. (BornInIsrael(x) & ParentOf(y, x) & Israeli(y) -> Israeli(x))\nexists x. (EmigratedTo(DavidHaivri, America) & BornInIsrael(DavidHaivri) & ParentOf(DavidHaivri, x) & Israeli(x))\nexists x. (ZionistLeader(x) & ElectedTo(x, ShomronMunicipalCouncil))\nZionstLeader(DavidHaivri)"
        ],
        "conclusion": "David Ha'ivri is a United States citizen.",
        "conclusion-FOL": "American(DavidHaivri)",
        "label": "ERROR"
    },
    {
        "premises": "David Ha'ivri is a political strategist. \nIf you are born in Israel to at least one Israeli parent, you receive Israeli citizenship at birth. \nDavid Ha'ivri emigrated to the United States from Israel, where he was born to Israeli parents. \nSeveral Zionist leaders have been elected to the Shomron Regional Municipal council. \nDavid Ha'ivri is a Zionist leader.",
        "premises-FOL": [
            "PoliticalStrategist(DavidHaivri)\nall x. exists y. (BornInIsrael(x) & ParentOf(y, x) & Israeli(y) -> Israeli(x))\nexists x. (EmigratedTo(DavidHaivri, America) & BornInIsrael(DavidHaivri) & ParentOf(DavidHaivri, x) & Israeli(x))\nexists x. (ZionistLeader(x) & ElectedTo(x, ShomronMunicipalCouncil))\nZionstLeader(DavidHaivri)"
        ],
        "conclusion": "David Ha'ivri has been elected to the Shomron Regional Municipal council.",
        "conclusion-FOL": "ElectedTo(DavidHaivri, ShomronMunicipalCouncil)",
        "label": "ERROR"
    },
    {
        "premises": "Mary has the flu.\nIf someone has the flu, then they have influenza.\nSusan doesn't have influenza.",
        "premises-FOL": [
            "Has(Mary, Flu)\nall x. (Has(x, Flu) -> Has(x, Influenza))\n-Has(Susan, Influenza)"
        ],
        "conclusion": "Either Mary or Susan has influenza.",
        "conclusion-FOL": "((Has(Mary, Influenza) & -Has(Susan, Influenza)) | (-Has(Mary, Influenza) & Has(Susan, Influenza)))",
        "label": "ERROR"
    },
    {
        "premises": "James Cocks was a British lawyer.\nJames Cocks was a Whig politician who sat in the House of Commons.\nA British is a European.\nAny lawyer is familiar with laws.\nSome Whigs speak French.",
        "premises-FOL": [
            "British(James) & Lawyer(James)\nWhig(James) & Politician(James) & SatInHouseOfCommons(James)\nall x. (British(x) -> European(x))\nall x. (Lawyer(x) -> FamiliarWithLaws(x))\nexists x. exists y. (Whig(x) & SpeakFrench(x)) & (-(x=y)) & (Whig(y) & SpeakFrench(y))"
        ],
        "conclusion": "No lawyer ever sat in the House of Commons.",
        "conclusion-FOL": "all x. (Lawyer(x) -> -SatInHouseOfCommons(x))",
        "label": "ERROR"
    },
    {
        "premises": "James Cocks was a British lawyer.\nJames Cocks was a Whig politician who sat in the House of Commons.\nA British is a European.\nAny lawyer is familiar with laws.\nSome Whigs speak French.",
        "premises-FOL": [
            "British(James) & Lawyer(James)\nWhig(James) & Politician(James) & SatInHouseOfCommons(James)\nall x. (British(x) -> European(x))\nall x. (Lawyer(x) -> FamiliarWithLaws(x))\nexists x. exists y. (Whig(x) & SpeakFrench(x)) & (-(x=y)) & (Whig(y) & SpeakFrench(y))"
        ],
        "conclusion": "Some European was familiar with laws.",
        "conclusion-FOL": "exists x. (European(x) & FamiliarWithLaws(x))",
        "label": "ERROR"
    },
    {
        "premises": "James Cocks was a British lawyer.\nJames Cocks was a Whig politician who sat in the House of Commons.\nA British is a European.\nAny lawyer is familiar with laws.\nSome Whigs speak French.",
        "premises-FOL": [
            "British(James) & Lawyer(James)\nWhig(James) & Politician(James) & SatInHouseOfCommons(James)\nall x. (British(x) -> European(x))\nall x. (Lawyer(x) -> FamiliarWithLaws(x))\nexists x. exists y. (Whig(x) & SpeakFrench(x)) & (-(x=y)) & (Whig(y) & SpeakFrench(y))"
        ],
        "conclusion": "James Cocks speaks French.",
        "conclusion-FOL": "SpeakFrench(James)",
        "label": "ERROR"
    },
    {
        "premises": "Beasts of Prey is a fantasy novel or a science fiction novel, or both.\nScience fiction novels are not about mythological creatures\nBeasts of Prey Is about a creature known as the Shetani.\nShetanis are mythological.",
        "premises-FOL": [
            "Novel(BeastsOfPrey) -> (Fantasy(BeastsOfPrey) | ScienceFiction(BeastsOfPrey))\nall x. all y. (ScienceFiction(x) & Mythological(y) & Creature(y) -> -About(x, y))\nAbout(BeastsOfPrey, Shetani) & Creature(Shetani)\nMythological(Shetani)"
        ],
        "conclusion": "Beasts of prey is a fantasy novel.",
        "conclusion-FOL": "Fantasy(BeastsOfpPrey) & Novel(BeastsOfPrey)",
        "label": "ERROR"
    },
    {
        "premises": "Beasts of Prey is a fantasy novel or a science fiction novel, or both.\nScience fiction novels are not about mythological creatures\nBeasts of Prey Is about a creature known as the Shetani.\nShetanis are mythological.",
        "premises-FOL": [
            "Novel(BeastsOfPrey) -> (Fantasy(BeastsOfPrey) | ScienceFiction(BeastsOfPrey))\nall x. all y. (ScienceFiction(x) & Mythological(y) & Creature(y) -> -About(x, y))\nAbout(BeastsOfPrey, Shetani) & Creature(Shetani)\nMythological(Shetani)"
        ],
        "conclusion": "Beasts of prey isn't a science fiction novel.",
        "conclusion-FOL": "-ScienceFiction(Beastsofprey) & Novel(BeastsOfPrey)",
        "label": "ERROR"
    },
    {
        "premises": "Beasts of Prey is a fantasy novel or a science fiction novel, or both.\nScience fiction novels are not about mythological creatures\nBeasts of Prey Is about a creature known as the Shetani.\nShetanis are mythological.",
        "premises-FOL": [
            "Novel(BeastsOfPrey) -> (Fantasy(BeastsOfPrey) | ScienceFiction(BeastsOfPrey))\nall x. all y. (ScienceFiction(x) & Mythological(y) & Creature(y) -> -About(x, y))\nAbout(BeastsOfPrey, Shetani) & Creature(Shetani)\nMythological(Shetani)"
        ],
        "conclusion": "A shetani is either mythological or a creature.",
        "conclusion-FOL": "((Mythological(Shetani) & -Creature(Shetani)) | (-Mythological(Shetani) & Creature(Shetani)))",
        "label": "ERROR"
    },
    {
        "premises": "Odell is an English surname originating in Odell, Bedfordshire.\nIn some families, Odell is spelled O'Dell in a mistaken Irish adaptation.\nNotable people with surnames include Amy Odell, Jack Odell, and Mats Odell.\nAmy Odell is a British singer-songwriter.\nJack Odell is an English toy inventor.",
        "premises-FOL": [
            "Surname(NameODell) & From(NameODell, oDellBedfordshire)\nMistakenSpellingOf(NameO'Dell, NameODell) & (exists xexists y.(Family(x) & Named(x, NameO'Dell) & (-(x=y)) & Family(y) & Named(y, NameO'Dell))\nNamed(AmyODell, NameODell) & NotablePerson(AmyODell) & Named(JackODell, NameODell) & NotablePerson(JackODell) & Named(MatsODell, NameODell) & NotablePerson(MatsODell)\nBritish(AmyODell) & Singer(AmyODell) & SongWriter(AmyODell)\nEnglish(JackODell) & ToyInventor(JackODell)"
        ],
        "conclusion": "Jack Odell is a notable person.",
        "conclusion-FOL": "NotablePerson(JackODell)",
        "label": "ERROR"
    },
    {
        "premises": "Odell is an English surname originating in Odell, Bedfordshire.\nIn some families, Odell is spelled O'Dell in a mistaken Irish adaptation.\nNotable people with surnames include Amy Odell, Jack Odell, and Mats Odell.\nAmy Odell is a British singer-songwriter.\nJack Odell is an English toy inventor.",
        "premises-FOL": [
            "Surname(NameODell) & From(NameODell, oDellBedfordshire)\nMistakenSpellingOf(NameO'Dell, NameODell) & (exists xexists y.(Family(x) & Named(x, NameO'Dell) & (-(x=y)) & Family(y) & Named(y, NameO'Dell))\nNamed(AmyODell, NameODell) & NotablePerson(AmyODell) & Named(JackODell, NameODell) & NotablePerson(JackODell) & Named(MatsODell, NameODell) & NotablePerson(MatsODell)\nBritish(AmyODell) & Singer(AmyODell) & SongWriter(AmyODell)\nEnglish(JackODell) & ToyInventor(JackODell)"
        ],
        "conclusion": "Odell is Amy Odell's surname.",
        "conclusion-FOL": "Named(AmyODell, NameODell)",
        "label": "ERROR"
    },
    {
        "premises": "Odell is an English surname originating in Odell, Bedfordshire.\nIn some families, Odell is spelled O'Dell in a mistaken Irish adaptation.\nNotable people with surnames include Amy Odell, Jack Odell, and Mats Odell.\nAmy Odell is a British singer-songwriter.\nJack Odell is an English toy inventor.",
        "premises-FOL": [
            "Surname(NameODell) & From(NameODell, oDellBedfordshire)\nMistakenSpellingOf(NameO'Dell, NameODell) & (exists xexists y.(Family(x) & Named(x, NameO'Dell) & (-(x=y)) & Family(y) & Named(y, NameO'Dell))\nNamed(AmyODell, NameODell) & NotablePerson(AmyODell) & Named(JackODell, NameODell) & NotablePerson(JackODell) & Named(MatsODell, NameODell) & NotablePerson(MatsODell)\nBritish(AmyODell) & Singer(AmyODell) & SongWriter(AmyODell)\nEnglish(JackODell) & ToyInventor(JackODell)"
        ],
        "conclusion": "Amy Odell is an English toy inventor.",
        "conclusion-FOL": "English(AmyODell) & ToyInventor(AmyODell)",
        "label": "ERROR"
    },
    {
        "premises": "Odell is an English surname originating in Odell, Bedfordshire.\nIn some families, Odell is spelled O'Dell in a mistaken Irish adaptation.\nNotable people with surnames include Amy Odell, Jack Odell, and Mats Odell.\nAmy Odell is a British singer-songwriter.\nJack Odell is an English toy inventor.",
        "premises-FOL": [
            "Surname(NameODell) & From(NameODell, oDellBedfordshire)\nMistakenSpellingOf(NameO'Dell, NameODell) & (exists xexists y.(Family(x) & Named(x, NameO'Dell) & (-(x=y)) & Family(y) & Named(y, NameO'Dell))\nNamed(AmyODell, NameODell) & NotablePerson(AmyODell) & Named(JackODell, NameODell) & NotablePerson(JackODell) & Named(MatsODell, NameODell) & NotablePerson(MatsODell)\nBritish(AmyODell) & Singer(AmyODell) & SongWriter(AmyODell)\nEnglish(JackODell) & ToyInventor(JackODell)"
        ],
        "conclusion": "Amy Odell is also Amy O'Dell.",
        "conclusion-FOL": "Named(AmyODell, NameODell) & Named(AmyODell, NameO'Dell)",
        "label": "ERROR"
    },
    {
        "premises": "If you go somewhere by train, you will not lose time.\nIf you go somewhere by car and meet a traffic jam, you will lose time.\nIf you lose time, you will be late for work.\nMary can get from New Haven to New York City either by train or car.\nMary is late for work.",
        "premises-FOL": [
            "all x. (GoByTrain(x) -> -LoseTime(x))\nall x.((GoByCar(x) & Meet(x, TrafficJam)) -> LoseTime(x))\nall x. (LoseTime(x) -> LateForWork(x))\nFromAndTo(NewHaven, NewYork) & (((GoByTrain(Mary) & -GoByCar(Mary)) | (-GoByTrain(Mary) & GoByCar(Mary))))\nLateForWork(Mary)"
        ],
        "conclusion": "Mary gets from New Haven to New York City by train.",
        "conclusion-FOL": "FromAndTo(NewHaven, NewYork) & GoByTrain(Mary)",
        "label": "ERROR"
    },
    {
        "premises": "If you go somewhere by train, you will not lose time.\nIf you go somewhere by car and meet a traffic jam, you will lose time.\nIf you lose time, you will be late for work.\nMary can get from New Haven to New York City either by train or car.\nMary is late for work.",
        "premises-FOL": [
            "all x. (GoByTrain(x) -> -LoseTime(x))\nall x.((GoByCar(x) & Meet(x, TrafficJam)) -> LoseTime(x))\nall x. (LoseTime(x) -> LateForWork(x))\nFromAndTo(NewHaven, NewYork) & (((GoByTrain(Mary) & -GoByCar(Mary)) | (-GoByTrain(Mary) & GoByCar(Mary))))\nLateForWork(Mary)"
        ],
        "conclusion": "Mary gets from New Haven to New York City by car.",
        "conclusion-FOL": "FromAndTo(NewHaven, NewYork) & GoByCar(Mary)",
        "label": "ERROR"
    },
    {
        "premises": "If you go somewhere by train, you will not lose time.\nIf you go somewhere by car and meet a traffic jam, you will lose time.\nIf you lose time, you will be late for work.\nMary can get from New Haven to New York City either by train or car.\nMary is late for work.",
        "premises-FOL": [
            "all x. (GoByTrain(x) -> -LoseTime(x))\nall x.((GoByCar(x) & Meet(x, TrafficJam)) -> LoseTime(x))\nall x. (LoseTime(x) -> LateForWork(x))\nFromAndTo(NewHaven, NewYork) & (((GoByTrain(Mary) & -GoByCar(Mary)) | (-GoByTrain(Mary) & GoByCar(Mary))))\nLateForWork(Mary)"
        ],
        "conclusion": "Mary meets a traffic jam.",
        "conclusion-FOL": "Meet(Mary, TrafficJam)",
        "label": "ERROR"
    },
    {
        "premises": "If a person is hungry, the person is uncomfortable.\nIf a person is uncomfortable, the person is unhappy.",
        "premises-FOL": [
            "all x. (Hungry(x) -> Uncomfortable(x))\nall x. (Uncomfortable(x) -> -Happy(x))"
        ],
        "conclusion": "If a person is not hungry, the person is unhappy.",
        "conclusion-FOL": "all x. (-Hungry(x) -> -Happy(x))",
        "label": "ERROR"
    },
    {
        "premises": "Tipped employees are not entitled to be paid the federal minimum wage by their employees. \nIf a person is a white-collar worker, they are entitled to be paid the federal minimum wage by their employees. \nAll lawyers are white-collar workers.\nEvery advocate is a lawyer.\nMary is not a lawyer or a tipped employee.",
        "premises-FOL": [
            "all x. (TippedEmployee(x) -> -EntitledTo(x, FederalMinimumWage))\nall x. (WhiteCollarWorker(x) -> EntitledTo(x, FederalMinimumWage))\nall x. (Lawyer(x) -> WhiteCollarWorker(x))\nall x. (Advocate(x) -> Lawyer(x))\n-(((Lawyer(Mary) & -TippedEmployee(Mary)) | (-Lawyer(Mary) & TippedEmployee(Mary))))"
        ],
        "conclusion": "Mary is a white-collar worker.",
        "conclusion-FOL": "WhiteCollarWorker(Mary)",
        "label": "ERROR"
    },
    {
        "premises": "Tipped employees are not entitled to be paid the federal minimum wage by their employees. \nIf a person is a white-collar worker, they are entitled to be paid the federal minimum wage by their employees. \nAll lawyers are white-collar workers.\nEvery advocate is a lawyer.\nMary is not a lawyer or a tipped employee.",
        "premises-FOL": [
            "all x. (TippedEmployee(x) -> -EntitledTo(x, FederalMinimumWage))\nall x. (WhiteCollarWorker(x) -> EntitledTo(x, FederalMinimumWage))\nall x. (Lawyer(x) -> WhiteCollarWorker(x))\nall x. (Advocate(x) -> Lawyer(x))\n-(((Lawyer(Mary) & -TippedEmployee(Mary)) | (-Lawyer(Mary) & TippedEmployee(Mary))))"
        ],
        "conclusion": "Mary is an advocate.",
        "conclusion-FOL": "Advocate(Mary)",
        "label": "ERROR"
    },
    {
        "premises": "Tipped employees are not entitled to be paid the federal minimum wage by their employees. \nIf a person is a white-collar worker, they are entitled to be paid the federal minimum wage by their employees. \nAll lawyers are white-collar workers.\nEvery advocate is a lawyer.\nMary is not a lawyer or a tipped employee.",
        "premises-FOL": [
            "all x. (TippedEmployee(x) -> -EntitledTo(x, FederalMinimumWage))\nall x. (WhiteCollarWorker(x) -> EntitledTo(x, FederalMinimumWage))\nall x. (Lawyer(x) -> WhiteCollarWorker(x))\nall x. (Advocate(x) -> Lawyer(x))\n-(((Lawyer(Mary) & -TippedEmployee(Mary)) | (-Lawyer(Mary) & TippedEmployee(Mary))))"
        ],
        "conclusion": "Mary is not an advocate.",
        "conclusion-FOL": "-Advocate(Mary)",
        "label": "ERROR"
    },
    {
        "premises": "Tipped employees are not entitled to be paid the federal minimum wage by their employees. \nIf a person is a white-collar worker, they are entitled to be paid the federal minimum wage by their employees. \nAll lawyers are white-collar workers.\nEvery advocate is a lawyer.\nMary is not a lawyer or a tipped employee.",
        "premises-FOL": [
            "all x. (TippedEmployee(x) -> -EntitledTo(x, FederalMinimumWage))\nall x. (WhiteCollarWorker(x) -> EntitledTo(x, FederalMinimumWage))\nall x. (Lawyer(x) -> WhiteCollarWorker(x))\nall x. (Advocate(x) -> Lawyer(x))\n-(((Lawyer(Mary) & -TippedEmployee(Mary)) | (-Lawyer(Mary) & TippedEmployee(Mary))))"
        ],
        "conclusion": "Mary is either an advocate or a tipped employee.",
        "conclusion-FOL": "((Advocate(Mary) & -TippedEmployee(Mary)) | (-Advocate(Mary) & TippedEmployee(Mary)))",
        "label": "ERROR"
    },
    {
        "premises": "Tipped employees are not entitled to be paid the federal minimum wage by their employees. \nIf a person is a white-collar worker, they are entitled to be paid the federal minimum wage by their employees. \nAll lawyers are white-collar workers.\nEvery advocate is a lawyer.\nMary is not a lawyer or a tipped employee.",
        "premises-FOL": [
            "all x. (TippedEmployee(x) -> -EntitledTo(x, FederalMinimumWage))\nall x. (WhiteCollarWorker(x) -> EntitledTo(x, FederalMinimumWage))\nall x. (Lawyer(x) -> WhiteCollarWorker(x))\nall x. (Advocate(x) -> Lawyer(x))\n-(((Lawyer(Mary) & -TippedEmployee(Mary)) | (-Lawyer(Mary) & TippedEmployee(Mary))))"
        ],
        "conclusion": "If Mary is not both an advocate and is entitled to be paid the federal minimum wage by their employees, she is not a tipped employee.",
        "conclusion-FOL": "(-(Advocate(Mary) & EntitledTo(Mary, FederalMinimumWage))) -> -TippedEmployee(Mary)",
        "label": "ERROR"
    },
    {
        "premises": "Tipped employees are not entitled to be paid the federal minimum wage by their employees. \nIf a person is a white-collar worker, they are entitled to be paid the federal minimum wage by their employees. \nAll lawyers are white-collar workers.\nEvery advocate is a lawyer.\nMary is not a lawyer or a tipped employee.",
        "premises-FOL": [
            "all x. (TippedEmployee(x) -> -EntitledTo(x, FederalMinimumWage))\nall x. (WhiteCollarWorker(x) -> EntitledTo(x, FederalMinimumWage))\nall x. (Lawyer(x) -> WhiteCollarWorker(x))\nall x. (Advocate(x) -> Lawyer(x))\n-(((Lawyer(Mary) & -TippedEmployee(Mary)) | (-Lawyer(Mary) & TippedEmployee(Mary))))"
        ],
        "conclusion": "If Mary is either an advocate or a tipped employee, she is an advocate.",
        "conclusion-FOL": "(((Advocate(Mary) & -TippedEmployee(Mary)) | (-Advocate(Mary) & TippedEmployee(Mary)))) -> Advocate(Mary)",
        "label": "ERROR"
    },
    {
        "premises": "Asa Hoffmann was born in New York City.\nAsa Hoffman lives in Manhattan.\nAsa Hoffman is a chess player.\nSome chess players are grandmasters.\nPeople born and living in New York City are New Yorkers.\nPeople living in Manhattan live in New York City.",
        "premises-FOL": [
            "BornIn(AsaHoffmann, NewYorkCity)\nLiveIn(AsaHoffmann, Manhattan)\nChessPlayer(AsaHoffmann)\nexists x. exists y. (ChessPlayer(x) & GrandMaster(x) & (-(x=y)) & ChessPlayer(y) & GrandMaster(y))\nall x. ((BornIn(x, NewYorkCity) & LiveIn(x, NewYorkCity)) -> NewYorker(x))\nall x. (LiveIn(x, Manhattan) -> LiveIn(x, NewYorkCity))"
        ],
        "conclusion": "Asa Hoffmann is a New Yorker.",
        "conclusion-FOL": "NewYorker(AsaHoffmann)",
        "label": "ERROR"
    },
    {
        "premises": "Asa Hoffmann was born in New York City.\nAsa Hoffman lives in Manhattan.\nAsa Hoffman is a chess player.\nSome chess players are grandmasters.\nPeople born and living in New York City are New Yorkers.\nPeople living in Manhattan live in New York City.",
        "premises-FOL": [
            "BornIn(AsaHoffmann, NewYorkCity)\nLiveIn(AsaHoffmann, Manhattan)\nChessPlayer(AsaHoffmann)\nexists x. exists y. (ChessPlayer(x) & GrandMaster(x) & (-(x=y)) & ChessPlayer(y) & GrandMaster(y))\nall x. ((BornIn(x, NewYorkCity) & LiveIn(x, NewYorkCity)) -> NewYorker(x))\nall x. (LiveIn(x, Manhattan) -> LiveIn(x, NewYorkCity))"
        ],
        "conclusion": "Asa Hoffmann is a grandmaster.",
        "conclusion-FOL": "GrandMaster(AsaHoffmann)",
        "label": "ERROR"
    },
    {
        "premises": "Asa Hoffmann was born in New York City.\nAsa Hoffman lives in Manhattan.\nAsa Hoffman is a chess player.\nSome chess players are grandmasters.\nPeople born and living in New York City are New Yorkers.\nPeople living in Manhattan live in New York City.",
        "premises-FOL": [
            "BornIn(AsaHoffmann, NewYorkCity)\nLiveIn(AsaHoffmann, Manhattan)\nChessPlayer(AsaHoffmann)\nexists x. exists y. (ChessPlayer(x) & GrandMaster(x) & (-(x=y)) & ChessPlayer(y) & GrandMaster(y))\nall x. ((BornIn(x, NewYorkCity) & LiveIn(x, NewYorkCity)) -> NewYorker(x))\nall x. (LiveIn(x, Manhattan) -> LiveIn(x, NewYorkCity))"
        ],
        "conclusion": "Asa Hoffmann does not live in New York.",
        "conclusion-FOL": "-LiveIn(AsaHoffmann, NewYorkCity)",
        "label": "ERROR"
    },
    {
        "premises": "Some of those who apply for a Schengen visa get it.\nTo apply for a Schengen Visa, you need to provide financial guarantees.\nIf you need to provide financial guarantees, you must request documents from the bank.\nDo not close your bank account if you request documents from the bank.\nPhilip closed his bank account.",
        "premises-FOL": [
            "exists x. (Apply(x, SchengenVisa) -> Get(x, SchengenVisa))\nall x. (Apply(x, SchengenVisa) -> Provide(x, FinancialGuarantees))\nall x. (Provide(x, FinancialGuarantees) -> Request(x, DocumentsFromBank))\nall x. (Request(x, DocumentsFromBank) -> -Close(x, BankAccount))\nClose(Philip, BankAccount)"
        ],
        "conclusion": "Philip got a Schengen visa.",
        "conclusion-FOL": "Get(Philip, SchengenVisa)",
        "label": "ERROR"
    },
    {
        "premises": "Some of those who apply for a Schengen visa get it.\nTo apply for a Schengen Visa, you need to provide financial guarantees.\nIf you need to provide financial guarantees, you must request documents from the bank.\nDo not close your bank account if you request documents from the bank.\nPhilip closed his bank account.",
        "premises-FOL": [
            "exists x. (Apply(x, SchengenVisa) -> Get(x, SchengenVisa))\nall x. (Apply(x, SchengenVisa) -> Provide(x, FinancialGuarantees))\nall x. (Provide(x, FinancialGuarantees) -> Request(x, DocumentsFromBank))\nall x. (Request(x, DocumentsFromBank) -> -Close(x, BankAccount))\nClose(Philip, BankAccount)"
        ],
        "conclusion": "Philip applied for a Schengen visa and got it.",
        "conclusion-FOL": "Apply(Philip, SchengenVisa) & Get(Philip, SchengenVisa)",
        "label": "ERROR"
    },
    {
        "premises": "Some of those who apply for a Schengen visa get it.\nTo apply for a Schengen Visa, you need to provide financial guarantees.\nIf you need to provide financial guarantees, you must request documents from the bank.\nDo not close your bank account if you request documents from the bank.\nPhilip closed his bank account.",
        "premises-FOL": [
            "exists x. (Apply(x, SchengenVisa) -> Get(x, SchengenVisa))\nall x. (Apply(x, SchengenVisa) -> Provide(x, FinancialGuarantees))\nall x. (Provide(x, FinancialGuarantees) -> Request(x, DocumentsFromBank))\nall x. (Request(x, DocumentsFromBank) -> -Close(x, BankAccount))\nClose(Philip, BankAccount)"
        ],
        "conclusion": "If Philip did not request documents from the bank or get a Schengen visa, he didn\u2019t apply for a Schengen visa.",
        "conclusion-FOL": "(-Request(Philip, DocumentsFromBank) & -Get(x, SchengenVisa)) -> Apply(x, SchengenVisa)",
        "label": "ERROR"
    },
    {
        "premises": "Some fears lead to anxiety.\nSome anxiety leads to terror.",
        "premises-FOL": [
            "exists x. exists y. (Fear(x) & Anxiety(y) & LeadTo(x, y) & -(x=y))\nexists x. exists y. (Anxiety(x) & Terror(y) & LeadTo(x, y))"
        ],
        "conclusion": "No fears lead to terror.",
        "conclusion-FOL": "all x. all y. (Fear(x) -> -(Terror(y) & LeadTo(x, y)))",
        "label": "ERROR"
    },
    {
        "premises": "The Great Lakes are Lake Superior, Lake Michigan, Lake Huron, Lake Erie, and Lake Ontario.\nSome major settlements of Lake Erie are in NY, PA, OH, and MI.\nNY, PA, OH, and MI are states in the US.\nON is a state of Canada.\nThere is a major settlement of Lake Huron in ON. \nAll states are in their country.\nThe US is in North America.\nThe Great Lakes began to form at the end of the Last Glacial Period.",
        "premises-FOL": [
            "all x. (((GreatLake(x) -> ((Superior(x) & -Michigan(x)) | (-Superior(x) & Michigan(x))) & -((Huron(x) & -Erie(x))) | (-(GreatLake(x) -> ((Superior(x) & -Michigan(x)) | (-Superior(x) & Michigan(x))) & ((Huron(x) & -Erie(x)))) | (-Huron(x) & Erie(x)) & -Ontario(x)) | (-(GreatLake(x) -> ((Superior(x) & -Michigan(x)) | (-Superior(x) & Michigan(x))) & -((Huron(x) & -Erie(x))) | (-(GreatLake(x) -> ((Superior(x) & -Michigan(x)) | (-Superior(x) & Michigan(x))) & ((Huron(x) & -Erie(x)))) | (-Huron(x) & Erie(x)) & Ontario(x)))\nall x. (Erie (x) & MajorSettlement(x) -> In(x, nY) | In(x, pA) | In(x, oH) | In(x, mI))\nStateOf(nY, uS) & StateOf(pA, uS) & StateOf(oH, uS) & StateOf(mI, uS)\nStateOf(oN, Canada)\nexists x. (Huron(x) & MajorSettlement(x) & In(x, oN))\nall x. all y. (StateOf(x, y) -> In(x, y))\nIn(Us, NorthAmerica)\nall x. (GreatLake(x) -> FormAtEndOf(x, LastGlacialPeriod))"
        ],
        "conclusion": "Lake Erie has a major settlement.",
        "conclusion-FOL": "exists x. exists y. (Erie(y) & MajorSettlementOf(x, y))",
        "label": "ERROR"
    },
    {
        "premises": "The Great Lakes are Lake Superior, Lake Michigan, Lake Huron, Lake Erie, and Lake Ontario.\nSome major settlements of Lake Erie are in NY, PA, OH, and MI.\nNY, PA, OH, and MI are states in the US.\nON is a state of Canada.\nThere is a major settlement of Lake Huron in ON. \nAll states are in their country.\nThe US is in North America.\nThe Great Lakes began to form at the end of the Last Glacial Period.",
        "premises-FOL": [
            "all x. (((GreatLake(x) -> ((Superior(x) & -Michigan(x)) | (-Superior(x) & Michigan(x))) & -((Huron(x) & -Erie(x))) | (-(GreatLake(x) -> ((Superior(x) & -Michigan(x)) | (-Superior(x) & Michigan(x))) & ((Huron(x) & -Erie(x)))) | (-Huron(x) & Erie(x)) & -Ontario(x)) | (-(GreatLake(x) -> ((Superior(x) & -Michigan(x)) | (-Superior(x) & Michigan(x))) & -((Huron(x) & -Erie(x))) | (-(GreatLake(x) -> ((Superior(x) & -Michigan(x)) | (-Superior(x) & Michigan(x))) & ((Huron(x) & -Erie(x)))) | (-Huron(x) & Erie(x)) & Ontario(x)))\nall x. (Erie (x) & MajorSettlement(x) -> In(x, nY) | In(x, pA) | In(x, oH) | In(x, mI))\nStateOf(nY, uS) & StateOf(pA, uS) & StateOf(oH, uS) & StateOf(mI, uS)\nStateOf(oN, Canada)\nexists x. (Huron(x) & MajorSettlement(x) & In(x, oN))\nall x. all y. (StateOf(x, y) -> In(x, y))\nIn(Us, NorthAmerica)\nall x. (GreatLake(x) -> FormAtEndOf(x, LastGlacialPeriod))"
        ],
        "conclusion": "There is a great lake that did not form at the end of the Last Glacial Period.",
        "conclusion-FOL": "exists x. (GreatLake(x) & -FormAtEndOf(x, LastGlacialPeriod))",
        "label": "ERROR"
    },
    {
        "premises": "All professional soccer defenders are professional soccer players.\nNo professional soccer players are professional basketball players.\nAll professional centerbacks are professional soccer defenders.\nAll NBA players are professional basketball players.\nStephen Curry is an NBA player.",
        "premises-FOL": [
            "all x. ((Professional(x) & Defender(x)) -> (Professional(x) & SoccerPlayer(x)))\nall x. ((Professional(x) & SoccerPlayer(x)) -> -(Professional(x) & BasketballPlayer(x)))\nall x. ((Professional(x) & CenterBack(x)) -> (Professional(x) & Defender(x))\nall x. (NBAPlayer(x) -> (Professional(x) & BasketballPlayer(x)))\nNBAPlayer(StephenCurry)"
        ],
        "conclusion": "Stephen Curry is a professional basketball player.",
        "conclusion-FOL": "Professional(StephenCurry) & BasketballPlayer(StephenCurry)",
        "label": "ERROR"
    },
    {
        "premises": "All professional soccer defenders are professional soccer players.\nNo professional soccer players are professional basketball players.\nAll professional centerbacks are professional soccer defenders.\nAll NBA players are professional basketball players.\nStephen Curry is an NBA player.",
        "premises-FOL": [
            "all x. ((Professional(x) & Defender(x)) -> (Professional(x) & SoccerPlayer(x)))\nall x. ((Professional(x) & SoccerPlayer(x)) -> -(Professional(x) & BasketballPlayer(x)))\nall x. ((Professional(x) & CenterBack(x)) -> (Professional(x) & Defender(x))\nall x. (NBAPlayer(x) -> (Professional(x) & BasketballPlayer(x)))\nNBAPlayer(StephenCurry)"
        ],
        "conclusion": "Stephen Curry is a professional centerback.",
        "conclusion-FOL": "Professional(StephenCurry) & CenterBack(StephenCurry)",
        "label": "ERROR"
    },
    {
        "premises": "All professional soccer defenders are professional soccer players.\nNo professional soccer players are professional basketball players.\nAll professional centerbacks are professional soccer defenders.\nAll NBA players are professional basketball players.\nStephen Curry is an NBA player.",
        "premises-FOL": [
            "all x. ((Professional(x) & Defender(x)) -> (Professional(x) & SoccerPlayer(x)))\nall x. ((Professional(x) & SoccerPlayer(x)) -> -(Professional(x) & BasketballPlayer(x)))\nall x. ((Professional(x) & CenterBack(x)) -> (Professional(x) & Defender(x))\nall x. (NBAPlayer(x) -> (Professional(x) & BasketballPlayer(x)))\nNBAPlayer(StephenCurry)"
        ],
        "conclusion": "Stephen Curry is not a centerback.",
        "conclusion-FOL": "-(Professional(StephenCurry) & CenterBack(StephenCurry))",
        "label": "ERROR"
    },
    {
        "premises": "Naive cynicism was proposed by Justin Kruger and a colleague.\nThomas Gilovich is a colleague of Justin Kruger. \nNaive cynicism is a philosophy of mind.",
        "premises-FOL": [
            "Proposed(JustinKruger, NaiveCynicism) & exists y. (ColleagueOfJustinKruger(y) & Proposed(y, NaiveCynicism))\nColleagues(ThomasGilovich, JustinKruger)\nPhilosophyOfMind(NaiveCynicism)"
        ],
        "conclusion": "Thomas Gilovich proposed naive cynicism.",
        "conclusion-FOL": "Proposed(ThomasGilovich, NaiveCynicism)",
        "label": "ERROR"
    },
    {
        "premises": "Naive cynicism was proposed by Justin Kruger and a colleague.\nThomas Gilovich is a colleague of Justin Kruger. \nNaive cynicism is a philosophy of mind.",
        "premises-FOL": [
            "Proposed(JustinKruger, NaiveCynicism) & exists y. (ColleagueOfJustinKruger(y) & Proposed(y, NaiveCynicism))\nColleagues(ThomasGilovich, JustinKruger)\nPhilosophyOfMind(NaiveCynicism)"
        ],
        "conclusion": "Justin Kruger proposed a philosophy of mind.",
        "conclusion-FOL": "exists x. (Proposed(JustinKruger, x) & PhilosophyOfMind(x))",
        "label": "ERROR"
    },
    {
        "premises": "Naive cynicism was proposed by Justin Kruger and a colleague.\nThomas Gilovich is a colleague of Justin Kruger. \nNaive cynicism is a philosophy of mind.",
        "premises-FOL": [
            "Proposed(JustinKruger, NaiveCynicism) & exists y. (ColleagueOfJustinKruger(y) & Proposed(y, NaiveCynicism))\nColleagues(ThomasGilovich, JustinKruger)\nPhilosophyOfMind(NaiveCynicism)"
        ],
        "conclusion": "Thomas Gilovich worked on philosophies of mind.",
        "conclusion-FOL": "exists x. (WorkedOn(ThomasGilovich, x) & PhilosophyOfMind(x))",
        "label": "ERROR"
    },
    {
        "premises": "The Turing Award has been awarded to Donald Knuth, Marvin Minsky, Richard Hamming, and John McCarthy. \nDonald Knuth made contributions to the analysis of algorithms.\nMarvin Minsky is recognized for his contributions to the field of artificial intelligence.\nRichard Hamming researched numerical methods.\nJohn McCarthy made contributions to the field of artificial intelligence. ",
        "premises-FOL": [
            "AwardedTo(TuringAward, DonaldKnuth) & AwardedTo(TuringAward, MarvinMinsky) & AwardedTo(TuringAward, RichardHamming) & AwardedTo(TuringAward, JohnMccarthy)\nContributedTo(DonaldKnuth, AnalysisOfAlgorithms)\nContributedTo(MarvinMinsky, ArtificialIntelligence)\nContributedTo(RichardHamming, NumericalMethods)\nContributedTo(JohnMccarthy, ArtificialIntelligence)"
        ],
        "conclusion": "At least two people who have won the Turing Award worked in artificial intelligence.",
        "conclusion-FOL": "exists x. exists y. (-(x=y) & AwardedTo(TuringAward, x) & AwardedTo(TuringAward, y) & ContributedTo(x, ArtificialIntelligence)  & ContributedTo(y, ArtificialIntelligence))",
        "label": "ERROR"
    },
    {
        "premises": "The Turing Award has been awarded to Donald Knuth, Marvin Minsky, Richard Hamming, and John McCarthy. \nDonald Knuth made contributions to the analysis of algorithms.\nMarvin Minsky is recognized for his contributions to the field of artificial intelligence.\nRichard Hamming researched numerical methods.\nJohn McCarthy made contributions to the field of artificial intelligence. ",
        "premises-FOL": [
            "AwardedTo(TuringAward, DonaldKnuth) & AwardedTo(TuringAward, MarvinMinsky) & AwardedTo(TuringAward, RichardHamming) & AwardedTo(TuringAward, JohnMccarthy)\nContributedTo(DonaldKnuth, AnalysisOfAlgorithms)\nContributedTo(MarvinMinsky, ArtificialIntelligence)\nContributedTo(RichardHamming, NumericalMethods)\nContributedTo(JohnMccarthy, ArtificialIntelligence)"
        ],
        "conclusion": "At least two people who worked in artificial intelligence have won the Turing Award.",
        "conclusion-FOL": "exists x. exists y. (-(x=y) & ContributedTo(x, ArtificialIntelligence) & ContributedTo(x, ArtificialIntelligence) & AwardedTo(TuringAward, x) & AwardedTo(TuringAward, y))",
        "label": "ERROR"
    },
    {
        "premises": "The Turing Award has been awarded to Donald Knuth, Marvin Minsky, Richard Hamming, and John McCarthy. \nDonald Knuth made contributions to the analysis of algorithms.\nMarvin Minsky is recognized for his contributions to the field of artificial intelligence.\nRichard Hamming researched numerical methods.\nJohn McCarthy made contributions to the field of artificial intelligence. ",
        "premises-FOL": [
            "AwardedTo(TuringAward, DonaldKnuth) & AwardedTo(TuringAward, MarvinMinsky) & AwardedTo(TuringAward, RichardHamming) & AwardedTo(TuringAward, JohnMccarthy)\nContributedTo(DonaldKnuth, AnalysisOfAlgorithms)\nContributedTo(MarvinMinsky, ArtificialIntelligence)\nContributedTo(RichardHamming, NumericalMethods)\nContributedTo(JohnMccarthy, ArtificialIntelligence)"
        ],
        "conclusion": "Only one person who won the Turing Award made significant contributions to the analysis of algorithms.",
        "conclusion-FOL": "exists x. all y. ((AwardedTo(TuringAward, x) & AwardedTo(TuringAward, y) & ContributedTo(y, Algorithms) & -(x=y)) -> -ContributedTo(y, Algorithms))",
        "label": "ERROR"
    },
    {
        "premises": "The Turing Award has been awarded to Donald Knuth, Marvin Minsky, Richard Hamming, and John McCarthy. \nDonald Knuth made contributions to the analysis of algorithms.\nMarvin Minsky is recognized for his contributions to the field of artificial intelligence.\nRichard Hamming researched numerical methods.\nJohn McCarthy made contributions to the field of artificial intelligence. ",
        "premises-FOL": [
            "AwardedTo(TuringAward, DonaldKnuth) & AwardedTo(TuringAward, MarvinMinsky) & AwardedTo(TuringAward, RichardHamming) & AwardedTo(TuringAward, JohnMccarthy)\nContributedTo(DonaldKnuth, AnalysisOfAlgorithms)\nContributedTo(MarvinMinsky, ArtificialIntelligence)\nContributedTo(RichardHamming, NumericalMethods)\nContributedTo(JohnMccarthy, ArtificialIntelligence)"
        ],
        "conclusion": "No Turing Award winners worked in the field of numerical methods.",
        "conclusion-FOL": "all x. (AwardedTo(TuringAward, x) -> -ContributedTo(x, NumericalMethods))",
        "label": "ERROR"
    },
    {
        "premises": "None of the easy Leetcode problems have an AC rate lower than 20 percent. \nAll Leetcode problems recommended to novices are easy. \nLeetcode problems either have an AC rate lower than 20 percent or are starred by more than 1 thousand users. \nAll hard Leetcode problems are starred by more than 1,000 users. \nNo Leetcode problems published after 2022 are starred by more than 1,000 users. \n'2Sum' is not both hard and also recommended to novices.\n'4Sum' is either starred by more than 1,000 users and published after 2022, or it is neither. ",
        "premises-FOL": [
            "all x. ((LeetcodeProblems(x) & Easy(x)) -> -HaveAnACRateLowerThan(x, PercentTwoZero))\nall x. ((LeetcodeProblems(x) & RecommendedTo(x, Novices)) -> Easy(x))\nall x. (LeetcodeProblems(x) -> ((HaveAnACRateLowerThan(x, PercentTwoZero) & -StarredByMoreThan(x, NumOneZeroZeroZero)) | (-HaveAnACRateLowerThan(x, PercentTwoZero) & StarredByMoreThan(x, NumOneZeroZeroZero))))\nall x. ((LeetcodeProblems(x) & Hard(x)) -> StarredByMoreThan(x, NumOneZeroZeroZero))\nall x. ((LeetcodeProblems(x) & PublishedAfter(x, YrTwoZeroTwoTwo)) -> (-StarredByMoreThan(x, NumOneZeroZeroZero)))\n-(RecommendedTo(Twosum, Novices) & Hard(Twosum)) & LeetcodeProblems(Twosum)\n-(((StarredByMoreThan(Foursum, NumOneZeroZeroZero) & -PublishedAfter(Foursum, YrTwoZeroTwoTwo)) | (-StarredByMoreThan(Foursum, NumOneZeroZeroZero) & PublishedAfter(Foursum, YrTwoZeroTwoTwo)))) & LeetcodeProblems(Twosum)"
        ],
        "conclusion": "2Sum is an easy Leetcode problem.",
        "conclusion-FOL": "LeetcodeProblems(Twosum) & Easy(Twosum)",
        "label": "ERROR"
    },
    {
        "premises": "None of the easy Leetcode problems have an AC rate lower than 20 percent. \nAll Leetcode problems recommended to novices are easy. \nLeetcode problems either have an AC rate lower than 20 percent or are starred by more than 1 thousand users. \nAll hard Leetcode problems are starred by more than 1,000 users. \nNo Leetcode problems published after 2022 are starred by more than 1,000 users. \n'2Sum' is not both hard and also recommended to novices.\n'4Sum' is either starred by more than 1,000 users and published after 2022, or it is neither. ",
        "premises-FOL": [
            "all x. ((LeetcodeProblems(x) & Easy(x)) -> -HaveAnACRateLowerThan(x, PercentTwoZero))\nall x. ((LeetcodeProblems(x) & RecommendedTo(x, Novices)) -> Easy(x))\nall x. (LeetcodeProblems(x) -> ((HaveAnACRateLowerThan(x, PercentTwoZero) & -StarredByMoreThan(x, NumOneZeroZeroZero)) | (-HaveAnACRateLowerThan(x, PercentTwoZero) & StarredByMoreThan(x, NumOneZeroZeroZero))))\nall x. ((LeetcodeProblems(x) & Hard(x)) -> StarredByMoreThan(x, NumOneZeroZeroZero))\nall x. ((LeetcodeProblems(x) & PublishedAfter(x, YrTwoZeroTwoTwo)) -> (-StarredByMoreThan(x, NumOneZeroZeroZero)))\n-(RecommendedTo(Twosum, Novices) & Hard(Twosum)) & LeetcodeProblems(Twosum)\n-(((StarredByMoreThan(Foursum, NumOneZeroZeroZero) & -PublishedAfter(Foursum, YrTwoZeroTwoTwo)) | (-StarredByMoreThan(Foursum, NumOneZeroZeroZero) & PublishedAfter(Foursum, YrTwoZeroTwoTwo)))) & LeetcodeProblems(Twosum)"
        ],
        "conclusion": "2Sum is not an easy Leetcode problem.",
        "conclusion-FOL": "-(LeetcodeProblems(Twosum) & Easy(Twosum))",
        "label": "ERROR"
    },
    {
        "premises": "None of the easy Leetcode problems have an AC rate lower than 20 percent. \nAll Leetcode problems recommended to novices are easy. \nLeetcode problems either have an AC rate lower than 20 percent or are starred by more than 1 thousand users. \nAll hard Leetcode problems are starred by more than 1,000 users. \nNo Leetcode problems published after 2022 are starred by more than 1,000 users. \n'2Sum' is not both hard and also recommended to novices.\n'4Sum' is either starred by more than 1,000 users and published after 2022, or it is neither. ",
        "premises-FOL": [
            "all x. ((LeetcodeProblems(x) & Easy(x)) -> -HaveAnACRateLowerThan(x, PercentTwoZero))\nall x. ((LeetcodeProblems(x) & RecommendedTo(x, Novices)) -> Easy(x))\nall x. (LeetcodeProblems(x) -> ((HaveAnACRateLowerThan(x, PercentTwoZero) & -StarredByMoreThan(x, NumOneZeroZeroZero)) | (-HaveAnACRateLowerThan(x, PercentTwoZero) & StarredByMoreThan(x, NumOneZeroZeroZero))))\nall x. ((LeetcodeProblems(x) & Hard(x)) -> StarredByMoreThan(x, NumOneZeroZeroZero))\nall x. ((LeetcodeProblems(x) & PublishedAfter(x, YrTwoZeroTwoTwo)) -> (-StarredByMoreThan(x, NumOneZeroZeroZero)))\n-(RecommendedTo(Twosum, Novices) & Hard(Twosum)) & LeetcodeProblems(Twosum)\n-(((StarredByMoreThan(Foursum, NumOneZeroZeroZero) & -PublishedAfter(Foursum, YrTwoZeroTwoTwo)) | (-StarredByMoreThan(Foursum, NumOneZeroZeroZero) & PublishedAfter(Foursum, YrTwoZeroTwoTwo)))) & LeetcodeProblems(Twosum)"
        ],
        "conclusion": "4Sum is recommended to novices or is hard.",
        "conclusion-FOL": "RecommendedTo(Foursum, Novices) | Hard(Foursum)",
        "label": "ERROR"
    },
    {
        "premises": "None of the easy Leetcode problems have an AC rate lower than 20 percent. \nAll Leetcode problems recommended to novices are easy. \nLeetcode problems either have an AC rate lower than 20 percent or are starred by more than 1 thousand users. \nAll hard Leetcode problems are starred by more than 1,000 users. \nNo Leetcode problems published after 2022 are starred by more than 1,000 users. \n'2Sum' is not both hard and also recommended to novices.\n'4Sum' is either starred by more than 1,000 users and published after 2022, or it is neither. ",
        "premises-FOL": [
            "all x. ((LeetcodeProblems(x) & Easy(x)) -> -HaveAnACRateLowerThan(x, PercentTwoZero))\nall x. ((LeetcodeProblems(x) & RecommendedTo(x, Novices)) -> Easy(x))\nall x. (LeetcodeProblems(x) -> ((HaveAnACRateLowerThan(x, PercentTwoZero) & -StarredByMoreThan(x, NumOneZeroZeroZero)) | (-HaveAnACRateLowerThan(x, PercentTwoZero) & StarredByMoreThan(x, NumOneZeroZeroZero))))\nall x. ((LeetcodeProblems(x) & Hard(x)) -> StarredByMoreThan(x, NumOneZeroZeroZero))\nall x. ((LeetcodeProblems(x) & PublishedAfter(x, YrTwoZeroTwoTwo)) -> (-StarredByMoreThan(x, NumOneZeroZeroZero)))\n-(RecommendedTo(Twosum, Novices) & Hard(Twosum)) & LeetcodeProblems(Twosum)\n-(((StarredByMoreThan(Foursum, NumOneZeroZeroZero) & -PublishedAfter(Foursum, YrTwoZeroTwoTwo)) | (-StarredByMoreThan(Foursum, NumOneZeroZeroZero) & PublishedAfter(Foursum, YrTwoZeroTwoTwo)))) & LeetcodeProblems(Twosum)"
        ],
        "conclusion": "4Sum is neither recommended to the novice nor a Leetcode problem that's hard.",
        "conclusion-FOL": "-RecommendedTo(Foursum, Novices) & -Hard(Foursum)",
        "label": "ERROR"
    },
    {
        "premises": "Show Your Love is a song recorded by the South Korean boy band BtoB 4u.\nThe lead single of the extended play Inside is Show Your Love.\nShow Your Love contains a hopeful message.\nBtoB 4u member Hyunsik wrote Show Your Love.\nThere is a music video for Show Your Love.",
        "premises-FOL": [
            "Song(ShowYourLove) & RecordedBy(ShowYourLove, bToBFouru) & SouthKorean(bToBFouru) & BoyBand(bToBFouru)\nExtendedPlay(Inside) & LeadSingleOf(ShowYourLove, Inside)\nContains(ShowYourLove, HopefulMessage)\nMember(Hyunsik, BtobFouru) & Wrote(Hyunsik, ShowYourLove)\nHave(ShowYourLove, MusicVideo)"
        ],
        "conclusion": "Show Your Love wasn't written by a member of a boy band.",
        "conclusion-FOL": "all x. all y. (Wrote(x, ShowYourLove) -> -(BoyBand(y) & MemberOf(x, y)))",
        "label": "ERROR"
    },
    {
        "premises": "Show Your Love is a song recorded by the South Korean boy band BtoB 4u.\nThe lead single of the extended play Inside is Show Your Love.\nShow Your Love contains a hopeful message.\nBtoB 4u member Hyunsik wrote Show Your Love.\nThere is a music video for Show Your Love.",
        "premises-FOL": [
            "Song(ShowYourLove) & RecordedBy(ShowYourLove, bToBFouru) & SouthKorean(bToBFouru) & BoyBand(bToBFouru)\nExtendedPlay(Inside) & LeadSingleOf(ShowYourLove, Inside)\nContains(ShowYourLove, HopefulMessage)\nMember(Hyunsik, BtobFouru) & Wrote(Hyunsik, ShowYourLove)\nHave(ShowYourLove, MusicVideo)"
        ],
        "conclusion": "A lead single of Inside contains a hopeful message.",
        "conclusion-FOL": "exists x. (LeadSingleOf(x, Inside) & Contains(x, HopefulMessage))",
        "label": "ERROR"
    },
    {
        "premises": "Show Your Love is a song recorded by the South Korean boy band BtoB 4u.\nThe lead single of the extended play Inside is Show Your Love.\nShow Your Love contains a hopeful message.\nBtoB 4u member Hyunsik wrote Show Your Love.\nThere is a music video for Show Your Love.",
        "premises-FOL": [
            "Song(ShowYourLove) & RecordedBy(ShowYourLove, bToBFouru) & SouthKorean(bToBFouru) & BoyBand(bToBFouru)\nExtendedPlay(Inside) & LeadSingleOf(ShowYourLove, Inside)\nContains(ShowYourLove, HopefulMessage)\nMember(Hyunsik, BtobFouru) & Wrote(Hyunsik, ShowYourLove)\nHave(ShowYourLove, MusicVideo)"
        ],
        "conclusion": "Hyunsik is Korean.",
        "conclusion-FOL": "Korean(Hyunsik)",
        "label": "ERROR"
    },
    {
        "premises": "All tables are round.\nSome pieces of furniture are tables.",
        "premises-FOL": [
            "all x. (Table(x) -> Round(x))\nexists x. exists y. (Furniture(x) & Furniture(y) & Table(x) & Table(y) & -(x=y))"
        ],
        "conclusion": "Some pieces of furniture are round.",
        "conclusion-FOL": "exists x. exists y. (Furniture(x) & Furniture(y) & Round(x) & Round(y) & -(x=y))",
        "label": "ERROR"
    },
    {
        "premises": "All juvenile delinquents have committed a crime.\nSome juvenile delinquents are products of broken homes.",
        "premises-FOL": [
            "all x. (JuvenileDelinquent(x) -> Commited(x, Crime))\nexists x. exists y. (JuvenileDelinquent(x) & JuvenileDelinquent(y) & ProductOf(x, BrokenHome) & ProductOf(y, BrokenHome) & -(x=y))"
        ],
        "conclusion": "Some people who have committed a crime are products of broken homes.",
        "conclusion-FOL": "exists x. exists y. (Commited(x, Crime) & Commited(y, Crime) & ProductOf(x, BrokenHome) & ProductOf(y, BrokenHome) & -(x=y))",
        "label": "ERROR"
    },
    {
        "premises": "All mind-reading is either brain reading or brain decoding. \nAll brain decoding that is mind-reading is extracting information from BOLD signals.\nNo studies that are mind-reading and extract information from BOLD signals are without statistical pattern analysis. \nWriting a novel is without statistical pattern analysis.\nIf multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.\nMultivoxel (pattern) analysis is a type of mind-reading.",
        "premises-FOL": [
            "all x. (MindReading(x) & (((BrainReading(x) & -BrainDecoding(x)) | (-BrainReading(x) & BrainDecoding(x)))))\nall x. ((MindReading(x) & BrainDecoding(x)) -> ExtractingFrom(x, Information, bOLDSignals))\nall x. ((MindReading(x) & ExtractingFrom(x, Information, bOLDSignals)) -> Uses(x, StatisticalPatternAnalysis))\nall x. (NovelWriting(x) -> -Uses(x, StatisticalPatternAnalysis)) \nMindReading(MultivoxelPatternAnalysis) & (-Uses(MultivoxelPatternAnalysis, StatisticalPatternAnalysis) & BrainReading(MultivoxelPatternAnalysis)) ->  (-Uses(MultivoxelPatternAnalysis, StatisticalPatternAnalysis) & (-BrainDecoding(MultivoxelPatternAnalysis)))\nMindReading(MultivoxelPatternAnalysis) "
        ],
        "conclusion": "Multivoxel (pattern) analysis is a brain decoding.",
        "conclusion-FOL": "MindReading(MultivoxelPatternAnalysis) & BrainDecoding(MultivoxelPatternAnalysis)",
        "label": "ERROR"
    },
    {
        "premises": "All mind-reading is either brain reading or brain decoding. \nAll brain decoding that is mind-reading is extracting information from BOLD signals.\nNo studies that are mind-reading and extract information from BOLD signals are without statistical pattern analysis. \nWriting a novel is without statistical pattern analysis.\nIf multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.\nMultivoxel (pattern) analysis is a type of mind-reading.",
        "premises-FOL": [
            "all x. (MindReading(x) & (((BrainReading(x) & -BrainDecoding(x)) | (-BrainReading(x) & BrainDecoding(x)))))\nall x. ((MindReading(x) & BrainDecoding(x)) -> ExtractingFrom(x, Information, bOLDSignals))\nall x. ((MindReading(x) & ExtractingFrom(x, Information, bOLDSignals)) -> Uses(x, StatisticalPatternAnalysis))\nall x. (NovelWriting(x) -> -Uses(x, StatisticalPatternAnalysis)) \nMindReading(MultivoxelPatternAnalysis) & (-Uses(MultivoxelPatternAnalysis, StatisticalPatternAnalysis) & BrainReading(MultivoxelPatternAnalysis)) ->  (-Uses(MultivoxelPatternAnalysis, StatisticalPatternAnalysis) & (-BrainDecoding(MultivoxelPatternAnalysis)))\nMindReading(MultivoxelPatternAnalysis) "
        ],
        "conclusion": "Multivoxel (pattern) analysis is the writing of a novel.",
        "conclusion-FOL": "MindReading(MultivoxelPatternAnalysis) & NovelWriting(MultivoxelPatternAnalysis)",
        "label": "ERROR"
    },
    {
        "premises": "All mind-reading is either brain reading or brain decoding. \nAll brain decoding that is mind-reading is extracting information from BOLD signals.\nNo studies that are mind-reading and extract information from BOLD signals are without statistical pattern analysis. \nWriting a novel is without statistical pattern analysis.\nIf multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.\nMultivoxel (pattern) analysis is a type of mind-reading.",
        "premises-FOL": [
            "all x. (MindReading(x) & (((BrainReading(x) & -BrainDecoding(x)) | (-BrainReading(x) & BrainDecoding(x)))))\nall x. ((MindReading(x) & BrainDecoding(x)) -> ExtractingFrom(x, Information, bOLDSignals))\nall x. ((MindReading(x) & ExtractingFrom(x, Information, bOLDSignals)) -> Uses(x, StatisticalPatternAnalysis))\nall x. (NovelWriting(x) -> -Uses(x, StatisticalPatternAnalysis)) \nMindReading(MultivoxelPatternAnalysis) & (-Uses(MultivoxelPatternAnalysis, StatisticalPatternAnalysis) & BrainReading(MultivoxelPatternAnalysis)) ->  (-Uses(MultivoxelPatternAnalysis, StatisticalPatternAnalysis) & (-BrainDecoding(MultivoxelPatternAnalysis)))\nMindReading(MultivoxelPatternAnalysis) "
        ],
        "conclusion": "Multivoxel (pattern) analysis is without statistical pattern analysis and writing a novel.",
        "conclusion-FOL": "-(Uses(MultivoxelPatternAnalysis, StatisticalPatternAnalysis) & NovelWriting(MultivoxelPatternAnalysis))",
        "label": "ERROR"
    },
    {
        "premises": "All mind-reading is either brain reading or brain decoding. \nAll brain decoding that is mind-reading is extracting information from BOLD signals.\nNo studies that are mind-reading and extract information from BOLD signals are without statistical pattern analysis. \nWriting a novel is without statistical pattern analysis.\nIf multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.\nMultivoxel (pattern) analysis is a type of mind-reading.",
        "premises-FOL": [
            "all x. (MindReading(x) & (((BrainReading(x) & -BrainDecoding(x)) | (-BrainReading(x) & BrainDecoding(x)))))\nall x. ((MindReading(x) & BrainDecoding(x)) -> ExtractingFrom(x, Information, bOLDSignals))\nall x. ((MindReading(x) & ExtractingFrom(x, Information, bOLDSignals)) -> Uses(x, StatisticalPatternAnalysis))\nall x. (NovelWriting(x) -> -Uses(x, StatisticalPatternAnalysis)) \nMindReading(MultivoxelPatternAnalysis) & (-Uses(MultivoxelPatternAnalysis, StatisticalPatternAnalysis) & BrainReading(MultivoxelPatternAnalysis)) ->  (-Uses(MultivoxelPatternAnalysis, StatisticalPatternAnalysis) & (-BrainDecoding(MultivoxelPatternAnalysis)))\nMindReading(MultivoxelPatternAnalysis) "
        ],
        "conclusion": "Multivoxel (pattern) analysis is without statistical pattern analysis or writing a novel.",
        "conclusion-FOL": "-(Uses(MultivoxelPatternAnalysis, StatisticalPatternAnalysis) | NovelWriting(MultivoxelPatternAnalysis))",
        "label": "ERROR"
    },
    {
        "premises": "All mind-reading is either brain reading or brain decoding. \nAll brain decoding that is mind-reading is extracting information from BOLD signals.\nNo studies that are mind-reading and extract information from BOLD signals are without statistical pattern analysis. \nWriting a novel is without statistical pattern analysis.\nIf multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.\nMultivoxel (pattern) analysis is a type of mind-reading.",
        "premises-FOL": [
            "all x. (MindReading(x) & (((BrainReading(x) & -BrainDecoding(x)) | (-BrainReading(x) & BrainDecoding(x)))))\nall x. ((MindReading(x) & BrainDecoding(x)) -> ExtractingFrom(x, Information, bOLDSignals))\nall x. ((MindReading(x) & ExtractingFrom(x, Information, bOLDSignals)) -> Uses(x, StatisticalPatternAnalysis))\nall x. (NovelWriting(x) -> -Uses(x, StatisticalPatternAnalysis)) \nMindReading(MultivoxelPatternAnalysis) & (-Uses(MultivoxelPatternAnalysis, StatisticalPatternAnalysis) & BrainReading(MultivoxelPatternAnalysis)) ->  (-Uses(MultivoxelPatternAnalysis, StatisticalPatternAnalysis) & (-BrainDecoding(MultivoxelPatternAnalysis)))\nMindReading(MultivoxelPatternAnalysis) "
        ],
        "conclusion": "Multivoxel (pattern) analysis is either without statistical pattern analysis or writing a novel.",
        "conclusion-FOL": "-((Uses(MultivoxelPatternAnalysis, StatisticalPatternAnalysis) & -Writing(MultivoxelPatternAnalysis, aNovel)) | (-Uses(MultivoxelPatternAnalysis, StatisticalPatternAnalysis) & Writing(MultivoxelPatternAnalysis, aNovel)))",
        "label": "ERROR"
    },
    {
        "premises": "All mind-reading is either brain reading or brain decoding. \nAll brain decoding that is mind-reading is extracting information from BOLD signals.\nNo studies that are mind-reading and extract information from BOLD signals are without statistical pattern analysis. \nWriting a novel is without statistical pattern analysis.\nIf multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.\nMultivoxel (pattern) analysis is a type of mind-reading.",
        "premises-FOL": [
            "all x. (MindReading(x) & (((BrainReading(x) & -BrainDecoding(x)) | (-BrainReading(x) & BrainDecoding(x)))))\nall x. ((MindReading(x) & BrainDecoding(x)) -> ExtractingFrom(x, Information, bOLDSignals))\nall x. ((MindReading(x) & ExtractingFrom(x, Information, bOLDSignals)) -> Uses(x, StatisticalPatternAnalysis))\nall x. (NovelWriting(x) -> -Uses(x, StatisticalPatternAnalysis)) \nMindReading(MultivoxelPatternAnalysis) & (-Uses(MultivoxelPatternAnalysis, StatisticalPatternAnalysis) & BrainReading(MultivoxelPatternAnalysis)) ->  (-Uses(MultivoxelPatternAnalysis, StatisticalPatternAnalysis) & (-BrainDecoding(MultivoxelPatternAnalysis)))\nMindReading(MultivoxelPatternAnalysis) "
        ],
        "conclusion": "If multivoxel (pattern) analysis is writing a novel, then multivoxel (pattern) analysis is neither without statistical pattern analysis nor writing a novel.",
        "conclusion-FOL": "(MindReading(MultivoxelPatternAnalysis) & NovelWriting(MultivoxelPatternAnalysis)) -> (Uses(MultivoxelPatternAnalysis, StatisticalPatternAnalysis) | -NovelWriting(MultivoxelPatternAnalysis))",
        "label": "ERROR"
    },
    {
        "premises": "If you have room for dessert, you have room for broccoli.\nEveryone at Luis's dinner party has room for dessert, including Luis.\nMauricia does not have room for broccoli.\nLuis's dinner party is the first ever dinner party that Allison has attended.\nGustave has room for both broccoli and asparagus.\nBroccoli and asparagus are both vegetables.",
        "premises-FOL": [
            "all x. (RoomFor(x, Dessert) -> RoomFor(x, Broccoli))\nall x. (AtLuisParty(x) -> RoomFor(x, Dessert))\n-RoomFor(Mauricia, Broccoli)\nAtLuisParty(Allison) & FirstDinnerPartyFor(Luisparty, Allison) \nRoomFor(Gustave, Broccoli) & RoomFor(Gustave, Asparagus)\nVegetable(Broccoli) & Vegetable(Asparagus)"
        ],
        "conclusion": "Allison has room for broccoli.",
        "conclusion-FOL": "RoomFor(Allison, Broccoli)",
        "label": "ERROR"
    },
    {
        "premises": "If you have room for dessert, you have room for broccoli.\nEveryone at Luis's dinner party has room for dessert, including Luis.\nMauricia does not have room for broccoli.\nLuis's dinner party is the first ever dinner party that Allison has attended.\nGustave has room for both broccoli and asparagus.\nBroccoli and asparagus are both vegetables.",
        "premises-FOL": [
            "all x. (RoomFor(x, Dessert) -> RoomFor(x, Broccoli))\nall x. (AtLuisParty(x) -> RoomFor(x, Dessert))\n-RoomFor(Mauricia, Broccoli)\nAtLuisParty(Allison) & FirstDinnerPartyFor(Luisparty, Allison) \nRoomFor(Gustave, Broccoli) & RoomFor(Gustave, Asparagus)\nVegetable(Broccoli) & Vegetable(Asparagus)"
        ],
        "conclusion": "Mauricia is at Luis's dinner party.",
        "conclusion-FOL": "AtLuisParty(Mauricia)",
        "label": "ERROR"
    },
    {
        "premises": "If you have room for dessert, you have room for broccoli.\nEveryone at Luis's dinner party has room for dessert, including Luis.\nMauricia does not have room for broccoli.\nLuis's dinner party is the first ever dinner party that Allison has attended.\nGustave has room for both broccoli and asparagus.\nBroccoli and asparagus are both vegetables.",
        "premises-FOL": [
            "all x. (RoomFor(x, Dessert) -> RoomFor(x, Broccoli))\nall x. (AtLuisParty(x) -> RoomFor(x, Dessert))\n-RoomFor(Mauricia, Broccoli)\nAtLuisParty(Allison) & FirstDinnerPartyFor(Luisparty, Allison) \nRoomFor(Gustave, Broccoli) & RoomFor(Gustave, Asparagus)\nVegetable(Broccoli) & Vegetable(Asparagus)"
        ],
        "conclusion": "Gustav has room for dessert.",
        "conclusion-FOL": "RoomFor(Gustave, Dessert)",
        "label": "ERROR"
    },
    {
        "premises": "Imagine Dragons are an American pop-rock band.\nThe lead singer of Imagine Dragons is Dan.\nDan is also a songwriter.\nAll lead singers are singers.\nAll singers are musicians.\nDemons is one of the most popular singles of Imagine Dragons.\nSome singles of Imagine Dragons have been on Billboard Hot 100.",
        "premises-FOL": [
            "American(ImagineDragon) & RockBand(ImagineDragon)\nLeadSinger(ImagineDragon, Dan)\nSongWriter(Dan)\nall x. all y. (LeadSinger(x, y) -> Singer(y))\nall x. (Singer(x) -> Musician(x))\nPopularSingle(ImagineDragon, Demons)\nexists x. exists y. (PopularSingle(ImagineDragon, x) & BillboardHotOneZeroZero(x)) & (-(x=y)) & (PopularSingle(ImagineDragon, y) & BillboardHotOneZeroZero(y))"
        ],
        "conclusion": "Some rock band has a lead singer who is also a songwriter.",
        "conclusion-FOL": "exists x. exists y. (RockBand(x) & LeadSinger(x, y) & SongWriter(y))",
        "label": "ERROR"
    },
    {
        "premises": "Imagine Dragons are an American pop-rock band.\nThe lead singer of Imagine Dragons is Dan.\nDan is also a songwriter.\nAll lead singers are singers.\nAll singers are musicians.\nDemons is one of the most popular singles of Imagine Dragons.\nSome singles of Imagine Dragons have been on Billboard Hot 100.",
        "premises-FOL": [
            "American(ImagineDragon) & RockBand(ImagineDragon)\nLeadSinger(ImagineDragon, Dan)\nSongWriter(Dan)\nall x. all y. (LeadSinger(x, y) -> Singer(y))\nall x. (Singer(x) -> Musician(x))\nPopularSingle(ImagineDragon, Demons)\nexists x. exists y. (PopularSingle(ImagineDragon, x) & BillboardHotOneZeroZero(x)) & (-(x=y)) & (PopularSingle(ImagineDragon, y) & BillboardHotOneZeroZero(y))"
        ],
        "conclusion": "Dan is not a musician.",
        "conclusion-FOL": "-Musician(Dan)",
        "label": "ERROR"
    },
    {
        "premises": "Imagine Dragons are an American pop-rock band.\nThe lead singer of Imagine Dragons is Dan.\nDan is also a songwriter.\nAll lead singers are singers.\nAll singers are musicians.\nDemons is one of the most popular singles of Imagine Dragons.\nSome singles of Imagine Dragons have been on Billboard Hot 100.",
        "premises-FOL": [
            "American(ImagineDragon) & RockBand(ImagineDragon)\nLeadSinger(ImagineDragon, Dan)\nSongWriter(Dan)\nall x. all y. (LeadSinger(x, y) -> Singer(y))\nall x. (Singer(x) -> Musician(x))\nPopularSingle(ImagineDragon, Demons)\nexists x. exists y. (PopularSingle(ImagineDragon, x) & BillboardHotOneZeroZero(x)) & (-(x=y)) & (PopularSingle(ImagineDragon, y) & BillboardHotOneZeroZero(y))"
        ],
        "conclusion": "Demons has been on Billboard Hot 100.",
        "conclusion-FOL": "BillboardHotOneZeroZero(Demons)",
        "label": "ERROR"
    },
    {
        "premises": "All philosophers reason. \nSome sophists reason. \nAll who can reason can distinguish truth from falsehood.\nNobody who can distinguish truth from falsehood is morally perfect.  \nThe theistic God is morally perfect.",
        "premises-FOL": [
            "all x. (Philosopher(x) -> Reason(x))\nexists x. (Sophist(x) & Reason(x))\nall x. (Reason(x) -> CanDistinguishFrom(x, Truth, Falsehood))\nall x. (CanDistinguishFrom(x, Truth, Falsehood) -> -MorallyPerfect(x))\nMorallyPerfect(TheisticGod)"
        ],
        "conclusion": "The theistic God is a sophist.",
        "conclusion-FOL": "Sophist(TheisticGod)",
        "label": "ERROR"
    },
    {
        "premises": "All philosophers reason. \nSome sophists reason. \nAll who can reason can distinguish truth from falsehood.\nNobody who can distinguish truth from falsehood is morally perfect.  \nThe theistic God is morally perfect.",
        "premises-FOL": [
            "all x. (Philosopher(x) -> Reason(x))\nexists x. (Sophist(x) & Reason(x))\nall x. (Reason(x) -> CanDistinguishFrom(x, Truth, Falsehood))\nall x. (CanDistinguishFrom(x, Truth, Falsehood) -> -MorallyPerfect(x))\nMorallyPerfect(TheisticGod)"
        ],
        "conclusion": "The theistic God is a sophist and a philosopher.",
        "conclusion-FOL": "Sophist(TheisticGod) & Philosopher(TheisticGod)",
        "label": "ERROR"
    },
    {
        "premises": "All philosophers reason. \nSome sophists reason. \nAll who can reason can distinguish truth from falsehood.\nNobody who can distinguish truth from falsehood is morally perfect.  \nThe theistic God is morally perfect.",
        "premises-FOL": [
            "all x. (Philosopher(x) -> Reason(x))\nexists x. (Sophist(x) & Reason(x))\nall x. (Reason(x) -> CanDistinguishFrom(x, Truth, Falsehood))\nall x. (CanDistinguishFrom(x, Truth, Falsehood) -> -MorallyPerfect(x))\nMorallyPerfect(TheisticGod)"
        ],
        "conclusion": "if the theistic God is a philosopher, then he is not a sophist.",
        "conclusion-FOL": "Philosopher(TheisticGod) -> -Sophist(TheisticGod)",
        "label": "ERROR"
    },
    {
        "premises": "Common utilities include water, electricity, gas, heating, sewer, trash, and recycling.\nMany apartment rents cover the cost of water and electricity.\nSusan lives in an apartment where the rent covers all utilities.\nThe rent of the apartment where Ava lives does not cover any utility expenses.\nNoah lives in an apartment where the rent does not cover heating.",
        "premises-FOL": [
            "CommonUtilities(Water) & CommonUtilities(Electricity) & CommonUtilities(Gas) & CommonUtilities(Heating)\nexists x. (Apartment(x) & Cover(x, Water) & Cover(x, Electricity))\nall x. (Apartment(x) & LiveIn(Susan, x) & Cover(x, Water) & Cover(x, Electricity) & Cover(x, Gas) & Cover(x, Heating))\nall x. (Apartment(x) & LiveIn(Ava, x) & -Cover(x, Water) & -Cover(x, Electricity) & -Cover(x, Gas) & -Cover(x, Heating))\nall x. (Apartment(x) & LiveIn(Noah, x) & -Cover(x, Heating))"
        ],
        "conclusion": "Noah needs to pay the water bill.",
        "conclusion-FOL": "all x. (Apartment(x) & LiveIn(Noah, x) & -Cover(x, Water))",
        "label": "ERROR"
    },
    {
        "premises": "Common utilities include water, electricity, gas, heating, sewer, trash, and recycling.\nMany apartment rents cover the cost of water and electricity.\nSusan lives in an apartment where the rent covers all utilities.\nThe rent of the apartment where Ava lives does not cover any utility expenses.\nNoah lives in an apartment where the rent does not cover heating.",
        "premises-FOL": [
            "CommonUtilities(Water) & CommonUtilities(Electricity) & CommonUtilities(Gas) & CommonUtilities(Heating)\nexists x. (Apartment(x) & Cover(x, Water) & Cover(x, Electricity))\nall x. (Apartment(x) & LiveIn(Susan, x) & Cover(x, Water) & Cover(x, Electricity) & Cover(x, Gas) & Cover(x, Heating))\nall x. (Apartment(x) & LiveIn(Ava, x) & -Cover(x, Water) & -Cover(x, Electricity) & -Cover(x, Gas) & -Cover(x, Heating))\nall x. (Apartment(x) & LiveIn(Noah, x) & -Cover(x, Heating))"
        ],
        "conclusion": "Noah and Ava both need to pay the heating bill.",
        "conclusion-FOL": "-Cover(Noah, Heating) & -Cover(Ava, Heating)",
        "label": "ERROR"
    },
    {
        "premises": "Common utilities include water, electricity, gas, heating, sewer, trash, and recycling.\nMany apartment rents cover the cost of water and electricity.\nSusan lives in an apartment where the rent covers all utilities.\nThe rent of the apartment where Ava lives does not cover any utility expenses.\nNoah lives in an apartment where the rent does not cover heating.",
        "premises-FOL": [
            "CommonUtilities(Water) & CommonUtilities(Electricity) & CommonUtilities(Gas) & CommonUtilities(Heating)\nexists x. (Apartment(x) & Cover(x, Water) & Cover(x, Electricity))\nall x. (Apartment(x) & LiveIn(Susan, x) & Cover(x, Water) & Cover(x, Electricity) & Cover(x, Gas) & Cover(x, Heating))\nall x. (Apartment(x) & LiveIn(Ava, x) & -Cover(x, Water) & -Cover(x, Electricity) & -Cover(x, Gas) & -Cover(x, Heating))\nall x. (Apartment(x) & LiveIn(Noah, x) & -Cover(x, Heating))"
        ],
        "conclusion": "Susan does not need to pay the water bill.",
        "conclusion-FOL": "all x. (Apartment(x) & LiveIn(Susan, x) & Cover(x, Water))",
        "label": "ERROR"
    },
    {
        "premises": "All clothes are products. \nNo products are perfect. \nAll dresses are clothes.\nAll skirts are dresses. \nIf the fabric bundle is a piece of clothing, then the fabric bundle is a perfect dress.",
        "premises-FOL": [
            "all x. (Clothes(x) -> Product(x))\nall x. (Product(x) -> -Perfect(x))\nall x. (Dress(x) -> Clothes(x))\nall x. (Skirt(x) -> Dress(x))\nClothes(FabricBundle) -> Perfect(FabricBundle) & Dress(FabricBundle)"
        ],
        "conclusion": "The fabric bundle is perfect.",
        "conclusion-FOL": "Perfect(Fabricbundle)",
        "label": "ERROR"
    },
    {
        "premises": "All clothes are products. \nNo products are perfect. \nAll dresses are clothes.\nAll skirts are dresses. \nIf the fabric bundle is a piece of clothing, then the fabric bundle is a perfect dress.",
        "premises-FOL": [
            "all x. (Clothes(x) -> Product(x))\nall x. (Product(x) -> -Perfect(x))\nall x. (Dress(x) -> Clothes(x))\nall x. (Skirt(x) -> Dress(x))\nClothes(FabricBundle) -> Perfect(FabricBundle) & Dress(FabricBundle)"
        ],
        "conclusion": "The fabric bundle is a skirt.",
        "conclusion-FOL": "Skirt(Fabricbundle)",
        "label": "ERROR"
    },
    {
        "premises": "All clothes are products. \nNo products are perfect. \nAll dresses are clothes.\nAll skirts are dresses. \nIf the fabric bundle is a piece of clothing, then the fabric bundle is a perfect dress.",
        "premises-FOL": [
            "all x. (Clothes(x) -> Product(x))\nall x. (Product(x) -> -Perfect(x))\nall x. (Dress(x) -> Clothes(x))\nall x. (Skirt(x) -> Dress(x))\nClothes(FabricBundle) -> Perfect(FabricBundle) & Dress(FabricBundle)"
        ],
        "conclusion": "The fabric bundle is not a skirt.",
        "conclusion-FOL": "-Skirt(Fabricbundle)",
        "label": "ERROR"
    },
    {
        "premises": "All pets are animals.\nPets can be either a dog or a cat.\nIf a person has a pet, they care for that pet. \nDogs and cats can be naughty. \nPets who are naughty are not liked as much. \nCharlie has a naughty pet dog named Leo. ",
        "premises-FOL": [
            "all x. (Pet(x) -> Animal(x))\nall x. (Pet(x) -> (((Dog(x) & -Cat(x)) | (-Dog(x) & Cat(x)))))\nall x. all y. ((Pet(y) & OwnedBy(x,y)) -> Cares(x, y))\nexists x. exists y. (Cat(x) & Naughty(x) & (-(x=y)) & Dog(y) & Naughty(y))\nall x. all y. ((Pet(x) & Naughty(x) & OwnedBy(x,y)) -> -Liked(x, y))\nOwnedBy(Leo, Charlie) & Pet(Leo) & Dog(Leo) & Naughty(Leo)"
        ],
        "conclusion": "Leo is an animal.",
        "conclusion-FOL": "Animal(Leo)",
        "label": "ERROR"
    },
    {
        "premises": "All pets are animals.\nPets can be either a dog or a cat.\nIf a person has a pet, they care for that pet. \nDogs and cats can be naughty. \nPets who are naughty are not liked as much. \nCharlie has a naughty pet dog named Leo. ",
        "premises-FOL": [
            "all x. (Pet(x) -> Animal(x))\nall x. (Pet(x) -> (((Dog(x) & -Cat(x)) | (-Dog(x) & Cat(x)))))\nall x. all y. ((Pet(y) & OwnedBy(x,y)) -> Cares(x, y))\nexists x. exists y. (Cat(x) & Naughty(x) & (-(x=y)) & Dog(y) & Naughty(y))\nall x. all y. ((Pet(x) & Naughty(x) & OwnedBy(x,y)) -> -Liked(x, y))\nOwnedBy(Leo, Charlie) & Pet(Leo) & Dog(Leo) & Naughty(Leo)"
        ],
        "conclusion": "Charlie does not like Leo and does not care for Leo.",
        "conclusion-FOL": "-Liked(Leo, Charlie) & -Cares(Charlie, Leo)",
        "label": "ERROR"
    },
    {
        "premises": "All pets are animals.\nPets can be either a dog or a cat.\nIf a person has a pet, they care for that pet. \nDogs and cats can be naughty. \nPets who are naughty are not liked as much. \nCharlie has a naughty pet dog named Leo. ",
        "premises-FOL": [
            "all x. (Pet(x) -> Animal(x))\nall x. (Pet(x) -> (((Dog(x) & -Cat(x)) | (-Dog(x) & Cat(x)))))\nall x. all y. ((Pet(y) & OwnedBy(x,y)) -> Cares(x, y))\nexists x. exists y. (Cat(x) & Naughty(x) & (-(x=y)) & Dog(y) & Naughty(y))\nall x. all y. ((Pet(x) & Naughty(x) & OwnedBy(x,y)) -> -Liked(x, y))\nOwnedBy(Leo, Charlie) & Pet(Leo) & Dog(Leo) & Naughty(Leo)"
        ],
        "conclusion": "Dogs are not always naughty.",
        "conclusion-FOL": "all x. (Dog(x) -> -Naughty(x))",
        "label": "ERROR"
    },
    {
        "premises": "Surprises are either fun or dreadful.\nAll scares are surprises.",
        "premises-FOL": [
            "all x. (Surprise(x) -> (((Fun(x) & -Dreadful(x)) | (-Fun(x) & Dreadful(x)))))\nall x. (Scare(x) -> Surprise(x))"
        ],
        "conclusion": "All scares are fun.",
        "conclusion-FOL": "all x. (Scare(x) -> Fun(x))",
        "label": "ERROR"
    },
    {
        "premises": "All books written by Cixin Liu have sold more than 1 million copies. \nSome books that have won the Hugo Award were written by Cixin Liu.\nAll books about the future are forward-looking.\nThe book Three-Body Problem has sold more than 1 million copies.\nThe Three-Body Problem is about the future.",
        "premises-FOL": [
            "all x. ((Book(x) & WrittenBy(x, CixinLiu)) -> exists y.(MoreThan(y, OneMillion) & Sold(x,y)))\nexists x. (Won(x, HugoAward) & Book(x) & WrittenBy(x, CixinLiu))\nall x. ((Book(x) & AboutFuture(x)) -> FowardLooking(x))\nBook(ThreeBodyProblem) & exists y.(MoreThan(y, OneMillion) & Sold(ThreeBodyProblem,y))\nAboutFuture(ThreeBodyProblem)"
        ],
        "conclusion": "The Three-Body Problem won the Hugo Award.",
        "conclusion-FOL": "Won(ThreeBodyProblem, HugoAward)",
        "label": "ERROR"
    },
    {
        "premises": "All books written by Cixin Liu have sold more than 1 million copies. \nSome books that have won the Hugo Award were written by Cixin Liu.\nAll books about the future are forward-looking.\nThe book Three-Body Problem has sold more than 1 million copies.\nThe Three-Body Problem is about the future.",
        "premises-FOL": [
            "all x. ((Book(x) & WrittenBy(x, CixinLiu)) -> exists y.(MoreThan(y, OneMillion) & Sold(x,y)))\nexists x. (Won(x, HugoAward) & Book(x) & WrittenBy(x, CixinLiu))\nall x. ((Book(x) & AboutFuture(x)) -> FowardLooking(x))\nBook(ThreeBodyProblem) & exists y.(MoreThan(y, OneMillion) & Sold(ThreeBodyProblem,y))\nAboutFuture(ThreeBodyProblem)"
        ],
        "conclusion": "The Three-Body Problem is forward-looking.",
        "conclusion-FOL": "AboutFuture(ThreeBodyProblem)",
        "label": "ERROR"
    },
    {
        "premises": "All books written by Cixin Liu have sold more than 1 million copies. \nSome books that have won the Hugo Award were written by Cixin Liu.\nAll books about the future are forward-looking.\nThe book Three-Body Problem has sold more than 1 million copies.\nThe Three-Body Problem is about the future.",
        "premises-FOL": [
            "all x. ((Book(x) & WrittenBy(x, CixinLiu)) -> exists y.(MoreThan(y, OneMillion) & Sold(x,y)))\nexists x. (Won(x, HugoAward) & Book(x) & WrittenBy(x, CixinLiu))\nall x. ((Book(x) & AboutFuture(x)) -> FowardLooking(x))\nBook(ThreeBodyProblem) & exists y.(MoreThan(y, OneMillion) & Sold(ThreeBodyProblem,y))\nAboutFuture(ThreeBodyProblem)"
        ],
        "conclusion": "The Three-Body Problem was written by Cixin Liu.",
        "conclusion-FOL": "WrittenBy(ThreeBodyProblem, CixinLiu)",
        "label": "ERROR"
    },
    {
        "premises": "Some people are both late-night and early-morning people.\nIf a person is an earl- morning person, they have early-morning habits.\nEveryone who has early-morning habits gets up early.\nEveryone who gets up early catches the sunrise.\nJames doesn't catch the sunrise.",
        "premises-FOL": [
            "exists x. (LateNightPerson(x) & EarlyMorningPerson(x))\nall x. (EarlyMorningPerson(x) -> Have(x, EarlyMorningHabit))\nall x. (Have(x, EarlyMorningHabit) -> GetUpEarly(x))\nall x. (GetUpEarly(x) -> CatchTheSunrise(x))\n-CatchTheSunrise(James)"
        ],
        "conclusion": "James is a late night person.",
        "conclusion-FOL": "LateNightPerson(James)",
        "label": "ERROR"
    },
    {
        "premises": "Some people are both late-night and early-morning people.\nIf a person is an earl- morning person, they have early-morning habits.\nEveryone who has early-morning habits gets up early.\nEveryone who gets up early catches the sunrise.\nJames doesn't catch the sunrise.",
        "premises-FOL": [
            "exists x. (LateNightPerson(x) & EarlyMorningPerson(x))\nall x. (EarlyMorningPerson(x) -> Have(x, EarlyMorningHabit))\nall x. (Have(x, EarlyMorningHabit) -> GetUpEarly(x))\nall x. (GetUpEarly(x) -> CatchTheSunrise(x))\n-CatchTheSunrise(James)"
        ],
        "conclusion": "James is a late night person and an early-morning person.",
        "conclusion-FOL": "LateNightPerson(James) & EarlyMorningPerson(James)",
        "label": "ERROR"
    },
    {
        "premises": "Some people are both late-night and early-morning people.\nIf a person is an earl- morning person, they have early-morning habits.\nEveryone who has early-morning habits gets up early.\nEveryone who gets up early catches the sunrise.\nJames doesn't catch the sunrise.",
        "premises-FOL": [
            "exists x. (LateNightPerson(x) & EarlyMorningPerson(x))\nall x. (EarlyMorningPerson(x) -> Have(x, EarlyMorningHabit))\nall x. (Have(x, EarlyMorningHabit) -> GetUpEarly(x))\nall x. (GetUpEarly(x) -> CatchTheSunrise(x))\n-CatchTheSunrise(James)"
        ],
        "conclusion": "If James is an early-morning person, then he is a late night person.",
        "conclusion-FOL": "EarlyMorningPerson(James) -> LateNightPerson(James)",
        "label": "ERROR"
    },
    {
        "premises": "There is no dog on the roof.\nIf there is a dog on the roof, something went wrong.",
        "premises-FOL": [
            "all x. (Dog(x) -> -OnRoof(x)))\nall x. exists y. ((Dog(x) & OnRoof(x)) -> GoWrong(y))"
        ],
        "conclusion": "Something went wrong.",
        "conclusion-FOL": "exists x. (GoWrong(x))",
        "label": "ERROR"
    },
    {
        "premises": "Elephantopus is a genus of perennial plants in the daisy family.\nElephantopus is widespread over much of Africa, southern Asia, Australia, and the Americas.\nSeveral species of Elephantopus are native to the southeastern United States.\nElephantopus scaber is a traditional medicine.",
        "premises-FOL": [
            "all x. (Elephantopus(x) -> (Genus(x, Perennialplants) & BelongTo(x, Daisyfamily)))\nexists x. exists y. exists z.(Elephantopus(x) & In(x,Africa) & (-(x=y)) & Elephantopus(y) & In(y, Southernasia) & (-(x=z)) & (-(y=z)) & Elephantopus(z) & In(z, Australia))\nexists x. exists y. (Elephantopus(x) & NativeTo(x, Southeasternunitedstates) & (-(x=y)) & Elephantopus(y) & NativeTo(y, Southeasternunitedstates))\nall x. (ElephantopusScaber(x) -> TraditionalMedicine(x))"
        ],
        "conclusion": "Elephantopus is found in Australia and Southern Asia.",
        "conclusion-FOL": "exists xexists y.(Elephantopus(x) & In(x,Africa) & Elephantopus(y) & In(y,Africa))",
        "label": "ERROR"
    },
    {
        "premises": "Elephantopus is a genus of perennial plants in the daisy family.\nElephantopus is widespread over much of Africa, southern Asia, Australia, and the Americas.\nSeveral species of Elephantopus are native to the southeastern United States.\nElephantopus scaber is a traditional medicine.",
        "premises-FOL": [
            "all x. (Elephantopus(x) -> (Genus(x, Perennialplants) & BelongTo(x, Daisyfamily)))\nexists x. exists y. exists z.(Elephantopus(x) & In(x,Africa) & (-(x=y)) & Elephantopus(y) & In(y, Southernasia) & (-(x=z)) & (-(y=z)) & Elephantopus(z) & In(z, Australia))\nexists x. exists y. (Elephantopus(x) & NativeTo(x, Southeasternunitedstates) & (-(x=y)) & Elephantopus(y) & NativeTo(y, Southeasternunitedstates))\nall x. (ElephantopusScaber(x) -> TraditionalMedicine(x))"
        ],
        "conclusion": "No Elephantopus is native to the southeastern United States.",
        "conclusion-FOL": "all x. (Elephantopus(x) -> -NativeTo(x, Southeasternunitedstates))",
        "label": "ERROR"
    },
    {
        "premises": "Elephantopus is a genus of perennial plants in the daisy family.\nElephantopus is widespread over much of Africa, southern Asia, Australia, and the Americas.\nSeveral species of Elephantopus are native to the southeastern United States.\nElephantopus scaber is a traditional medicine.",
        "premises-FOL": [
            "all x. (Elephantopus(x) -> (Genus(x, Perennialplants) & BelongTo(x, Daisyfamily)))\nexists x. exists y. exists z.(Elephantopus(x) & In(x,Africa) & (-(x=y)) & Elephantopus(y) & In(y, Southernasia) & (-(x=z)) & (-(y=z)) & Elephantopus(z) & In(z, Australia))\nexists x. exists y. (Elephantopus(x) & NativeTo(x, Southeasternunitedstates) & (-(x=y)) & Elephantopus(y) & NativeTo(y, Southeasternunitedstates))\nall x. (ElephantopusScaber(x) -> TraditionalMedicine(x))"
        ],
        "conclusion": "Elephantopus is a traditional medicine.",
        "conclusion-FOL": "all x. (Elephantopus(x) -> TraditionalMedicine(x))",
        "label": "ERROR"
    },
    {
        "premises": "All Yale dormitories are located on the Yale campus. \nAll Yale buildings managed by Yale Housing are dormitories. \nAll Yale buildings operated by Yale Housing staff are managed by Yale Housing. \nNone of the Yale buildings open to students were built before 1701. \nAll Yale buildings located on the Yale campus are open to students. \nHarkness is either a Yale building operated by Yale Housing staff, or it is located on York Street. ",
        "premises-FOL": [
            "all x. (YaleDormitory(x) -> LocatedOn(x, YaleCampus))\nall x. ((YaleBuildings(x) & ManagedBy(x, YaleHousing)) -> YaleDormitory(x))\nall x. ((YaleBuildings(x) & OperatedBy(x, YaleHousingStaff)) -> ManagedBy(x, YaleHousing))\nall x. ((YaleBuildings(x) & OpenToStudents(x)) -> (-exists y.(Before(y, YrOneSevenZeroOne) & Established(x, y))))\nall x. ((YaleBuildings(x) & LocatedOn(x, YaleCampus)) -> OpenToStudents(x))\nYaleBuildings(Harkness) & (((OperatedBy(x, Harkness) & -LocatedOn(Harkness, YaleCampus)) | (-OperatedBy(x, Harkness) & LocatedOn(Harkness, YaleCampus))))"
        ],
        "conclusion": "Harkness is a Yale dormitory.",
        "conclusion-FOL": "YaleDormitory(Harkness)",
        "label": "ERROR"
    },
    {
        "premises": "All Yale dormitories are located on the Yale campus. \nAll Yale buildings managed by Yale Housing are dormitories. \nAll Yale buildings operated by Yale Housing staff are managed by Yale Housing. \nNone of the Yale buildings open to students were built before 1701. \nAll Yale buildings located on the Yale campus are open to students. \nHarkness is either a Yale building operated by Yale Housing staff, or it is located on York Street. ",
        "premises-FOL": [
            "all x. (YaleDormitory(x) -> LocatedOn(x, YaleCampus))\nall x. ((YaleBuildings(x) & ManagedBy(x, YaleHousing)) -> YaleDormitory(x))\nall x. ((YaleBuildings(x) & OperatedBy(x, YaleHousingStaff)) -> ManagedBy(x, YaleHousing))\nall x. ((YaleBuildings(x) & OpenToStudents(x)) -> (-exists y.(Before(y, YrOneSevenZeroOne) & Established(x, y))))\nall x. ((YaleBuildings(x) & LocatedOn(x, YaleCampus)) -> OpenToStudents(x))\nYaleBuildings(Harkness) & (((OperatedBy(x, Harkness) & -LocatedOn(Harkness, YaleCampus)) | (-OperatedBy(x, Harkness) & LocatedOn(Harkness, YaleCampus))))"
        ],
        "conclusion": "Harkness is not a Yale dormitory.",
        "conclusion-FOL": "-YaleDormitory(Harkness)",
        "label": "ERROR"
    },
    {
        "premises": "All Yale dormitories are located on the Yale campus. \nAll Yale buildings managed by Yale Housing are dormitories. \nAll Yale buildings operated by Yale Housing staff are managed by Yale Housing. \nNone of the Yale buildings open to students were built before 1701. \nAll Yale buildings located on the Yale campus are open to students. \nHarkness is either a Yale building operated by Yale Housing staff, or it is located on York Street. ",
        "premises-FOL": [
            "all x. (YaleDormitory(x) -> LocatedOn(x, YaleCampus))\nall x. ((YaleBuildings(x) & ManagedBy(x, YaleHousing)) -> YaleDormitory(x))\nall x. ((YaleBuildings(x) & OperatedBy(x, YaleHousingStaff)) -> ManagedBy(x, YaleHousing))\nall x. ((YaleBuildings(x) & OpenToStudents(x)) -> (-exists y.(Before(y, YrOneSevenZeroOne) & Established(x, y))))\nall x. ((YaleBuildings(x) & LocatedOn(x, YaleCampus)) -> OpenToStudents(x))\nYaleBuildings(Harkness) & (((OperatedBy(x, Harkness) & -LocatedOn(Harkness, YaleCampus)) | (-OperatedBy(x, Harkness) & LocatedOn(Harkness, YaleCampus))))"
        ],
        "conclusion": "Harkness is established before 1701.",
        "conclusion-FOL": "exists y.(Before(y, YearOneSevenZeroOne) & Established(x, y))",
        "label": "ERROR"
    },
    {
        "premises": "All Yale dormitories are located on the Yale campus. \nAll Yale buildings managed by Yale Housing are dormitories. \nAll Yale buildings operated by Yale Housing staff are managed by Yale Housing. \nNone of the Yale buildings open to students were built before 1701. \nAll Yale buildings located on the Yale campus are open to students. \nHarkness is either a Yale building operated by Yale Housing staff, or it is located on York Street. ",
        "premises-FOL": [
            "all x. (YaleDormitory(x) -> LocatedOn(x, YaleCampus))\nall x. ((YaleBuildings(x) & ManagedBy(x, YaleHousing)) -> YaleDormitory(x))\nall x. ((YaleBuildings(x) & OperatedBy(x, YaleHousingStaff)) -> ManagedBy(x, YaleHousing))\nall x. ((YaleBuildings(x) & OpenToStudents(x)) -> (-exists y.(Before(y, YrOneSevenZeroOne) & Established(x, y))))\nall x. ((YaleBuildings(x) & LocatedOn(x, YaleCampus)) -> OpenToStudents(x))\nYaleBuildings(Harkness) & (((OperatedBy(x, Harkness) & -LocatedOn(Harkness, YaleCampus)) | (-OperatedBy(x, Harkness) & LocatedOn(Harkness, YaleCampus))))"
        ],
        "conclusion": "Harkness is not established before 1701.",
        "conclusion-FOL": "-exists y.(Before(y, YearOneSevenZeroOne) & Established(x, y))",
        "label": "ERROR"
    },
    {
        "premises": "There are no mansion houses in an urban area.\nAll skyscrapers are in urban areas.\nEvery creepy haunted house is a mansion house.\nEvery terrifying building on Halloween is a creepy haunted house.\nThe LaLaurie House is a creepy haunted house or a terrifying building on Halloween.",
        "premises-FOL": [
            "all x. (InUrbanArea(x) -> -MansionHouse(x))\nall x. (Skyscraper(x) -> InUrbanArea(x))\nall x. (CreepyHauntedHouse(x) -> MansionHouse(x))\nall x. (TerrifyingBuilding(x) & OnHalloween(x) -> CreepyHauntedHouse(x))\nCreepyHauntedHouse(LaLaurieHouse) | TerrifyingBuilding(LaLaurieHouse) & OnHalloween(LaLaurieHouse)"
        ],
        "conclusion": "The LaLaurie House is a skyscraper.",
        "conclusion-FOL": "Skyscraper(LaLaurieHouse)",
        "label": "ERROR"
    },
    {
        "premises": "There are no mansion houses in an urban area.\nAll skyscrapers are in urban areas.\nEvery creepy haunted house is a mansion house.\nEvery terrifying building on Halloween is a creepy haunted house.\nThe LaLaurie House is a creepy haunted house or a terrifying building on Halloween.",
        "premises-FOL": [
            "all x. (InUrbanArea(x) -> -MansionHouse(x))\nall x. (Skyscraper(x) -> InUrbanArea(x))\nall x. (CreepyHauntedHouse(x) -> MansionHouse(x))\nall x. (TerrifyingBuilding(x) & OnHalloween(x) -> CreepyHauntedHouse(x))\nCreepyHauntedHouse(LaLaurieHouse) | TerrifyingBuilding(LaLaurieHouse) & OnHalloween(LaLaurieHouse)"
        ],
        "conclusion": "The LaLaurie House is not a skyscraper.",
        "conclusion-FOL": "-Skyscraper(LaLaurieHouse)",
        "label": "ERROR"
    },
    {
        "premises": "There are no mansion houses in an urban area.\nAll skyscrapers are in urban areas.\nEvery creepy haunted house is a mansion house.\nEvery terrifying building on Halloween is a creepy haunted house.\nThe LaLaurie House is a creepy haunted house or a terrifying building on Halloween.",
        "premises-FOL": [
            "all x. (InUrbanArea(x) -> -MansionHouse(x))\nall x. (Skyscraper(x) -> InUrbanArea(x))\nall x. (CreepyHauntedHouse(x) -> MansionHouse(x))\nall x. (TerrifyingBuilding(x) & OnHalloween(x) -> CreepyHauntedHouse(x))\nCreepyHauntedHouse(LaLaurieHouse) | TerrifyingBuilding(LaLaurieHouse) & OnHalloween(LaLaurieHouse)"
        ],
        "conclusion": "The LaLaurie House is a terrifying building on Halloween.",
        "conclusion-FOL": "TerrifyingBuilding(LaLaurieHouse) & OnHalloween(LaLaurieHouse)",
        "label": "ERROR"
    },
    {
        "premises": "There are no mansion houses in an urban area.\nAll skyscrapers are in urban areas.\nEvery creepy haunted house is a mansion house.\nEvery terrifying building on Halloween is a creepy haunted house.\nThe LaLaurie House is a creepy haunted house or a terrifying building on Halloween.",
        "premises-FOL": [
            "all x. (InUrbanArea(x) -> -MansionHouse(x))\nall x. (Skyscraper(x) -> InUrbanArea(x))\nall x. (CreepyHauntedHouse(x) -> MansionHouse(x))\nall x. (TerrifyingBuilding(x) & OnHalloween(x) -> CreepyHauntedHouse(x))\nCreepyHauntedHouse(LaLaurieHouse) | TerrifyingBuilding(LaLaurieHouse) & OnHalloween(LaLaurieHouse)"
        ],
        "conclusion": "The LaLaurie House is either a skyscraper or a mansion house.",
        "conclusion-FOL": "((Skyscraper(LaLaurieHouse) & -MansionHouse(LaLaurieHouse)) | (-Skyscraper(LaLaurieHouse) & MansionHouse(LaLaurieHouse)))",
        "label": "ERROR"
    },
    {
        "premises": "There are no mansion houses in an urban area.\nAll skyscrapers are in urban areas.\nEvery creepy haunted house is a mansion house.\nEvery terrifying building on Halloween is a creepy haunted house.\nThe LaLaurie House is a creepy haunted house or a terrifying building on Halloween.",
        "premises-FOL": [
            "all x. (InUrbanArea(x) -> -MansionHouse(x))\nall x. (Skyscraper(x) -> InUrbanArea(x))\nall x. (CreepyHauntedHouse(x) -> MansionHouse(x))\nall x. (TerrifyingBuilding(x) & OnHalloween(x) -> CreepyHauntedHouse(x))\nCreepyHauntedHouse(LaLaurieHouse) | TerrifyingBuilding(LaLaurieHouse) & OnHalloween(LaLaurieHouse)"
        ],
        "conclusion": "The LaLaurie House is either a skyscraper or in an urban area.",
        "conclusion-FOL": "((Skyscraper(LaLaurieHouse) & -UrbanArea(LaLaurieHouse)) | (-Skyscraper(LaLaurieHouse) & UrbanArea(LaLaurieHouse)))",
        "label": "ERROR"
    },
    {
        "premises": "There are no mansion houses in an urban area.\nAll skyscrapers are in urban areas.\nEvery creepy haunted house is a mansion house.\nEvery terrifying building on Halloween is a creepy haunted house.\nThe LaLaurie House is a creepy haunted house or a terrifying building on Halloween.",
        "premises-FOL": [
            "all x. (InUrbanArea(x) -> -MansionHouse(x))\nall x. (Skyscraper(x) -> InUrbanArea(x))\nall x. (CreepyHauntedHouse(x) -> MansionHouse(x))\nall x. (TerrifyingBuilding(x) & OnHalloween(x) -> CreepyHauntedHouse(x))\nCreepyHauntedHouse(LaLaurieHouse) | TerrifyingBuilding(LaLaurieHouse) & OnHalloween(LaLaurieHouse)"
        ],
        "conclusion": "The LaLaurie House is either a skyscraper or a creepy haunted house.",
        "conclusion-FOL": "((Skyscraper(LaLaurieHouse) & -CreepyHauntedHouse(LaLaurieHouse)) | (-Skyscraper(LaLaurieHouse) & CreepyHauntedHouse(LaLaurieHouse)))",
        "label": "ERROR"
    },
    {
        "premises": "There are no mansion houses in an urban area.\nAll skyscrapers are in urban areas.\nEvery creepy haunted house is a mansion house.\nEvery terrifying building on Halloween is a creepy haunted house.\nThe LaLaurie House is a creepy haunted house or a terrifying building on Halloween.",
        "premises-FOL": [
            "all x. (InUrbanArea(x) -> -MansionHouse(x))\nall x. (Skyscraper(x) -> InUrbanArea(x))\nall x. (CreepyHauntedHouse(x) -> MansionHouse(x))\nall x. (TerrifyingBuilding(x) & OnHalloween(x) -> CreepyHauntedHouse(x))\nCreepyHauntedHouse(LaLaurieHouse) | TerrifyingBuilding(LaLaurieHouse) & OnHalloween(LaLaurieHouse)"
        ],
        "conclusion": "If the LaLaurie House is not a mansion or not in an urban area, then it is either a skyscraper or in an urban area.",
        "conclusion-FOL": "-(MansionHouse(LaLaurieHouse) & InUrbanArea(LaLaurieHouse)) -> (((Skyscraper(LaLaurieHouse) & -InUrbanArea(LaLaurieHouse)) | (-Skyscraper(LaLaurieHouse) & InUrbanArea(LaLaurieHouse))))",
        "label": "ERROR"
    },
    {
        "premises": "There are no mansion houses in an urban area.\nAll skyscrapers are in urban areas.\nEvery creepy haunted house is a mansion house.\nEvery terrifying building on Halloween is a creepy haunted house.\nThe LaLaurie House is a creepy haunted house or a terrifying building on Halloween.",
        "premises-FOL": [
            "all x. (InUrbanArea(x) -> -MansionHouse(x))\nall x. (Skyscraper(x) -> InUrbanArea(x))\nall x. (CreepyHauntedHouse(x) -> MansionHouse(x))\nall x. (TerrifyingBuilding(x) & OnHalloween(x) -> CreepyHauntedHouse(x))\nCreepyHauntedHouse(LaLaurieHouse) | TerrifyingBuilding(LaLaurieHouse) & OnHalloween(LaLaurieHouse)"
        ],
        "conclusion": "If the LaLaurie House is either a skyscraper or a mansion house, then it is in an urban area.",
        "conclusion-FOL": "((Skyscraper(LaLaurieHouse) & -MansionHouse(LaLaurieHouse)) | (-Skyscraper(LaLaurieHouse) & MansionHouse(LaLaurieHouse))) -> InUrbanArea(LaLaurieHouse)",
        "label": "ERROR"
    },
    {
        "premises": "There are no mansion houses in an urban area.\nAll skyscrapers are in urban areas.\nEvery creepy haunted house is a mansion house.\nEvery terrifying building on Halloween is a creepy haunted house.\nThe LaLaurie House is a creepy haunted house or a terrifying building on Halloween.",
        "premises-FOL": [
            "all x. (InUrbanArea(x) -> -MansionHouse(x))\nall x. (Skyscraper(x) -> InUrbanArea(x))\nall x. (CreepyHauntedHouse(x) -> MansionHouse(x))\nall x. (TerrifyingBuilding(x) & OnHalloween(x) -> CreepyHauntedHouse(x))\nCreepyHauntedHouse(LaLaurieHouse) | TerrifyingBuilding(LaLaurieHouse) & OnHalloween(LaLaurieHouse)"
        ],
        "conclusion": "If the LaLaurie House is either a skyscraper or a mansion house, then it is neither a creepy haunted house nor a terrifying building on Halloween.",
        "conclusion-FOL": "((Skyscraper(LaLaurieHouse) & -MansionHouse(LaLaurieHouse)) | (-Skyscraper(LaLaurieHouse) & MansionHouse(LaLaurieHouse))) -> -(CreepyHauntedHouse(LaLaurieHouse) | TerrifyingBuilding(LaLaurieHouse) & OnHalloween(LaLaurieHouse))",
        "label": "ERROR"
    },
    {
        "premises": "There are no mansion houses in an urban area.\nAll skyscrapers are in urban areas.\nEvery creepy haunted house is a mansion house.\nEvery terrifying building on Halloween is a creepy haunted house.\nThe LaLaurie House is a creepy haunted house or a terrifying building on Halloween.",
        "premises-FOL": [
            "all x. (InUrbanArea(x) -> -MansionHouse(x))\nall x. (Skyscraper(x) -> InUrbanArea(x))\nall x. (CreepyHauntedHouse(x) -> MansionHouse(x))\nall x. (TerrifyingBuilding(x) & OnHalloween(x) -> CreepyHauntedHouse(x))\nCreepyHauntedHouse(LaLaurieHouse) | TerrifyingBuilding(LaLaurieHouse) & OnHalloween(LaLaurieHouse)"
        ],
        "conclusion": "If the LaLaurie House is either a skyscraper or a creepy haunted house, then it is not a mansion house.",
        "conclusion-FOL": "((Skyscraper(LaLaurieHouse) & -CreepyHauntedHouse(LaLaurieHouse)) | (-Skyscraper(LaLaurieHouse) & CreepyHauntedHouse(LaLaurieHouse))) -> -MansionHouse(LaLaurieHouse)",
        "label": "ERROR"
    },
    {
        "premises": "Phuoc Binh national park is a national park in Vietnam. \nAny national park in Vietnam is classified as a nature reserve. \nThere is a national park in Vietnam classified as a UNESCO World Heritage Site.\nAll national parks in Vietnam are either managed by the Ministry of Agriculture or managed by the People's Committee. \nPhuoc Binh is not managed by the Ministry of Agriculture.",
        "premises-FOL": [
            "NationalPark(PhuocBinh) & Locatedin(PhuocBinh, Vietnam)\nall x. ((NationalPark(x) & Locatedin(x, Vietnam)) -> NatureReserve(x))\nexists x. (NationalPark(x) & Locatedin(x, Vietnam) & UNESCOWorldHeritageSite(x))\nall x. ((NationalPark(x) & Locatedin(x, Vietnam)) -> (((Mangedby(x, MinistryofAgriculture) & -Managedby(x, PeoplesCommittee)) | (-Mangedby(x, MinistryofAgriculture) & Managedby(x, PeoplesCommittee)))))\n-Mangedby(PhuocBinh, MinistryofAgriculture)"
        ],
        "conclusion": "There is a nature reserve in Vietnam.",
        "conclusion-FOL": "exists x. (NatureReserve(x) & LocatedIn(x, Vietnam))",
        "label": "ERROR"
    },
    {
        "premises": "Phuoc Binh national park is a national park in Vietnam. \nAny national park in Vietnam is classified as a nature reserve. \nThere is a national park in Vietnam classified as a UNESCO World Heritage Site.\nAll national parks in Vietnam are either managed by the Ministry of Agriculture or managed by the People's Committee. \nPhuoc Binh is not managed by the Ministry of Agriculture.",
        "premises-FOL": [
            "NationalPark(PhuocBinh) & Locatedin(PhuocBinh, Vietnam)\nall x. ((NationalPark(x) & Locatedin(x, Vietnam)) -> NatureReserve(x))\nexists x. (NationalPark(x) & Locatedin(x, Vietnam) & UNESCOWorldHeritageSite(x))\nall x. ((NationalPark(x) & Locatedin(x, Vietnam)) -> (((Mangedby(x, MinistryofAgriculture) & -Managedby(x, PeoplesCommittee)) | (-Mangedby(x, MinistryofAgriculture) & Managedby(x, PeoplesCommittee)))))\n-Mangedby(PhuocBinh, MinistryofAgriculture)"
        ],
        "conclusion": "Phuoc Binh is a UNESCO Heritage Site.",
        "conclusion-FOL": "UNESCOWorldHeritageSite(PhuocBinh))",
        "label": "ERROR"
    },
    {
        "premises": "Phuoc Binh national park is a national park in Vietnam. \nAny national park in Vietnam is classified as a nature reserve. \nThere is a national park in Vietnam classified as a UNESCO World Heritage Site.\nAll national parks in Vietnam are either managed by the Ministry of Agriculture or managed by the People's Committee. \nPhuoc Binh is not managed by the Ministry of Agriculture.",
        "premises-FOL": [
            "NationalPark(PhuocBinh) & Locatedin(PhuocBinh, Vietnam)\nall x. ((NationalPark(x) & Locatedin(x, Vietnam)) -> NatureReserve(x))\nexists x. (NationalPark(x) & Locatedin(x, Vietnam) & UNESCOWorldHeritageSite(x))\nall x. ((NationalPark(x) & Locatedin(x, Vietnam)) -> (((Mangedby(x, MinistryofAgriculture) & -Managedby(x, PeoplesCommittee)) | (-Mangedby(x, MinistryofAgriculture) & Managedby(x, PeoplesCommittee)))))\n-Mangedby(PhuocBinh, MinistryofAgriculture)"
        ],
        "conclusion": "Phuoc Binh is managed by the People's Committee.",
        "conclusion-FOL": "Mangedby(PhuocBinh, PeoplesCommittee)",
        "label": "ERROR"
    },
    {
        "premises": "Greyhound racing is a competitive sport where spectators bet on greyhounds.\nGreyhound racing involves coursing.\nSome competitive sports where spectators bet on things are banned.\nCoursing involves spectators betting on a hare being pursued by greyhounds.\nSpectators betting on a hare is a small game.\nIf a competitive sport involves spectators betting on small games, then it is banned.",
        "premises-FOL": [
            "all x. (GreyhoundRacing(x) -> exists y. (CompetitiveSport(x) & Greyhound(y) & BetOn(Spectators, y, x)))\nall x. (GreyhoundRacing(x) -> Coursing(x))\nexists x. exists y. (CompetitiveSport(x) & BetOn(Spectators, y, x) & Banned(x))\nall x. exists y. exists z. (Coursing(x) -> Hare(y) & BetOn(Spectators, y, x) & GreyHound(z) & PursuedBy(y, z))\nexists x. all y. (Hare(x) & BetOn(Spectators, x, y) -> SmallGame(y))\nall x. exists y. (CompetitiveSport(x) & SmallGame(y) & BetOn(Spectators, y, x) -> Banned(x))"
        ],
        "conclusion": "No coursing is banned.",
        "conclusion-FOL": "all x. (Coursing(x) & -Banned(x))",
        "label": "ERROR"
    },
    {
        "premises": "Greyhound racing is a competitive sport where spectators bet on greyhounds.\nGreyhound racing involves coursing.\nSome competitive sports where spectators bet on things are banned.\nCoursing involves spectators betting on a hare being pursued by greyhounds.\nSpectators betting on a hare is a small game.\nIf a competitive sport involves spectators betting on small games, then it is banned.",
        "premises-FOL": [
            "all x. (GreyhoundRacing(x) -> exists y. (CompetitiveSport(x) & Greyhound(y) & BetOn(Spectators, y, x)))\nall x. (GreyhoundRacing(x) -> Coursing(x))\nexists x. exists y. (CompetitiveSport(x) & BetOn(Spectators, y, x) & Banned(x))\nall x. exists y. exists z. (Coursing(x) -> Hare(y) & BetOn(Spectators, y, x) & GreyHound(z) & PursuedBy(y, z))\nexists x. all y. (Hare(x) & BetOn(Spectators, x, y) -> SmallGame(y))\nall x. exists y. (CompetitiveSport(x) & SmallGame(y) & BetOn(Spectators, y, x) -> Banned(x))"
        ],
        "conclusion": "Greyhound racing is a competitive sport.",
        "conclusion-FOL": "all x. (GreyhoundRacing(x) -> CompetitiveSport(x))",
        "label": "ERROR"
    },
    {
        "premises": "If a soccer player receives two yellow cards in one game, this player will be ejected from the rest of the game.\nIf a soccer player receives one red card in one game, this player will be ejected from the rest of the game.\nHenry is a soccer player.\nIn one game, Henry receives one yellow card and one red card.",
        "premises-FOL": [
            "all x. (SoccerPlayer(x) & Receive(x, TwoYellowCard) -> EjectFromRestOfGame(x))\nall x. (SoccerPlayer(x) & Receive(x, OneRedCard)) -> EjectFromRestOfGame(x))   \nSoccerPlayer(Henry)\nReceive(Henry, OneYellowCard) & Receive(x, OneRedCard)"
        ],
        "conclusion": "Henry will be ejected from the rest of the game.",
        "conclusion-FOL": "EjectFromRestOfGame(Henry)",
        "label": "ERROR"
    },
    {
        "premises": "If a soccer player receives two yellow cards in one game, this player will be ejected from the rest of the game.\nIf a soccer player receives one red card in one game, this player will be ejected from the rest of the game.\nHenry is a soccer player.\nIn one game, Henry receives one yellow card and one red card.",
        "premises-FOL": [
            "all x. (SoccerPlayer(x) & Receive(x, TwoYellowCard) -> EjectFromRestOfGame(x))\nall x. (SoccerPlayer(x) & Receive(x, OneRedCard)) -> EjectFromRestOfGame(x))   \nSoccerPlayer(Henry)\nReceive(Henry, OneYellowCard) & Receive(x, OneRedCard)"
        ],
        "conclusion": "Henry will not be ejected from the rest of the game.",
        "conclusion-FOL": "-EjectFromRestOfGame(Henry)",
        "label": "ERROR"
    },
    {
        "premises": "Trees are plants. \nSome living things are trees.",
        "premises-FOL": [
            "all x. (Tree(x) -> Plant(x))\nexists x. exists y. (Living(x) & Living(y) & Tree(x) & Tree(y) & -(x=y))"
        ],
        "conclusion": "Some living things are plants.",
        "conclusion-FOL": "exists x. exists y. (Living(x) & Living(y) & Plant(x) & Plant(y) & -(x=y))",
        "label": "ERROR"
    },
    {
        "premises": "Notable people with the given name include Dagfinn Aarskog, Dagfinn Bakke and Dagfinn Dahl.\nDagfinn Aarskog is a Norwegian physician.\nDagfinn Dahl is a Norwegian barrister.",
        "premises-FOL": [
            "\nGivenName(NameDagfinn) & Named(DagfinnAarskog, NameDagfinn) & NotablePerson(DagfinnAarskog) & Named(DagfinnBakke, NameDagfinn) & NotablePerson(DagfinnBakke)  & Named(DagfinnDahl, NameDagfinn) & NotablePerson(DagfinnDahl)\nNorwegian(DagfinnAarskog) & Physician(DagfinnAarskog)\nNorwegian(DagfinnDahl) & Barrister(DagfinnDahl)"
        ],
        "conclusion": "Dagfinn Aarskog is a notable person.",
        "conclusion-FOL": "NotablePerson(DagfinnAarskog)",
        "label": "ERROR"
    },
    {
        "premises": "Notable people with the given name include Dagfinn Aarskog, Dagfinn Bakke and Dagfinn Dahl.\nDagfinn Aarskog is a Norwegian physician.\nDagfinn Dahl is a Norwegian barrister.",
        "premises-FOL": [
            "\nGivenName(NameDagfinn) & Named(DagfinnAarskog, NameDagfinn) & NotablePerson(DagfinnAarskog) & Named(DagfinnBakke, NameDagfinn) & NotablePerson(DagfinnBakke)  & Named(DagfinnDahl, NameDagfinn) & NotablePerson(DagfinnDahl)\nNorwegian(DagfinnAarskog) & Physician(DagfinnAarskog)\nNorwegian(DagfinnDahl) & Barrister(DagfinnDahl)"
        ],
        "conclusion": "Dagfinn is Dagfinn Aarskog's given name.",
        "conclusion-FOL": "Named(DagfinnAarskog, NameDagfinn)",
        "label": "ERROR"
    },
    {
        "premises": "Notable people with the given name include Dagfinn Aarskog, Dagfinn Bakke and Dagfinn Dahl.\nDagfinn Aarskog is a Norwegian physician.\nDagfinn Dahl is a Norwegian barrister.",
        "premises-FOL": [
            "\nGivenName(NameDagfinn) & Named(DagfinnAarskog, NameDagfinn) & NotablePerson(DagfinnAarskog) & Named(DagfinnBakke, NameDagfinn) & NotablePerson(DagfinnBakke)  & Named(DagfinnDahl, NameDagfinn) & NotablePerson(DagfinnDahl)\nNorwegian(DagfinnAarskog) & Physician(DagfinnAarskog)\nNorwegian(DagfinnDahl) & Barrister(DagfinnDahl)"
        ],
        "conclusion": "Dagfinn Dahl is a Norwegian physician.",
        "conclusion-FOL": "Norwegian(DagfinnDahl) & Physician(DagfinnDahl)",
        "label": "ERROR"
    },
    {
        "premises": "If a movie is popular, some people enjoy watching it.\nAll things that some people enjoy attract attention.",
        "premises-FOL": [
            "all x. (Movie(x) & Popular(x) -> exists y. exists z. (Person(y) & EnjoyWatching(y, x) & Person(z) & EnjoyWatching(z, x) & -(y=z)))\nall x. (exists y. exists z. (Person(y) & EnjoyWatching(y, x) & Person(z) & EnjoyWatching(z, x)) -> Attract(x, Attention))"
        ],
        "conclusion": "If a movie is popular, then it attracts attention.",
        "conclusion-FOL": "all x. (Movie(x) & Popular(x) -> Attract(x, Attention))",
        "label": "ERROR"
    },
    {
        "premises": "It is not true that some giant language models do not have good performance. \nAll language models with good performance are used by some researchers.\nIf a language model is used by some researchers, it is popular. \nIf BERT is a giant language model, then GPT-3 is also a giant language model. \nBERT is a giant language model. ",
        "premises-FOL": [
            "-(exists x. (LanguageModel(x) & Giant(x) & -GoodPerformance(x)))\nall x. exists y. exists z. (LanguageModel(x) & GoodPerformance(x) -> -(x=y) & Researcher(y) & UsedBy(x, y) & Researcher(z) & UsedBy(x, z))\nall x. exists y. exists z. (LanguageModel(x) & -(x=y) & Researcher(y) & UsedBy(x, y) & Researcher(z) & UsedBy(x, z) -> Popular(x))\n(LanguageModel(Bert) & Giant(Bert)) -> (LanguageModel(Gpt-Three) & Giant(Gpt-Three))Dot\nLanguageModel(Bert) & Giant(Bert)"
        ],
        "conclusion": "GPT-3 is popular.",
        "conclusion-FOL": "Popular(Gpt-Three)",
        "label": "ERROR"
    },
    {
        "premises": "St Johnstone is a Scottish team.\nSt Johnstone is part of the Scottish Premiership league.\nIf a team is part of the league, it has joined the league.\nSt Johnstone and Minsk are different teams.\nFor two teams, either one team wins, or the other team wins.\nMinsk won against St Johnstone.",
        "premises-FOL": [
            "Scottish(StJohnstone) & Team(StJohnstone)\nPartOf(StJohnstone, ScottishPremiership) & League(ScottishPremiership)\nall x. all y. (Team(x) & League(y) & PartOf(x, y) -> Joined(x, y))\n-(Misnk=StJohnstone)\nall x. all y. (-(x=y) -> ((WonAgainst(x, y) & -WonAgainst(y, x)) | (-WonAgainst(x, y) & WonAgainst(y, x))))\nWonAgainst(Minsk, StJohnstone)"
        ],
        "conclusion": "At least one Scottish team has joined the Scottish Premiership.",
        "conclusion-FOL": "exists x. (Scottish(x) & Joined(x, ScottishPremiership))",
        "label": "ERROR"
    },
    {
        "premises": "St Johnstone is a Scottish team.\nSt Johnstone is part of the Scottish Premiership league.\nIf a team is part of the league, it has joined the league.\nSt Johnstone and Minsk are different teams.\nFor two teams, either one team wins, or the other team wins.\nMinsk won against St Johnstone.",
        "premises-FOL": [
            "Scottish(StJohnstone) & Team(StJohnstone)\nPartOf(StJohnstone, ScottishPremiership) & League(ScottishPremiership)\nall x. all y. (Team(x) & League(y) & PartOf(x, y) -> Joined(x, y))\n-(Misnk=StJohnstone)\nall x. all y. (-(x=y) -> ((WonAgainst(x, y) & -WonAgainst(y, x)) | (-WonAgainst(x, y) & WonAgainst(y, x))))\nWonAgainst(Minsk, StJohnstone)"
        ],
        "conclusion": "St Johnstone won against Minsk.",
        "conclusion-FOL": "WonGame(StJohnstone, Minsk)",
        "label": "ERROR"
    },
    {
        "premises": "St Johnstone is a Scottish team.\nSt Johnstone is part of the Scottish Premiership league.\nIf a team is part of the league, it has joined the league.\nSt Johnstone and Minsk are different teams.\nFor two teams, either one team wins, or the other team wins.\nMinsk won against St Johnstone.",
        "premises-FOL": [
            "Scottish(StJohnstone) & Team(StJohnstone)\nPartOf(StJohnstone, ScottishPremiership) & League(ScottishPremiership)\nall x. all y. (Team(x) & League(y) & PartOf(x, y) -> Joined(x, y))\n-(Misnk=StJohnstone)\nall x. all y. (-(x=y) -> ((WonAgainst(x, y) & -WonAgainst(y, x)) | (-WonAgainst(x, y) & WonAgainst(y, x))))\nWonAgainst(Minsk, StJohnstone)"
        ],
        "conclusion": "Minsk joined the Scottish Premiership.",
        "conclusion-FOL": "Joined(Minsk, ScottishPremiership))",
        "label": "ERROR"
    },
    {
        "premises": "No Boeing-737 plane has more than 300 seats. \nAll of the planes acquired by Delta in this batch are Boeing-737. \nPlanes either have more than 300 seats or have a capacity of 100 passengers. \nAll planes with a capacity of 100 passengers are scheduled for a short-distance flight. \nAll planes with a capacity of 100 passengers are produced before 2010. \nJake32 is either a Boeing-737 plane or a plane acquired by Delta in this batch.\nT10 is either both a Boeing-737 plane and acquired by Delta in this batch, or it is neither.",
        "premises-FOL": [
            "all x. (Plane(x) & BoeingSevenThreeSeven(x) -> (-exists y.(GreaterThan(y, NumThreeZeroZero) & EquippedWithSeats(x,y)))\nall x. (Plane(x) & AcquiredBy(x, Delta) -> BoeingSevenThreeSeven(x))\nall x. (((Plane(x) -> ((exists y.(GreaterThan(y, NumThreeZeroZero) & EquippedWithSeats(x,y))) & -(exists y.(Equals(y, NumOneZeroZero) & EquippedWithSeats(x,y))) | (-(Plane(x) -> ((exists y.(GreaterThan(y, NumThreeZeroZero) & EquippedWithSeats(x,y))) & (exists y.(Equals(y, NumOneZeroZero) & EquippedWithSeats(x,y))))))\nall x. (Plane(x) & exists y.(Equals(y, NumOneZeroZero) & EquippedWithSeats(x,y)) -> ScheduledFor(x, Shortdistanceflight))\nall x. (Plane(x) & exists y.(Equals(y, NumOneZeroZero) & EquippedWithSeats(x,y)) -> exists z.(Before(z, YrTwoZeroOneZero) & Produced(x, z))\n(((BoeingSevenThreeSeven(JakeThreeTwo) & Plane(JakeThreeTwo)) & -(AcquiredByDeltaInThisBatch(JakeThreeTwo) & Plane(JakeThreeTwo))) | (-(BoeingSevenThreeSeven(JakeThreeTwo) & Plane(JakeThreeTwo)) & (AcquiredByDeltaInThisBatch(JakeThreeTwo) & Plane(JakeThreeTwo))))\n-((((BoeingSevenThreeSeven(tOneZero) & Plane(tOneZero)) & -(AcquiredByDeltaInThisBatch(tOneZero) & Plane(tOneZero))) | (-((BoeingSevenThreeSeven(tOneZero) & Plane(tOneZero)) & (AcquiredByDeltaInThisBatch(tOneZero) & Plane(tOneZero)))))"
        ],
        "conclusion": "Jake32 was produced before 2010 and is scheduled for a short-distance flight.",
        "conclusion-FOL": "exists z.(Before(z, YearTwoZeroOneZero) & Produced(JakeThreeTwo, z)) & ScheduledFor(JakeThreeTwo, Shortdistanceflight))",
        "label": "ERROR"
    },
    {
        "premises": "No Boeing-737 plane has more than 300 seats. \nAll of the planes acquired by Delta in this batch are Boeing-737. \nPlanes either have more than 300 seats or have a capacity of 100 passengers. \nAll planes with a capacity of 100 passengers are scheduled for a short-distance flight. \nAll planes with a capacity of 100 passengers are produced before 2010. \nJake32 is either a Boeing-737 plane or a plane acquired by Delta in this batch.\nT10 is either both a Boeing-737 plane and acquired by Delta in this batch, or it is neither.",
        "premises-FOL": [
            "all x. (Plane(x) & BoeingSevenThreeSeven(x) -> (-exists y.(GreaterThan(y, NumThreeZeroZero) & EquippedWithSeats(x,y)))\nall x. (Plane(x) & AcquiredBy(x, Delta) -> BoeingSevenThreeSeven(x))\nall x. (((Plane(x) -> ((exists y.(GreaterThan(y, NumThreeZeroZero) & EquippedWithSeats(x,y))) & -(exists y.(Equals(y, NumOneZeroZero) & EquippedWithSeats(x,y))) | (-(Plane(x) -> ((exists y.(GreaterThan(y, NumThreeZeroZero) & EquippedWithSeats(x,y))) & (exists y.(Equals(y, NumOneZeroZero) & EquippedWithSeats(x,y))))))\nall x. (Plane(x) & exists y.(Equals(y, NumOneZeroZero) & EquippedWithSeats(x,y)) -> ScheduledFor(x, Shortdistanceflight))\nall x. (Plane(x) & exists y.(Equals(y, NumOneZeroZero) & EquippedWithSeats(x,y)) -> exists z.(Before(z, YrTwoZeroOneZero) & Produced(x, z))\n(((BoeingSevenThreeSeven(JakeThreeTwo) & Plane(JakeThreeTwo)) & -(AcquiredByDeltaInThisBatch(JakeThreeTwo) & Plane(JakeThreeTwo))) | (-(BoeingSevenThreeSeven(JakeThreeTwo) & Plane(JakeThreeTwo)) & (AcquiredByDeltaInThisBatch(JakeThreeTwo) & Plane(JakeThreeTwo))))\n-((((BoeingSevenThreeSeven(tOneZero) & Plane(tOneZero)) & -(AcquiredByDeltaInThisBatch(tOneZero) & Plane(tOneZero))) | (-((BoeingSevenThreeSeven(tOneZero) & Plane(tOneZero)) & (AcquiredByDeltaInThisBatch(tOneZero) & Plane(tOneZero)))))"
        ],
        "conclusion": "Jake32 is not produced before 2010 and is not scheduled for a short-distance flight.",
        "conclusion-FOL": "-(exists z.(Before(z, YearTwoZeroOneZero) & Produced(JakeThreeTwo, z)) & ScheduledFor(JakeThreeTwo, Shortdistanceflight)))",
        "label": "ERROR"
    },
    {
        "premises": "No Boeing-737 plane has more than 300 seats. \nAll of the planes acquired by Delta in this batch are Boeing-737. \nPlanes either have more than 300 seats or have a capacity of 100 passengers. \nAll planes with a capacity of 100 passengers are scheduled for a short-distance flight. \nAll planes with a capacity of 100 passengers are produced before 2010. \nJake32 is either a Boeing-737 plane or a plane acquired by Delta in this batch.\nT10 is either both a Boeing-737 plane and acquired by Delta in this batch, or it is neither.",
        "premises-FOL": [
            "all x. (Plane(x) & BoeingSevenThreeSeven(x) -> (-exists y.(GreaterThan(y, NumThreeZeroZero) & EquippedWithSeats(x,y)))\nall x. (Plane(x) & AcquiredBy(x, Delta) -> BoeingSevenThreeSeven(x))\nall x. (((Plane(x) -> ((exists y.(GreaterThan(y, NumThreeZeroZero) & EquippedWithSeats(x,y))) & -(exists y.(Equals(y, NumOneZeroZero) & EquippedWithSeats(x,y))) | (-(Plane(x) -> ((exists y.(GreaterThan(y, NumThreeZeroZero) & EquippedWithSeats(x,y))) & (exists y.(Equals(y, NumOneZeroZero) & EquippedWithSeats(x,y))))))\nall x. (Plane(x) & exists y.(Equals(y, NumOneZeroZero) & EquippedWithSeats(x,y)) -> ScheduledFor(x, Shortdistanceflight))\nall x. (Plane(x) & exists y.(Equals(y, NumOneZeroZero) & EquippedWithSeats(x,y)) -> exists z.(Before(z, YrTwoZeroOneZero) & Produced(x, z))\n(((BoeingSevenThreeSeven(JakeThreeTwo) & Plane(JakeThreeTwo)) & -(AcquiredByDeltaInThisBatch(JakeThreeTwo) & Plane(JakeThreeTwo))) | (-(BoeingSevenThreeSeven(JakeThreeTwo) & Plane(JakeThreeTwo)) & (AcquiredByDeltaInThisBatch(JakeThreeTwo) & Plane(JakeThreeTwo))))\n-((((BoeingSevenThreeSeven(tOneZero) & Plane(tOneZero)) & -(AcquiredByDeltaInThisBatch(tOneZero) & Plane(tOneZero))) | (-((BoeingSevenThreeSeven(tOneZero) & Plane(tOneZero)) & (AcquiredByDeltaInThisBatch(tOneZero) & Plane(tOneZero)))))"
        ],
        "conclusion": "Jake32 is produced before 2010 or scheduled for a short-distance flight.",
        "conclusion-FOL": "exists z.(Before(z, YearTwoZeroOneZero) & Produced(JakeThreeTwo, z)) | ScheduledFor(JakeThreeTwo, Shortdistanceflight))",
        "label": "ERROR"
    },
    {
        "premises": "No Boeing-737 plane has more than 300 seats. \nAll of the planes acquired by Delta in this batch are Boeing-737. \nPlanes either have more than 300 seats or have a capacity of 100 passengers. \nAll planes with a capacity of 100 passengers are scheduled for a short-distance flight. \nAll planes with a capacity of 100 passengers are produced before 2010. \nJake32 is either a Boeing-737 plane or a plane acquired by Delta in this batch.\nT10 is either both a Boeing-737 plane and acquired by Delta in this batch, or it is neither.",
        "premises-FOL": [
            "all x. (Plane(x) & BoeingSevenThreeSeven(x) -> (-exists y.(GreaterThan(y, NumThreeZeroZero) & EquippedWithSeats(x,y)))\nall x. (Plane(x) & AcquiredBy(x, Delta) -> BoeingSevenThreeSeven(x))\nall x. (((Plane(x) -> ((exists y.(GreaterThan(y, NumThreeZeroZero) & EquippedWithSeats(x,y))) & -(exists y.(Equals(y, NumOneZeroZero) & EquippedWithSeats(x,y))) | (-(Plane(x) -> ((exists y.(GreaterThan(y, NumThreeZeroZero) & EquippedWithSeats(x,y))) & (exists y.(Equals(y, NumOneZeroZero) & EquippedWithSeats(x,y))))))\nall x. (Plane(x) & exists y.(Equals(y, NumOneZeroZero) & EquippedWithSeats(x,y)) -> ScheduledFor(x, Shortdistanceflight))\nall x. (Plane(x) & exists y.(Equals(y, NumOneZeroZero) & EquippedWithSeats(x,y)) -> exists z.(Before(z, YrTwoZeroOneZero) & Produced(x, z))\n(((BoeingSevenThreeSeven(JakeThreeTwo) & Plane(JakeThreeTwo)) & -(AcquiredByDeltaInThisBatch(JakeThreeTwo) & Plane(JakeThreeTwo))) | (-(BoeingSevenThreeSeven(JakeThreeTwo) & Plane(JakeThreeTwo)) & (AcquiredByDeltaInThisBatch(JakeThreeTwo) & Plane(JakeThreeTwo))))\n-((((BoeingSevenThreeSeven(tOneZero) & Plane(tOneZero)) & -(AcquiredByDeltaInThisBatch(tOneZero) & Plane(tOneZero))) | (-((BoeingSevenThreeSeven(tOneZero) & Plane(tOneZero)) & (AcquiredByDeltaInThisBatch(tOneZero) & Plane(tOneZero)))))"
        ],
        "conclusion": "Jake32 is neither produced before 2010 nor scheduled for a short-distance flight.",
        "conclusion-FOL": "-exists z.(Before(z, YearTwoZeroOneZero) & Produced(JakeThreeTwo, z)) & -ScheduledFor(JakeThreeTwo, Shortdistanceflight))",
        "label": "ERROR"
    },
    {
        "premises": "The SAT test is wholly owned and developed by the College Board.\nThe SAT test is intended to assess students' readiness for college.\nThe SAT was originally designed not to be aligned with high school curricula. \nSeveral adjustments were made to the version of the SAT introduced in 2016 to align with the high school curriculum.",
        "premises-FOL": [
            "OwnedBy(sAT, CollegeBoard) & DevelopedBy(sAT, CollegeBoard) & -(exists y. (-(y=CollegeBoard) & (OwnedBy(sAT, y) | DevelopedBy(sAT, y)))\nIntendedToAssess(sAT, StudentsReadinessForCollege)\nOriginallyDesignedToBeAlignedWith(sAT, HighSchoolCurricula)\nAdjustmentMadeIn(sAT, TwoZeroOneSix, ToAlignWithHighSchoolCurriculum)"
        ],
        "conclusion": "The SAT test is owned by the College Board and other third parties.",
        "conclusion-FOL": "OwnedBy(sAT, CollegeBoard) & OwnedBy(sAT, OtherThirdParties)",
        "label": "ERROR"
    },
    {
        "premises": "The SAT test is wholly owned and developed by the College Board.\nThe SAT test is intended to assess students' readiness for college.\nThe SAT was originally designed not to be aligned with high school curricula. \nSeveral adjustments were made to the version of the SAT introduced in 2016 to align with the high school curriculum.",
        "premises-FOL": [
            "OwnedBy(sAT, CollegeBoard) & DevelopedBy(sAT, CollegeBoard) & -(exists y. (-(y=CollegeBoard) & (OwnedBy(sAT, y) | DevelopedBy(sAT, y)))\nIntendedToAssess(sAT, StudentsReadinessForCollege)\nOriginallyDesignedToBeAlignedWith(sAT, HighSchoolCurricula)\nAdjustmentMadeIn(sAT, TwoZeroOneSix, ToAlignWithHighSchoolCurriculum)"
        ],
        "conclusion": "The SAT test assesses students' math skills.",
        "conclusion-FOL": "IntendedToAssess(sAT, StudentsMathSkill)",
        "label": "ERROR"
    },
    {
        "premises": "Rafa Nadal was born in Mallorca.\nRafa Nadal is a professional tennis player.\nNadal's win ratio is high.\nAll players in the Big 3 are professionals who have a high win ratio.",
        "premises-FOL": [
            "BornIn(RafaNadal, Mallorca)\nProfessionalTennisPlayer(RafaNadal)\nHighWinRatio(RafaNadal)\nall x. ((ProfessionalTennisPlayer(x) & HighWinRatio(x)) -> InBigThree(x))"
        ],
        "conclusion": "Nadal was not born in Mallorca.",
        "conclusion-FOL": "-BornIn(RafaNadal, Mallorca)",
        "label": "ERROR"
    },
    {
        "premises": "Rafa Nadal was born in Mallorca.\nRafa Nadal is a professional tennis player.\nNadal's win ratio is high.\nAll players in the Big 3 are professionals who have a high win ratio.",
        "premises-FOL": [
            "BornIn(RafaNadal, Mallorca)\nProfessionalTennisPlayer(RafaNadal)\nHighWinRatio(RafaNadal)\nall x. ((ProfessionalTennisPlayer(x) & HighWinRatio(x)) -> InBigThree(x))"
        ],
        "conclusion": "Nadal is in the Big 3.",
        "conclusion-FOL": "InBigThree(RafaNadal)",
        "label": "ERROR"
    },
    {
        "premises": "Rafa Nadal was born in Mallorca.\nRafa Nadal is a professional tennis player.\nNadal's win ratio is high.\nAll players in the Big 3 are professionals who have a high win ratio.",
        "premises-FOL": [
            "BornIn(RafaNadal, Mallorca)\nProfessionalTennisPlayer(RafaNadal)\nHighWinRatio(RafaNadal)\nall x. ((ProfessionalTennisPlayer(x) & HighWinRatio(x)) -> InBigThree(x))"
        ],
        "conclusion": "Nadal is the greatest player of all time.",
        "conclusion-FOL": "GreatestOfAllTime(RafaNadal)",
        "label": "ERROR"
    },
    {
        "premises": "No sandwich cookies are healthy.\nOreos are sandwich cookies.",
        "premises-FOL": [
            "all x. (SandwichCookie(x) -> -Healthy(x))\nall x. (Oreo(x) -> SandwichCookie(x))"
        ],
        "conclusion": "All sandwich cookies are delicious.",
        "conclusion-FOL": "all x. (SandwichCookie(x) -> Delicious(x))",
        "label": "ERROR"
    },
    {
        "premises": "No animals are plants.\nAll humans are animals.\nAll pupils are humans.\nAll flowers are plants.\nBailey is either both a human and a flower or neither a human nor a flower.",
        "premises-FOL": [
            "all x. (Animal(x) -> -Plant(x))\nall x. (Human(x) -> Animal(x))\nall x. (Pupil(x) -> Human(x))\nall x. (Flower(x) -> Plant(x))\n-(((Human(Bailey) & -Flower(Bailey)) | (-Human(Bailey) & Flower(Bailey))))"
        ],
        "conclusion": "Bailey is a pupil.",
        "conclusion-FOL": "Pupil(Bailey)",
        "label": "ERROR"
    },
    {
        "premises": "No animals are plants.\nAll humans are animals.\nAll pupils are humans.\nAll flowers are plants.\nBailey is either both a human and a flower or neither a human nor a flower.",
        "premises-FOL": [
            "all x. (Animal(x) -> -Plant(x))\nall x. (Human(x) -> Animal(x))\nall x. (Pupil(x) -> Human(x))\nall x. (Flower(x) -> Plant(x))\n-(((Human(Bailey) & -Flower(Bailey)) | (-Human(Bailey) & Flower(Bailey))))"
        ],
        "conclusion": "Bailey is not a pupil.",
        "conclusion-FOL": "-Pupil(Bailey)",
        "label": "ERROR"
    },
    {
        "premises": "No animals are plants.\nAll humans are animals.\nAll pupils are humans.\nAll flowers are plants.\nBailey is either both a human and a flower or neither a human nor a flower.",
        "premises-FOL": [
            "all x. (Animal(x) -> -Plant(x))\nall x. (Human(x) -> Animal(x))\nall x. (Pupil(x) -> Human(x))\nall x. (Flower(x) -> Plant(x))\n-(((Human(Bailey) & -Flower(Bailey)) | (-Human(Bailey) & Flower(Bailey))))"
        ],
        "conclusion": "Bailey is a plant.",
        "conclusion-FOL": "Plant(Bailey)",
        "label": "ERROR"
    },
    {
        "premises": "No animals are plants.\nAll humans are animals.\nAll pupils are humans.\nAll flowers are plants.\nBailey is either both a human and a flower or neither a human nor a flower.",
        "premises-FOL": [
            "all x. (Animal(x) -> -Plant(x))\nall x. (Human(x) -> Animal(x))\nall x. (Pupil(x) -> Human(x))\nall x. (Flower(x) -> Plant(x))\n-(((Human(Bailey) & -Flower(Bailey)) | (-Human(Bailey) & Flower(Bailey))))"
        ],
        "conclusion": "If Bailey is a human, then Bailey is not a pupil.",
        "conclusion-FOL": "Human(Bailey) -> -Pupil(Bailey)",
        "label": "ERROR"
    },
    {
        "premises": "Shoes are not food.\nAll slippers are shoes.\nAny object donated to the homeless charity is either clothes or food.\nWearable things are not edible.\nAll clothes are wearable. \nThe watch is donated to the homeless charify.\nIf the watch is not both edible and a piece of clothing, then the watch is either both edible and a piece of clothing or the watch is neither of them.",
        "premises-FOL": [
            "all x. (Shoe(x) -> -Food(x))\nall x. (Slipper(x) -> Shoe(x))\nall x. (DonatedTo(x, HomelessCharity) -> ((Food(x) & -Clothes(x)) | (-Food(x) & Clothes(x))))\nall x. (Wearable(x) -> -Edible(x))\nall x. (Clothes(x) -> Wearable(x))\nDonatedTo(Watch, HomelessCharify)\n-(Edible(Watch) & Clothes(Watch)) -> -(((Edible(Watch) & -Clothes(Watch)) | (-Edible(Watch) & Clothes(Watch))))"
        ],
        "conclusion": "A watch is wearable.",
        "conclusion-FOL": "Wearable(Watch)",
        "label": "ERROR"
    },
    {
        "premises": "Shoes are not food.\nAll slippers are shoes.\nAny object donated to the homeless charity is either clothes or food.\nWearable things are not edible.\nAll clothes are wearable. \nThe watch is donated to the homeless charify.\nIf the watch is not both edible and a piece of clothing, then the watch is either both edible and a piece of clothing or the watch is neither of them.",
        "premises-FOL": [
            "all x. (Shoe(x) -> -Food(x))\nall x. (Slipper(x) -> Shoe(x))\nall x. (DonatedTo(x, HomelessCharity) -> ((Food(x) & -Clothes(x)) | (-Food(x) & Clothes(x))))\nall x. (Wearable(x) -> -Edible(x))\nall x. (Clothes(x) -> Wearable(x))\nDonatedTo(Watch, HomelessCharify)\n-(Edible(Watch) & Clothes(Watch)) -> -(((Edible(Watch) & -Clothes(Watch)) | (-Edible(Watch) & Clothes(Watch))))"
        ],
        "conclusion": "A watch is a slipper.",
        "conclusion-FOL": "Slipper(Watch)",
        "label": "ERROR"
    },
    {
        "premises": "Shoes are not food.\nAll slippers are shoes.\nAny object donated to the homeless charity is either clothes or food.\nWearable things are not edible.\nAll clothes are wearable. \nThe watch is donated to the homeless charify.\nIf the watch is not both edible and a piece of clothing, then the watch is either both edible and a piece of clothing or the watch is neither of them.",
        "premises-FOL": [
            "all x. (Shoe(x) -> -Food(x))\nall x. (Slipper(x) -> Shoe(x))\nall x. (DonatedTo(x, HomelessCharity) -> ((Food(x) & -Clothes(x)) | (-Food(x) & Clothes(x))))\nall x. (Wearable(x) -> -Edible(x))\nall x. (Clothes(x) -> Wearable(x))\nDonatedTo(Watch, HomelessCharify)\n-(Edible(Watch) & Clothes(Watch)) -> -(((Edible(Watch) & -Clothes(Watch)) | (-Edible(Watch) & Clothes(Watch))))"
        ],
        "conclusion": "A watch is neither edible nor a slipper.",
        "conclusion-FOL": "-Edible(Watch) & -Slipper(Watch)",
        "label": "ERROR"
    },
    {
        "premises": "An Olympian is a person who trains for an Olympic sport and goes to the Olympics.\nCarlos Reyes trains for an Olympic sport.\nCarlos Reyes went to the Olympics.\nCarlos Reyes is a welterweight.\nHeavy weights are not welterweights.",
        "premises-FOL": [
            "all x. ((DoesOlympicSport(x) & GoesToOlympicGames(x)) -> Olympian(x))\nDoesOlympicSport(CarlosReyes)\nGoesToOlympicGames(CarlosReyes)\nWelterWeight(CarlosReyes)\nall x. (WelterWeight(x) -> - HeavyWeight(x))"
        ],
        "conclusion": "Carlos Reyes is an Olympian.",
        "conclusion-FOL": "Olympian(CarlosReyes)",
        "label": "ERROR"
    },
    {
        "premises": "An Olympian is a person who trains for an Olympic sport and goes to the Olympics.\nCarlos Reyes trains for an Olympic sport.\nCarlos Reyes went to the Olympics.\nCarlos Reyes is a welterweight.\nHeavy weights are not welterweights.",
        "premises-FOL": [
            "all x. ((DoesOlympicSport(x) & GoesToOlympicGames(x)) -> Olympian(x))\nDoesOlympicSport(CarlosReyes)\nGoesToOlympicGames(CarlosReyes)\nWelterWeight(CarlosReyes)\nall x. (WelterWeight(x) -> - HeavyWeight(x))"
        ],
        "conclusion": "Carlos Reyes is a heavy weight.",
        "conclusion-FOL": "HeavyWeight(CarlosReyes)",
        "label": "ERROR"
    },
    {
        "premises": "An Olympian is a person who trains for an Olympic sport and goes to the Olympics.\nCarlos Reyes trains for an Olympic sport.\nCarlos Reyes went to the Olympics.\nCarlos Reyes is a welterweight.\nHeavy weights are not welterweights.",
        "premises-FOL": [
            "all x. ((DoesOlympicSport(x) & GoesToOlympicGames(x)) -> Olympian(x))\nDoesOlympicSport(CarlosReyes)\nGoesToOlympicGames(CarlosReyes)\nWelterWeight(CarlosReyes)\nall x. (WelterWeight(x) -> - HeavyWeight(x))"
        ],
        "conclusion": "Carlos Reyes won an Olympic medal.",
        "conclusion-FOL": "WonOlympicMedal(CarlosReyes)",
        "label": "ERROR"
    },
    {
        "premises": "If people have a lot of music decorations in their rooms, they cannot pack and move out of their rooms very easily.\nIf people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.\nIf people are big fans of pop bands and singers, then they have a lot of music decorations in their room.\nAll young teenage girls who attend music festival frequently are big fans of pop bands and singers.\nIf Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
        "premises-FOL": [
            "all x. (HaveIn(x, aLotOfMusicDecoration, Room) -> -MoveOutEasily(x))\nall x. (Ambitious(x) -> MoveOutEasily(x))\nall x. (BigFanOfMusic(x) -> MusicDecorations(x, Room))\nall x. (AttendFrequently(x, MusicFestival) & YoungTeenageGirl(x) -> BigFanOfPopBand(x) & BigFanOfPopSinger(x))\nAmbitious(Sam) -> BBigFanOfPopBand(Sam) & BigFanOfPopSinger(Sam)"
        ],
        "conclusion": "Sam is a young teenage girl who attends music festival frequently",
        "conclusion-FOL": "Attend(Sam, Festival) & YoungTeenageGirl(Sam)",
        "label": "ERROR"
    },
    {
        "premises": "If people have a lot of music decorations in their rooms, they cannot pack and move out of their rooms very easily.\nIf people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.\nIf people are big fans of pop bands and singers, then they have a lot of music decorations in their room.\nAll young teenage girls who attend music festival frequently are big fans of pop bands and singers.\nIf Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
        "premises-FOL": [
            "all x. (HaveIn(x, aLotOfMusicDecoration, Room) -> -MoveOutEasily(x))\nall x. (Ambitious(x) -> MoveOutEasily(x))\nall x. (BigFanOfMusic(x) -> MusicDecorations(x, Room))\nall x. (AttendFrequently(x, MusicFestival) & YoungTeenageGirl(x) -> BigFanOfPopBand(x) & BigFanOfPopSinger(x))\nAmbitious(Sam) -> BBigFanOfPopBand(Sam) & BigFanOfPopSinger(Sam)"
        ],
        "conclusion": "Sam is not a young teenage girl who attends music festival frequently",
        "conclusion-FOL": "-(Attend(Sam, Festival) & YoungTeenageGirl(Sam))",
        "label": "ERROR"
    },
    {
        "premises": "If people have a lot of music decorations in their rooms, they cannot pack and move out of their rooms very easily.\nIf people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.\nIf people are big fans of pop bands and singers, then they have a lot of music decorations in their room.\nAll young teenage girls who attend music festival frequently are big fans of pop bands and singers.\nIf Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
        "premises-FOL": [
            "all x. (HaveIn(x, aLotOfMusicDecoration, Room) -> -MoveOutEasily(x))\nall x. (Ambitious(x) -> MoveOutEasily(x))\nall x. (BigFanOfMusic(x) -> MusicDecorations(x, Room))\nall x. (AttendFrequently(x, MusicFestival) & YoungTeenageGirl(x) -> BigFanOfPopBand(x) & BigFanOfPopSinger(x))\nAmbitious(Sam) -> BBigFanOfPopBand(Sam) & BigFanOfPopSinger(Sam)"
        ],
        "conclusion": "Sam is a big fan of pop bands and singers.",
        "conclusion-FOL": "BigFanOfMusic(Sam)",
        "label": "ERROR"
    },
    {
        "premises": "If people have a lot of music decorations in their rooms, they cannot pack and move out of their rooms very easily.\nIf people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.\nIf people are big fans of pop bands and singers, then they have a lot of music decorations in their room.\nAll young teenage girls who attend music festival frequently are big fans of pop bands and singers.\nIf Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
        "premises-FOL": [
            "all x. (HaveIn(x, aLotOfMusicDecoration, Room) -> -MoveOutEasily(x))\nall x. (Ambitious(x) -> MoveOutEasily(x))\nall x. (BigFanOfMusic(x) -> MusicDecorations(x, Room))\nall x. (AttendFrequently(x, MusicFestival) & YoungTeenageGirl(x) -> BigFanOfPopBand(x) & BigFanOfPopSinger(x))\nAmbitious(Sam) -> BBigFanOfPopBand(Sam) & BigFanOfPopSinger(Sam)"
        ],
        "conclusion": "Sam neither has high ambitions and future career goals nor is she a young teenage girl attending music festival frequently",
        "conclusion-FOL": "-(Ambitious(Sam) | (Attend(Sam, Festival) & YoungTeenageGirl(Sam)))",
        "label": "ERROR"
    },
    {
        "premises": "If people have a lot of music decorations in their rooms, they cannot pack and move out of their rooms very easily.\nIf people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.\nIf people are big fans of pop bands and singers, then they have a lot of music decorations in their room.\nAll young teenage girls who attend music festival frequently are big fans of pop bands and singers.\nIf Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
        "premises-FOL": [
            "all x. (HaveIn(x, aLotOfMusicDecoration, Room) -> -MoveOutEasily(x))\nall x. (Ambitious(x) -> MoveOutEasily(x))\nall x. (BigFanOfMusic(x) -> MusicDecorations(x, Room))\nall x. (AttendFrequently(x, MusicFestival) & YoungTeenageGirl(x) -> BigFanOfPopBand(x) & BigFanOfPopSinger(x))\nAmbitious(Sam) -> BBigFanOfPopBand(Sam) & BigFanOfPopSinger(Sam)"
        ],
        "conclusion": "Sam has high ambitions and future career goals and is a young teenage girl attending music festival frequently.",
        "conclusion-FOL": "Ambitious(Sam) & Attend(Sam, Festival) & YoungTeenageGirl(Sam)",
        "label": "ERROR"
    },
    {
        "premises": "If people have a lot of music decorations in their rooms, they cannot pack and move out of their rooms very easily.\nIf people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.\nIf people are big fans of pop bands and singers, then they have a lot of music decorations in their room.\nAll young teenage girls who attend music festival frequently are big fans of pop bands and singers.\nIf Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
        "premises-FOL": [
            "all x. (HaveIn(x, aLotOfMusicDecoration, Room) -> -MoveOutEasily(x))\nall x. (Ambitious(x) -> MoveOutEasily(x))\nall x. (BigFanOfMusic(x) -> MusicDecorations(x, Room))\nall x. (AttendFrequently(x, MusicFestival) & YoungTeenageGirl(x) -> BigFanOfPopBand(x) & BigFanOfPopSinger(x))\nAmbitious(Sam) -> BBigFanOfPopBand(Sam) & BigFanOfPopSinger(Sam)"
        ],
        "conclusion": "Sam has high ambitions and future career goals and is a young teenage girl attending college.",
        "conclusion-FOL": "Ambitious(Sam) & Attend(Sam, Festival) & YoungTeenageGirl(Sam)",
        "label": "ERROR"
    },
    {
        "premises": "If people have a lot of music decorations in their rooms, they cannot pack and move out of their rooms very easily.\nIf people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.\nIf people are big fans of pop bands and singers, then they have a lot of music decorations in their room.\nAll young teenage girls who attend music festival frequently are big fans of pop bands and singers.\nIf Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
        "premises-FOL": [
            "all x. (HaveIn(x, aLotOfMusicDecoration, Room) -> -MoveOutEasily(x))\nall x. (Ambitious(x) -> MoveOutEasily(x))\nall x. (BigFanOfMusic(x) -> MusicDecorations(x, Room))\nall x. (AttendFrequently(x, MusicFestival) & YoungTeenageGirl(x) -> BigFanOfPopBand(x) & BigFanOfPopSinger(x))\nAmbitious(Sam) -> BBigFanOfPopBand(Sam) & BigFanOfPopSinger(Sam)"
        ],
        "conclusion": "If Sam is a young teenage girl attending college, then Sam either does not have high ambitions and future career goals or is a big fan of pop bands and singers.",
        "conclusion-FOL": "Attend(Sam, Festival) & YoungTeenageGirl(Sam) -> -(Ambitious(Sam) | (BigFanOfPopBand(Sam) & BigFanOfPopSinger(Sam)))",
        "label": "ERROR"
    },
    {
        "premises": "If people have a lot of music decorations in their rooms, they cannot pack and move out of their rooms very easily.\nIf people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.\nIf people are big fans of pop bands and singers, then they have a lot of music decorations in their room.\nAll young teenage girls who attend music festival frequently are big fans of pop bands and singers.\nIf Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
        "premises-FOL": [
            "all x. (HaveIn(x, aLotOfMusicDecoration, Room) -> -MoveOutEasily(x))\nall x. (Ambitious(x) -> MoveOutEasily(x))\nall x. (BigFanOfMusic(x) -> MusicDecorations(x, Room))\nall x. (AttendFrequently(x, MusicFestival) & YoungTeenageGirl(x) -> BigFanOfPopBand(x) & BigFanOfPopSinger(x))\nAmbitious(Sam) -> BBigFanOfPopBand(Sam) & BigFanOfPopSinger(Sam)"
        ],
        "conclusion": "If Sam has high ambitions and future career goals and is a young teenage girl attending college, then Sam either does not have high ambitions and future career goals or is not a young teenage girl attending college.",
        "conclusion-FOL": "Ambitious(Sam) & Attend(Sam, Festival) & YoungTeenageGirl(Sam) -> -(Ambitious(Sam) | (Attend(Sam, Festival) & YoungTeenageGirl(Sam)))",
        "label": "ERROR"
    },
    {
        "premises": "If people have a lot of music decorations in their rooms, they cannot pack and move out of their rooms very easily.\nIf people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.\nIf people are big fans of pop bands and singers, then they have a lot of music decorations in their room.\nAll young teenage girls who attend music festival frequently are big fans of pop bands and singers.\nIf Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
        "premises-FOL": [
            "all x. (HaveIn(x, aLotOfMusicDecoration, Room) -> -MoveOutEasily(x))\nall x. (Ambitious(x) -> MoveOutEasily(x))\nall x. (BigFanOfMusic(x) -> MusicDecorations(x, Room))\nall x. (AttendFrequently(x, MusicFestival) & YoungTeenageGirl(x) -> BigFanOfPopBand(x) & BigFanOfPopSinger(x))\nAmbitious(Sam) -> BBigFanOfPopBand(Sam) & BigFanOfPopSinger(Sam)"
        ],
        "conclusion": "If Sam has high ambitions and future career goals, then Sam is a young teenage girl attending college.",
        "conclusion-FOL": "Ambitious(Sam) -> Attend(Sam, Festival) & YoungTeenageGirl(Sam)",
        "label": "ERROR"
    },
    {
        "premises": "Brita was a cargo ship built for Norwegians.\nBrita was impressed into service by Germany.\nShips that have been impressed into service were seized by whoever impressed them into service.\nThe Britta was sold to Hong Kong.",
        "premises-FOL": [
            "CargoShip(Britta) & Ship(Britta) & BuiltFor(Britta, Norwegians)\nImpressedIntoServiceBy(Britta, Germany)\nall x. all y. (Ship(x) & ImpressedIntoServiceBy(x, y) -> SeizedBy(x, y))\nSoldTo(Britta, Hongkong)"
        ],
        "conclusion": "There was a cargo ship seized by Germany that was sold to Hong Kong.",
        "conclusion-FOL": "exists x. (CargoShip(x) & SeizedBy(x, Germany) & SoldTo(x, Hongkong))",
        "label": "ERROR"
    },
    {
        "premises": "Brita was a cargo ship built for Norwegians.\nBrita was impressed into service by Germany.\nShips that have been impressed into service were seized by whoever impressed them into service.\nThe Britta was sold to Hong Kong.",
        "premises-FOL": [
            "CargoShip(Britta) & Ship(Britta) & BuiltFor(Britta, Norwegians)\nImpressedIntoServiceBy(Britta, Germany)\nall x. all y. (Ship(x) & ImpressedIntoServiceBy(x, y) -> SeizedBy(x, y))\nSoldTo(Britta, Hongkong)"
        ],
        "conclusion": "Hong Kong hasn't had any seized ships sold to them.",
        "conclusion-FOL": "all x. all y. (SoldTo(x, Hongkong) -> -SeizedBy(x, y))",
        "label": "ERROR"
    },
    {
        "premises": "Brita was a cargo ship built for Norwegians.\nBrita was impressed into service by Germany.\nShips that have been impressed into service were seized by whoever impressed them into service.\nThe Britta was sold to Hong Kong.",
        "premises-FOL": [
            "CargoShip(Britta) & Ship(Britta) & BuiltFor(Britta, Norwegians)\nImpressedIntoServiceBy(Britta, Germany)\nall x. all y. (Ship(x) & ImpressedIntoServiceBy(x, y) -> SeizedBy(x, y))\nSoldTo(Britta, Hongkong)"
        ],
        "conclusion": "Hong Kong seized the Britta.",
        "conclusion-FOL": "SeizedBy(Britta, Hongkong)",
        "label": "ERROR"
    },
    {
        "premises": "Quincy McDuffie is an American professional wide receiver in Canadian Football.\nPeople who can catch balls are good wide receivers. \nQuincy McDuffie can catch some footballs easily.\nGood wide receivers play professionally.\nGood wide receivers can catch with both their left and right hand.\nAll footballs are balls.",
        "premises-FOL": [
            "American(QuincyMcduffie) & Professional(QuincyMcduffie) & WideReciever(QuincyMcduffie) & PlaysIn(QuincyMcduffie, cFL)\nall x. ((exists y.(CanCatch(x, y) & Ball(y))) -> GoodWideReceiver(x))\nexists x. exists y. (Football(x) & CanCatch(Quincymcduffie, x)) & (-(x=y) & (Football(y) & CanCatch(Quincymcduffie, y))\nall x. (GoodWideReceiver(x) -> Professional(x))\nall x. (GoodWideReceiver(x) -> (CanCatchWith(x, Lefthand) & CanCatchWith(x, Righthand)))\nall x. (Football(x) -> Ball(x))"
        ],
        "conclusion": "Quincy McDuffie is a good wide receiver.",
        "conclusion-FOL": "GoodWideReceiver(QuincyMcduffie)",
        "label": "ERROR"
    },
    {
        "premises": "Quincy McDuffie is an American professional wide receiver in Canadian Football.\nPeople who can catch balls are good wide receivers. \nQuincy McDuffie can catch some footballs easily.\nGood wide receivers play professionally.\nGood wide receivers can catch with both their left and right hand.\nAll footballs are balls.",
        "premises-FOL": [
            "American(QuincyMcduffie) & Professional(QuincyMcduffie) & WideReciever(QuincyMcduffie) & PlaysIn(QuincyMcduffie, cFL)\nall x. ((exists y.(CanCatch(x, y) & Ball(y))) -> GoodWideReceiver(x))\nexists x. exists y. (Football(x) & CanCatch(Quincymcduffie, x)) & (-(x=y) & (Football(y) & CanCatch(Quincymcduffie, y))\nall x. (GoodWideReceiver(x) -> Professional(x))\nall x. (GoodWideReceiver(x) -> (CanCatchWith(x, Lefthand) & CanCatchWith(x, Righthand)))\nall x. (Football(x) -> Ball(x))"
        ],
        "conclusion": "Quincy McDuffie can catch every ball.",
        "conclusion-FOL": "all x. (Ball(x) -> CanCatch(Quincymcduffie, x))",
        "label": "ERROR"
    },
    {
        "premises": "Quincy McDuffie is an American professional wide receiver in Canadian Football.\nPeople who can catch balls are good wide receivers. \nQuincy McDuffie can catch some footballs easily.\nGood wide receivers play professionally.\nGood wide receivers can catch with both their left and right hand.\nAll footballs are balls.",
        "premises-FOL": [
            "American(QuincyMcduffie) & Professional(QuincyMcduffie) & WideReciever(QuincyMcduffie) & PlaysIn(QuincyMcduffie, cFL)\nall x. ((exists y.(CanCatch(x, y) & Ball(y))) -> GoodWideReceiver(x))\nexists x. exists y. (Football(x) & CanCatch(Quincymcduffie, x)) & (-(x=y) & (Football(y) & CanCatch(Quincymcduffie, y))\nall x. (GoodWideReceiver(x) -> Professional(x))\nall x. (GoodWideReceiver(x) -> (CanCatchWith(x, Lefthand) & CanCatchWith(x, Righthand)))\nall x. (Football(x) -> Ball(x))"
        ],
        "conclusion": "Professional wide receivers are good at catching balls.",
        "conclusion-FOL": "all x. ((Professional(x) & WideReciever(x)) -> Good(x, Catchingballs))",
        "label": "ERROR"
    },
    {
        "premises": "Boves is a railway station located in France. \nThe preceding station of Boves is Longueau.\nThe preceding station of Dommartin is Boves.\nFrance is a European country.\nDommartin is situated on the Paris\u2013Lille railway. \nAny two contiguous stations are on the same railway.\nBoves is served by regional TER Hauts-de-France trains.\nIf place A is located in place B and place B is located in place C, then place A is located in place C.\nIf place A precedes place B and place B precedes place C, then place A precedes place C.",
        "premises-FOL": [
            "RailwayStation(Boves) & In(Boves, France)\nPrecede(Longueau, Boves)\nPrecede(Boves, Dommartin)\nIn(France, Europe)\nSituatedOn(Dommartin, PairsLille)\nall x. all y. all z. ((SituatedOn(x, z) & (Precede(x, y) | Precede(y, x)) -> SituatedOn(y, z))\nServe(Boves, HautsDeFrance)\nall x. all y. all z. ((In(x, y) & In(y, z)) -> In(x, z))\nall x. all y. all z. ((Precede(x, y) & Precede(y, z)) -> Precede(x, z))"
        ],
        "conclusion": "Longueau is situated on the Paris\u2013Lille railway.",
        "conclusion-FOL": "SituatedOn(Longueau, PairsLille)",
        "label": "ERROR"
    },
    {
        "premises": "Boves is a railway station located in France. \nThe preceding station of Boves is Longueau.\nThe preceding station of Dommartin is Boves.\nFrance is a European country.\nDommartin is situated on the Paris\u2013Lille railway. \nAny two contiguous stations are on the same railway.\nBoves is served by regional TER Hauts-de-France trains.\nIf place A is located in place B and place B is located in place C, then place A is located in place C.\nIf place A precedes place B and place B precedes place C, then place A precedes place C.",
        "premises-FOL": [
            "RailwayStation(Boves) & In(Boves, France)\nPrecede(Longueau, Boves)\nPrecede(Boves, Dommartin)\nIn(France, Europe)\nSituatedOn(Dommartin, PairsLille)\nall x. all y. all z. ((SituatedOn(x, z) & (Precede(x, y) | Precede(y, x)) -> SituatedOn(y, z))\nServe(Boves, HautsDeFrance)\nall x. all y. all z. ((In(x, y) & In(y, z)) -> In(x, z))\nall x. all y. all z. ((Precede(x, y) & Precede(y, z)) -> Precede(x, z))"
        ],
        "conclusion": "Boves is not in Europe.",
        "conclusion-FOL": "-In(Boves, Europe)",
        "label": "ERROR"
    },
    {
        "premises": "Boves is a railway station located in France. \nThe preceding station of Boves is Longueau.\nThe preceding station of Dommartin is Boves.\nFrance is a European country.\nDommartin is situated on the Paris\u2013Lille railway. \nAny two contiguous stations are on the same railway.\nBoves is served by regional TER Hauts-de-France trains.\nIf place A is located in place B and place B is located in place C, then place A is located in place C.\nIf place A precedes place B and place B precedes place C, then place A precedes place C.",
        "premises-FOL": [
            "RailwayStation(Boves) & In(Boves, France)\nPrecede(Longueau, Boves)\nPrecede(Boves, Dommartin)\nIn(France, Europe)\nSituatedOn(Dommartin, PairsLille)\nall x. all y. all z. ((SituatedOn(x, z) & (Precede(x, y) | Precede(y, x)) -> SituatedOn(y, z))\nServe(Boves, HautsDeFrance)\nall x. all y. all z. ((In(x, y) & In(y, z)) -> In(x, z))\nall x. all y. all z. ((Precede(x, y) & Precede(y, z)) -> Precede(x, z))"
        ],
        "conclusion": "Longueau is served by regional TER Hauts-de-France trains.",
        "conclusion-FOL": "Serve(Longueau, HautsDeFrance)",
        "label": "ERROR"
    },
    {
        "premises": "Edwin Smith was a New Zealand rower from Auckland.\nEdwin Smith was also known as Ted Smith.\nEdwin Smith went to Rose Road Primary School, located in Grey Lynn.\nEdwin Smith was a sergeant who served with the New Zealand 24th battalion in Italy and Egypt.\nBroadway Sheetmetals was a business run and owned by Edwin Smith, a sheet metal worker.",
        "premises-FOL": [
            "From(EdwinSmith, NewZealand) & Rower(EdwinSmith) & From(EdwinSmith, Auckland)\nEdwinSmith=TedSmith\nGoTo(EdwinSmith, RoseRoadPrimarySchool) & LocatedIn(RoseRoadPrimarySchool, GreyLynn)\nSergeant(EdwinSmith) & ServeWith(EdwinSmith, NewZealandTwoFourthBattalion) & ServeIn(EdwinSmith, Italy) & ServeIn(EdwinSmith, Egypt)\nBuisness(BroadwaySheetmetals) & Run(EdwinSmith, BroadwaySheetmetals) & Own(EdwinSmith, BroadwaySheetmetals) & SheetmetalWorker(Edwinsmith)"
        ],
        "conclusion": "Ted Smith was a sergeant.",
        "conclusion-FOL": "Sergeant(TedSmith)",
        "label": "ERROR"
    },
    {
        "premises": "Edwin Smith was a New Zealand rower from Auckland.\nEdwin Smith was also known as Ted Smith.\nEdwin Smith went to Rose Road Primary School, located in Grey Lynn.\nEdwin Smith was a sergeant who served with the New Zealand 24th battalion in Italy and Egypt.\nBroadway Sheetmetals was a business run and owned by Edwin Smith, a sheet metal worker.",
        "premises-FOL": [
            "From(EdwinSmith, NewZealand) & Rower(EdwinSmith) & From(EdwinSmith, Auckland)\nEdwinSmith=TedSmith\nGoTo(EdwinSmith, RoseRoadPrimarySchool) & LocatedIn(RoseRoadPrimarySchool, GreyLynn)\nSergeant(EdwinSmith) & ServeWith(EdwinSmith, NewZealandTwoFourthBattalion) & ServeIn(EdwinSmith, Italy) & ServeIn(EdwinSmith, Egypt)\nBuisness(BroadwaySheetmetals) & Run(EdwinSmith, BroadwaySheetmetals) & Own(EdwinSmith, BroadwaySheetmetals) & SheetmetalWorker(Edwinsmith)"
        ],
        "conclusion": "There were no rowers that own a buisness.",
        "conclusion-FOL": "all x. all y. (Rower(x) & Buisness(y) -> -Own(x, y))",
        "label": "ERROR"
    },
    {
        "premises": "Edwin Smith was a New Zealand rower from Auckland.\nEdwin Smith was also known as Ted Smith.\nEdwin Smith went to Rose Road Primary School, located in Grey Lynn.\nEdwin Smith was a sergeant who served with the New Zealand 24th battalion in Italy and Egypt.\nBroadway Sheetmetals was a business run and owned by Edwin Smith, a sheet metal worker.",
        "premises-FOL": [
            "From(EdwinSmith, NewZealand) & Rower(EdwinSmith) & From(EdwinSmith, Auckland)\nEdwinSmith=TedSmith\nGoTo(EdwinSmith, RoseRoadPrimarySchool) & LocatedIn(RoseRoadPrimarySchool, GreyLynn)\nSergeant(EdwinSmith) & ServeWith(EdwinSmith, NewZealandTwoFourthBattalion) & ServeIn(EdwinSmith, Italy) & ServeIn(EdwinSmith, Egypt)\nBuisness(BroadwaySheetmetals) & Run(EdwinSmith, BroadwaySheetmetals) & Own(EdwinSmith, BroadwaySheetmetals) & SheetmetalWorker(Edwinsmith)"
        ],
        "conclusion": "No sergeants were from Auckland.",
        "conclusion-FOL": "all x. (Sergeant(x) -> -From(x, Auckland))",
        "label": "ERROR"
    },
    {
        "premises": "Edwin Smith was a New Zealand rower from Auckland.\nEdwin Smith was also known as Ted Smith.\nEdwin Smith went to Rose Road Primary School, located in Grey Lynn.\nEdwin Smith was a sergeant who served with the New Zealand 24th battalion in Italy and Egypt.\nBroadway Sheetmetals was a business run and owned by Edwin Smith, a sheet metal worker.",
        "premises-FOL": [
            "From(EdwinSmith, NewZealand) & Rower(EdwinSmith) & From(EdwinSmith, Auckland)\nEdwinSmith=TedSmith\nGoTo(EdwinSmith, RoseRoadPrimarySchool) & LocatedIn(RoseRoadPrimarySchool, GreyLynn)\nSergeant(EdwinSmith) & ServeWith(EdwinSmith, NewZealandTwoFourthBattalion) & ServeIn(EdwinSmith, Italy) & ServeIn(EdwinSmith, Egypt)\nBuisness(BroadwaySheetmetals) & Run(EdwinSmith, BroadwaySheetmetals) & Own(EdwinSmith, BroadwaySheetmetals) & SheetmetalWorker(Edwinsmith)"
        ],
        "conclusion": "No business owner served in Egypt.",
        "conclusion-FOL": "all x. all y. (Buisness(x) & Own(y, x) -> -ServeIn(y, Egypt))",
        "label": "ERROR"
    },
    {
        "premises": "A werewolf is a human that can turn into a wolf.\nA werewolf has been scratched or bitten by another werewolf.\nIf someone has been scratched or bitten by some entity, they have been attacked by that entity.",
        "premises-FOL": [
            "all x. (Human(x) & CanTurnInto(x, Wolf) -> Werewolf(x))\nall x. exists y. (Werewolf(x) -> (BittenBy(x, y) | ScratchedBy(x, y)) & Werewolf(y))\nall x. exists y. (BittenBy(x, y) | ScratchedBy(x, y)) -> AttackedBy(x,y)"
        ],
        "conclusion": "All humans are werewolves.",
        "conclusion-FOL": "all x. (Human(x) -> Werewolf(x))",
        "label": "ERROR"
    },
    {
        "premises": "A werewolf is a human that can turn into a wolf.\nA werewolf has been scratched or bitten by another werewolf.\nIf someone has been scratched or bitten by some entity, they have been attacked by that entity.",
        "premises-FOL": [
            "all x. (Human(x) & CanTurnInto(x, Wolf) -> Werewolf(x))\nall x. exists y. (Werewolf(x) -> (BittenBy(x, y) | ScratchedBy(x, y)) & Werewolf(y))\nall x. exists y. (BittenBy(x, y) | ScratchedBy(x, y)) -> AttackedBy(x,y)"
        ],
        "conclusion": "A werewolf is a wolf.",
        "conclusion-FOL": "all x. (Werewolf(x) -> Wolf(x))",
        "label": "ERROR"
    },
    {
        "premises": "A werewolf is a human that can turn into a wolf.\nA werewolf has been scratched or bitten by another werewolf.\nIf someone has been scratched or bitten by some entity, they have been attacked by that entity.",
        "premises-FOL": [
            "all x. (Human(x) & CanTurnInto(x, Wolf) -> Werewolf(x))\nall x. exists y. (Werewolf(x) -> (BittenBy(x, y) | ScratchedBy(x, y)) & Werewolf(y))\nall x. exists y. (BittenBy(x, y) | ScratchedBy(x, y)) -> AttackedBy(x,y)"
        ],
        "conclusion": "A werewolf has scratched someone before.",
        "conclusion-FOL": "all x. exists y. (Werewolf(x) -> ScratchedBy(y, x))",
        "label": "ERROR"
    },
    {
        "premises": "UFC Fight Night was a mixed martial arts event held in Sweden.\nAt UFC Fight Night, Sadollah was scheduled to fight Musoke.\nSadollah fought Akiyama at UFC Fight Night.\nMusoke fought Yakovlev at UFC Fight Night.\nJung was injured at UFC Fight Night.\nPeople injured at UFC Fight Night did not fight.",
        "premises-FOL": [
            "Event(uFCFightNight) & MixedMartial(uFCFightNight) & HeldIn(uFCFightNight, Sweden)\nScheduledToFight(Sadollah, Musoke,uFCFightNight)\nFight(Sadollah, Akiyama, uFCFightNight)\nFight(Musoke, Yakovlev, uFCFightNight)\nInjuredAt(Jung, uFCFightNight)\nall x. (InjuredAt(x, uFCFightNight) -> -FightIn(x, uFCFightNight))"
        ],
        "conclusion": "Jung fought Sadollah.",
        "conclusion-FOL": "Fight(Jung, Sadollah, uFCFightNight)",
        "label": "ERROR"
    },
    {
        "premises": "UFC Fight Night was a mixed martial arts event held in Sweden.\nAt UFC Fight Night, Sadollah was scheduled to fight Musoke.\nSadollah fought Akiyama at UFC Fight Night.\nMusoke fought Yakovlev at UFC Fight Night.\nJung was injured at UFC Fight Night.\nPeople injured at UFC Fight Night did not fight.",
        "premises-FOL": [
            "Event(uFCFightNight) & MixedMartial(uFCFightNight) & HeldIn(uFCFightNight, Sweden)\nScheduledToFight(Sadollah, Musoke,uFCFightNight)\nFight(Sadollah, Akiyama, uFCFightNight)\nFight(Musoke, Yakovlev, uFCFightNight)\nInjuredAt(Jung, uFCFightNight)\nall x. (InjuredAt(x, uFCFightNight) -> -FightIn(x, uFCFightNight))"
        ],
        "conclusion": "Jung did not fight at UFC Fight Night.",
        "conclusion-FOL": "Event(uFCFightNight) & -FightIn(Jung, uFCFightNight)",
        "label": "ERROR"
    },
    {
        "premises": "UFC Fight Night was a mixed martial arts event held in Sweden.\nAt UFC Fight Night, Sadollah was scheduled to fight Musoke.\nSadollah fought Akiyama at UFC Fight Night.\nMusoke fought Yakovlev at UFC Fight Night.\nJung was injured at UFC Fight Night.\nPeople injured at UFC Fight Night did not fight.",
        "premises-FOL": [
            "Event(uFCFightNight) & MixedMartial(uFCFightNight) & HeldIn(uFCFightNight, Sweden)\nScheduledToFight(Sadollah, Musoke,uFCFightNight)\nFight(Sadollah, Akiyama, uFCFightNight)\nFight(Musoke, Yakovlev, uFCFightNight)\nInjuredAt(Jung, uFCFightNight)\nall x. (InjuredAt(x, uFCFightNight) -> -FightIn(x, uFCFightNight))"
        ],
        "conclusion": "Sadollah fought Musoke at UFC Fight Night.",
        "conclusion-FOL": "Fight(Sadollah, Musoke, uFCFightNight)",
        "label": "ERROR"
    },
    {
        "premises": "UFC Fight Night was a mixed martial arts event held in Sweden.\nAt UFC Fight Night, Sadollah was scheduled to fight Musoke.\nSadollah fought Akiyama at UFC Fight Night.\nMusoke fought Yakovlev at UFC Fight Night.\nJung was injured at UFC Fight Night.\nPeople injured at UFC Fight Night did not fight.",
        "premises-FOL": [
            "Event(uFCFightNight) & MixedMartial(uFCFightNight) & HeldIn(uFCFightNight, Sweden)\nScheduledToFight(Sadollah, Musoke,uFCFightNight)\nFight(Sadollah, Akiyama, uFCFightNight)\nFight(Musoke, Yakovlev, uFCFightNight)\nInjuredAt(Jung, uFCFightNight)\nall x. (InjuredAt(x, uFCFightNight) -> -FightIn(x, uFCFightNight))"
        ],
        "conclusion": "Nelson fought Story at UFC Fight Night.",
        "conclusion-FOL": "Fight(Nelson, Story, uFCFightNight)",
        "label": "ERROR"
    },
    {
        "premises": "All drinks on the counter are edible. \nAll juices on the counter are drinks. \nOrange juice is a type of juice. \nEverything on the counter is either orange juice or apple juice.\nAll apple juices on the counter are sweet.\nThe coke is on the counter and if the coke is apple juice, then the coke is a drink.\nIf the coke is not apple juice, then the coke is not edible.",
        "premises-FOL": [
            "all x. (OnCounter(x) & Drink(x) -> Edible(x))\nall x. (OnCounter(x) & Juice(x) -> Drink(x))\nall x. (OrangeJuice(x) -> Juice(x))\nall x. (OnCounter(x) -> ((OrangeJuice(x) & -AppleJuice(x)) | (-OrangeJuice(x) & AppleJuice(x))))\nall x. (OnCounter(x) & AppleJuice(x) -> Sweet(x))\nOnCounter(Coke) & (AppleJuice(Coke) -> Drink(Coke))\n-AppleJuice(Coke) -> -Edible(Coke)"
        ],
        "conclusion": "The coke is orange juice.",
        "conclusion-FOL": "OrangeJuice(Coke)",
        "label": "ERROR"
    },
    {
        "premises": "All drinks on the counter are edible. \nAll juices on the counter are drinks. \nOrange juice is a type of juice. \nEverything on the counter is either orange juice or apple juice.\nAll apple juices on the counter are sweet.\nThe coke is on the counter and if the coke is apple juice, then the coke is a drink.\nIf the coke is not apple juice, then the coke is not edible.",
        "premises-FOL": [
            "all x. (OnCounter(x) & Drink(x) -> Edible(x))\nall x. (OnCounter(x) & Juice(x) -> Drink(x))\nall x. (OrangeJuice(x) -> Juice(x))\nall x. (OnCounter(x) -> ((OrangeJuice(x) & -AppleJuice(x)) | (-OrangeJuice(x) & AppleJuice(x))))\nall x. (OnCounter(x) & AppleJuice(x) -> Sweet(x))\nOnCounter(Coke) & (AppleJuice(Coke) -> Drink(Coke))\n-AppleJuice(Coke) -> -Edible(Coke)"
        ],
        "conclusion": "The coke is edible and sweet.",
        "conclusion-FOL": "Edible(Coke) & Sweet(Coke)",
        "label": "ERROR"
    },
    {
        "premises": "All drinks on the counter are edible. \nAll juices on the counter are drinks. \nOrange juice is a type of juice. \nEverything on the counter is either orange juice or apple juice.\nAll apple juices on the counter are sweet.\nThe coke is on the counter and if the coke is apple juice, then the coke is a drink.\nIf the coke is not apple juice, then the coke is not edible.",
        "premises-FOL": [
            "all x. (OnCounter(x) & Drink(x) -> Edible(x))\nall x. (OnCounter(x) & Juice(x) -> Drink(x))\nall x. (OrangeJuice(x) -> Juice(x))\nall x. (OnCounter(x) -> ((OrangeJuice(x) & -AppleJuice(x)) | (-OrangeJuice(x) & AppleJuice(x))))\nall x. (OnCounter(x) & AppleJuice(x) -> Sweet(x))\nOnCounter(Coke) & (AppleJuice(Coke) -> Drink(Coke))\n-AppleJuice(Coke) -> -Edible(Coke)"
        ],
        "conclusion": "The coke is not edible and sweet.",
        "conclusion-FOL": "-(Edible(Coke) & Sweet(Coke))",
        "label": "ERROR"
    },
    {
        "premises": "Federico Garcia Lorca was a talented Spanish poet, and he supported the Popular Front.\nThe Spanish Nationalists opposed anyone who supported the Popular Front\nTalented poets are popular.\nSpanish Nationalists killed anyone who they opposed and who was popular.\nDaniel supported the Popular Front but was not popular.",
        "premises-FOL": [
            "TalentedPoet(Lorca) & Support(Lorca, Populists)\nall x. (Support(x, Populists) -> Opposed(Nationalists, x))\nall x. (TalentedPoet(x) -> Popular(x))\nall x. ((Opposed(Nationalists, x) & Popular(x)) -> Killed(Nationalists, x))\nSupport(Daniel, Populists) & (-Popular(Daniel))"
        ],
        "conclusion": "The Spanish Nationalists killed Daniel.",
        "conclusion-FOL": "-Killed(Nationalists, Daniel)",
        "label": "ERROR"
    },
    {
        "premises": "Federico Garcia Lorca was a talented Spanish poet, and he supported the Popular Front.\nThe Spanish Nationalists opposed anyone who supported the Popular Front\nTalented poets are popular.\nSpanish Nationalists killed anyone who they opposed and who was popular.\nDaniel supported the Popular Front but was not popular.",
        "premises-FOL": [
            "TalentedPoet(Lorca) & Support(Lorca, Populists)\nall x. (Support(x, Populists) -> Opposed(Nationalists, x))\nall x. (TalentedPoet(x) -> Popular(x))\nall x. ((Opposed(Nationalists, x) & Popular(x)) -> Killed(Nationalists, x))\nSupport(Daniel, Populists) & (-Popular(Daniel))"
        ],
        "conclusion": "The Spanish Nationalists killed Lorca.",
        "conclusion-FOL": "Killed(Nationalists, Lorca)",
        "label": "ERROR"
    },
    {
        "premises": "People in Franny's family drink kombucha every day or drink Coca-Cola or a Pepsi product.\nIf people in Franny's family drink Coca-Cola or a Pepsi product every day, then they grew up with extremely busy parents who did not have time to pack them lunch.\nIf people in Franny's family drink Coca-Cola or another Pepsi product every day, then they have to visit the dentist frequently.\nIf people in Franny's family grew up with extremely busy parents who did not have time to pack them lunch, then they have erratic and diverse eating habits.\nIf people in Franny's family have erratic and diverse eating habits, then they do not have consistent everyday routines and like sticking to a solid schedule.\nDamon is in Franny's family. \nDamon either both grow up with extremely busy parents who did not have time to pack her lunch and have consistent everyday routines and like sticking to a solid schedule, or Damon did neither.",
        "premises-FOL": [
            "all x. (In(x, FrannysFamily) & (Drink(x, Kombucha) | (exists y. (Drink(x, CocaCola) | (PepsiProduct(y) & Drink(x, y))))))\nall x. (In(x, FrannysFamily) & (exists y. (Drink(x, CocaCola) | (PepsiProduct(y) & Drink(x, y)))) -> (exists y. exists z. (-(y=z) & BusyParent(y) & BusyParent(z) & -Pack(y, Lunch) & -Pack(z, Lunch) & GrowUpWith(x, y) & GrowUpWith(x, z))))\nall x. (In(x, FrannysFamily)) & (exists y. (Drink(x, CocaCola) | (PepsiProduct(y) & Drink(x, y)))) -> HaveToVisitFrequently(x, Dentist))\nall x. (In(x, FrannysFamily) & (exists y. exists z. (-(y=z) & BusyParent(y) & BusyParent(z) & -Pack(y, Lunch) & -Pack(z, Lunch) & GrowUpWith(x, y) & GrowUpWith(x, z))) -> exists y. (Have(x, y) & Erratic(y) & Diverse(y) & EatingHabit(y)))\nall x. (In(x, FrannysFamily) & exists y. (Have(x, y) & Erratic(y) & Diverse(y) & EatingHabit(y))) -> -(ConsistentEverydayRoutine(x) & StickTo(Damon, SolidSchedule)))\nIn(Damon, FrannysFamily)\n-((((exists y. exists z.(-(y=z) & BusyParent(y) & BusyParent(z) & -Pack(y, Lunch) & -Pack(z, Lunch) & GrowUpWith(Damon, y) & GrowUpWith(Damon, z))) & -(ConsistentEverydayRoutine(Damon) & StickTo(Damon, SolidSchedule))) | (-((exists y. exists z.(-(y=z) & BusyParent(y) & BusyParent(z) & -Pack(y, Lunch) & -Pack(z, Lunch) & GrowUpWith(Damon, y) & GrowUpWith(Damon, z))) & (ConsistentEverydayRoutine(Damon) & StickTo(Damon, SolidSchedule)))))"
        ],
        "conclusion": "Damon is in Franny's family and he has to visit the dentist frequently.",
        "conclusion-FOL": "HaveToVisitFrequently(Damon, Dentist)",
        "label": "ERROR"
    },
    {
        "premises": "People in Franny's family drink kombucha every day or drink Coca-Cola or a Pepsi product.\nIf people in Franny's family drink Coca-Cola or a Pepsi product every day, then they grew up with extremely busy parents who did not have time to pack them lunch.\nIf people in Franny's family drink Coca-Cola or another Pepsi product every day, then they have to visit the dentist frequently.\nIf people in Franny's family grew up with extremely busy parents who did not have time to pack them lunch, then they have erratic and diverse eating habits.\nIf people in Franny's family have erratic and diverse eating habits, then they do not have consistent everyday routines and like sticking to a solid schedule.\nDamon is in Franny's family. \nDamon either both grow up with extremely busy parents who did not have time to pack her lunch and have consistent everyday routines and like sticking to a solid schedule, or Damon did neither.",
        "premises-FOL": [
            "all x. (In(x, FrannysFamily) & (Drink(x, Kombucha) | (exists y. (Drink(x, CocaCola) | (PepsiProduct(y) & Drink(x, y))))))\nall x. (In(x, FrannysFamily) & (exists y. (Drink(x, CocaCola) | (PepsiProduct(y) & Drink(x, y)))) -> (exists y. exists z. (-(y=z) & BusyParent(y) & BusyParent(z) & -Pack(y, Lunch) & -Pack(z, Lunch) & GrowUpWith(x, y) & GrowUpWith(x, z))))\nall x. (In(x, FrannysFamily)) & (exists y. (Drink(x, CocaCola) | (PepsiProduct(y) & Drink(x, y)))) -> HaveToVisitFrequently(x, Dentist))\nall x. (In(x, FrannysFamily) & (exists y. exists z. (-(y=z) & BusyParent(y) & BusyParent(z) & -Pack(y, Lunch) & -Pack(z, Lunch) & GrowUpWith(x, y) & GrowUpWith(x, z))) -> exists y. (Have(x, y) & Erratic(y) & Diverse(y) & EatingHabit(y)))\nall x. (In(x, FrannysFamily) & exists y. (Have(x, y) & Erratic(y) & Diverse(y) & EatingHabit(y))) -> -(ConsistentEverydayRoutine(x) & StickTo(Damon, SolidSchedule)))\nIn(Damon, FrannysFamily)\n-((((exists y. exists z.(-(y=z) & BusyParent(y) & BusyParent(z) & -Pack(y, Lunch) & -Pack(z, Lunch) & GrowUpWith(Damon, y) & GrowUpWith(Damon, z))) & -(ConsistentEverydayRoutine(Damon) & StickTo(Damon, SolidSchedule))) | (-((exists y. exists z.(-(y=z) & BusyParent(y) & BusyParent(z) & -Pack(y, Lunch) & -Pack(z, Lunch) & GrowUpWith(Damon, y) & GrowUpWith(Damon, z))) & (ConsistentEverydayRoutine(Damon) & StickTo(Damon, SolidSchedule)))))"
        ],
        "conclusion": "If Damon is in Franny's family and he either both grew up with extremely busy parents who did not have time to pack his lunch and drink kombucha every day or neither grew up with extremely busy parents who did not have time to pack his lunch nor drink kombucha every day, then Damon neither visits the dentist frequently nor drinks Coca Cola or Pepsi products.",
        "conclusion-FOL": "-((-(y=z) & exists y. exists z. (BusyParent(y) & BusyParent(z) & -Pack(y, Lunch) & -Pack(z, Lunch) & GrowUpWith(Damon, y) & GrowUpWith(Damon, z))) \u2295 Drink(Damon, Kombucha)) -> -(HaveToVisitFrequently(Damon, Dentist) | (exists y. (Have(Damon, y) & Erratic(y) & Diverse(y) & EatingHabit(y))))",
        "label": "ERROR"
    },
    {
        "premises": "People in Franny's family drink kombucha every day or drink Coca-Cola or a Pepsi product.\nIf people in Franny's family drink Coca-Cola or a Pepsi product every day, then they grew up with extremely busy parents who did not have time to pack them lunch.\nIf people in Franny's family drink Coca-Cola or another Pepsi product every day, then they have to visit the dentist frequently.\nIf people in Franny's family grew up with extremely busy parents who did not have time to pack them lunch, then they have erratic and diverse eating habits.\nIf people in Franny's family have erratic and diverse eating habits, then they do not have consistent everyday routines and like sticking to a solid schedule.\nDamon is in Franny's family. \nDamon either both grow up with extremely busy parents who did not have time to pack her lunch and have consistent everyday routines and like sticking to a solid schedule, or Damon did neither.",
        "premises-FOL": [
            "all x. (In(x, FrannysFamily) & (Drink(x, Kombucha) | (exists y. (Drink(x, CocaCola) | (PepsiProduct(y) & Drink(x, y))))))\nall x. (In(x, FrannysFamily) & (exists y. (Drink(x, CocaCola) | (PepsiProduct(y) & Drink(x, y)))) -> (exists y. exists z. (-(y=z) & BusyParent(y) & BusyParent(z) & -Pack(y, Lunch) & -Pack(z, Lunch) & GrowUpWith(x, y) & GrowUpWith(x, z))))\nall x. (In(x, FrannysFamily)) & (exists y. (Drink(x, CocaCola) | (PepsiProduct(y) & Drink(x, y)))) -> HaveToVisitFrequently(x, Dentist))\nall x. (In(x, FrannysFamily) & (exists y. exists z. (-(y=z) & BusyParent(y) & BusyParent(z) & -Pack(y, Lunch) & -Pack(z, Lunch) & GrowUpWith(x, y) & GrowUpWith(x, z))) -> exists y. (Have(x, y) & Erratic(y) & Diverse(y) & EatingHabit(y)))\nall x. (In(x, FrannysFamily) & exists y. (Have(x, y) & Erratic(y) & Diverse(y) & EatingHabit(y))) -> -(ConsistentEverydayRoutine(x) & StickTo(Damon, SolidSchedule)))\nIn(Damon, FrannysFamily)\n-((((exists y. exists z.(-(y=z) & BusyParent(y) & BusyParent(z) & -Pack(y, Lunch) & -Pack(z, Lunch) & GrowUpWith(Damon, y) & GrowUpWith(Damon, z))) & -(ConsistentEverydayRoutine(Damon) & StickTo(Damon, SolidSchedule))) | (-((exists y. exists z.(-(y=z) & BusyParent(y) & BusyParent(z) & -Pack(y, Lunch) & -Pack(z, Lunch) & GrowUpWith(Damon, y) & GrowUpWith(Damon, z))) & (ConsistentEverydayRoutine(Damon) & StickTo(Damon, SolidSchedule)))))"
        ],
        "conclusion": "If Damon is in Franny's family and he either visits the dentist frequently or drinks kombucha, then Damon both visits the dentist frequently and drinks Coca-Cola or Pepsi products every day.",
        "conclusion-FOL": "HaveToVisitFrequently(Damon, Dentist) | Drink(Damon, Kombucha, EveryDay) -> HaveToVisitFrequently(Damon, Dentist) & (exists y. (Drink(x, CocaCola) | (PepsiProduct(y) & Drink(x, y))))",
        "label": "ERROR"
    },
    {
        "premises": "If a customer subscribes to AMC A-List, then he/she can watch 3 movies every week without any additional fees. \nSome customers go to cinemas every week. \nCustomers who prefer TV series will not watch TV series in cinemas.\nJames watches TV series in cinemas. \nJames subscribes to AMC A-List.\nPeter prefers TV series.",
        "premises-FOL": [
            "all x. (SubscribedTo(x, aMCAList) -> EligibleForThreeFreeMovies(x))\nexists x. (CinemaEveryWeek(x))\nall x. (Prefer(x, tVSeries) -> -WatchTVIn(x, Cinemas))\nWatchTVIn(James, Cinemas)\nSubscribedTo(James, aMCAList)\nPrefer(Peter, tVSeries)"
        ],
        "conclusion": "James cannot watch 3 movies every week without any additional fees.",
        "conclusion-FOL": "-EligibleForThreeFreeMovies(James)",
        "label": "ERROR"
    },
    {
        "premises": "If a customer subscribes to AMC A-List, then he/she can watch 3 movies every week without any additional fees. \nSome customers go to cinemas every week. \nCustomers who prefer TV series will not watch TV series in cinemas.\nJames watches TV series in cinemas. \nJames subscribes to AMC A-List.\nPeter prefers TV series.",
        "premises-FOL": [
            "all x. (SubscribedTo(x, aMCAList) -> EligibleForThreeFreeMovies(x))\nexists x. (CinemaEveryWeek(x))\nall x. (Prefer(x, tVSeries) -> -WatchTVIn(x, Cinemas))\nWatchTVIn(James, Cinemas)\nSubscribedTo(James, aMCAList)\nPrefer(Peter, tVSeries)"
        ],
        "conclusion": "James goes to cinemas every week.",
        "conclusion-FOL": "CinemaEveryWeek(James)",
        "label": "ERROR"
    },
    {
        "premises": "If a customer subscribes to AMC A-List, then he/she can watch 3 movies every week without any additional fees. \nSome customers go to cinemas every week. \nCustomers who prefer TV series will not watch TV series in cinemas.\nJames watches TV series in cinemas. \nJames subscribes to AMC A-List.\nPeter prefers TV series.",
        "premises-FOL": [
            "all x. (SubscribedTo(x, aMCAList) -> EligibleForThreeFreeMovies(x))\nexists x. (CinemaEveryWeek(x))\nall x. (Prefer(x, tVSeries) -> -WatchTVIn(x, Cinemas))\nWatchTVIn(James, Cinemas)\nSubscribedTo(James, aMCAList)\nPrefer(Peter, tVSeries)"
        ],
        "conclusion": "Peter will not watch TV series in cinemas.",
        "conclusion-FOL": "-WatchTVIn(Peter, Cinemas)",
        "label": "ERROR"
    },
    {
        "premises": "Bulbophyllum attenuatum is in the genus Bulbophyllum.\nAll Bulbophyllum are orchids.",
        "premises-FOL": [
            "GenusBulbophyllum(BulbophyllumAttenuatum)\nall x. (GenusBulbophyllum(x) -> Orchid(x))"
        ],
        "conclusion": "Bulbophyllum attenuatum is not an orchid.",
        "conclusion-FOL": "-Orchid(BulbophyllumAttenuatum)",
        "label": "ERROR"
    },
    {
        "premises": "There are eight federal districts of Russia: Central, Northwestern, Southern, North Caucasian, Volga, Ural, Siberian, and Far Eastern.\nThe Central federal district has the largest population among all federal districts in Russia.\nMoscow is the administrative center of the Central federal district.\nYekaterinburg is the administrative center of the Ural federal district.\nVladivostok is the administrative center of the Far Eastern federal district.\nThe Far Eastern federal district has the largest area among all federal districts in Russia.\nSome federal districts in Russia were established in 2000.",
        "premises-FOL": [
            "FederalDistrictOf(Central, Russia) & FederalDistrictOf(Northwestern, Russia) & FederalDistrictOf(Southern, Russia) & FederalDistrictOf(Northcaucasian, Russia) & FederalDistrictOf(Volga, Russia) & FederalDistrictOf(Ural, Russia) & FederalDistrictOf(Siberian, Russia) & FederalDistrictOf(Fareastern, Russia)\nLargestPopulation(Central) \nAdministrativeCenterOf(Moscow, Central)\nAdministrativeCenterOf(Yekaterinburg, Ural)\nAdministrativeCenterOf(Vladivostok, FarEastern)\nLargestArea(FarEastern)\nexists x. (FederalDistrictOf(x, Russia) & EstablishedIn(x, TwoZeroZeroZero))"
        ],
        "conclusion": "Vladivostok is the administrative center of the federal district with the largest area.",
        "conclusion-FOL": "exists x. (AdministrativeCenterOf(Vladivostok, x) & LargestArea(x))",
        "label": "ERROR"
    },
    {
        "premises": "There are eight federal districts of Russia: Central, Northwestern, Southern, North Caucasian, Volga, Ural, Siberian, and Far Eastern.\nThe Central federal district has the largest population among all federal districts in Russia.\nMoscow is the administrative center of the Central federal district.\nYekaterinburg is the administrative center of the Ural federal district.\nVladivostok is the administrative center of the Far Eastern federal district.\nThe Far Eastern federal district has the largest area among all federal districts in Russia.\nSome federal districts in Russia were established in 2000.",
        "premises-FOL": [
            "FederalDistrictOf(Central, Russia) & FederalDistrictOf(Northwestern, Russia) & FederalDistrictOf(Southern, Russia) & FederalDistrictOf(Northcaucasian, Russia) & FederalDistrictOf(Volga, Russia) & FederalDistrictOf(Ural, Russia) & FederalDistrictOf(Siberian, Russia) & FederalDistrictOf(Fareastern, Russia)\nLargestPopulation(Central) \nAdministrativeCenterOf(Moscow, Central)\nAdministrativeCenterOf(Yekaterinburg, Ural)\nAdministrativeCenterOf(Vladivostok, FarEastern)\nLargestArea(FarEastern)\nexists x. (FederalDistrictOf(x, Russia) & EstablishedIn(x, TwoZeroZeroZero))"
        ],
        "conclusion": "Moscow is the administrative center of the federal district with the largest population.",
        "conclusion-FOL": "exists x. (AdministrativeCenterOf(Moscow, x) & LargestPopulationIn(x))",
        "label": "ERROR"
    },
    {
        "premises": "There are eight federal districts of Russia: Central, Northwestern, Southern, North Caucasian, Volga, Ural, Siberian, and Far Eastern.\nThe Central federal district has the largest population among all federal districts in Russia.\nMoscow is the administrative center of the Central federal district.\nYekaterinburg is the administrative center of the Ural federal district.\nVladivostok is the administrative center of the Far Eastern federal district.\nThe Far Eastern federal district has the largest area among all federal districts in Russia.\nSome federal districts in Russia were established in 2000.",
        "premises-FOL": [
            "FederalDistrictOf(Central, Russia) & FederalDistrictOf(Northwestern, Russia) & FederalDistrictOf(Southern, Russia) & FederalDistrictOf(Northcaucasian, Russia) & FederalDistrictOf(Volga, Russia) & FederalDistrictOf(Ural, Russia) & FederalDistrictOf(Siberian, Russia) & FederalDistrictOf(Fareastern, Russia)\nLargestPopulation(Central) \nAdministrativeCenterOf(Moscow, Central)\nAdministrativeCenterOf(Yekaterinburg, Ural)\nAdministrativeCenterOf(Vladivostok, FarEastern)\nLargestArea(FarEastern)\nexists x. (FederalDistrictOf(x, Russia) & EstablishedIn(x, TwoZeroZeroZero))"
        ],
        "conclusion": "The Northwestern federal district was established in 2000.",
        "conclusion-FOL": "EstablishedIn(Northwestern, TwoZeroZeroZero)",
        "label": "ERROR"
    },
    {
        "premises": "All cancers have mutations.\nNo mutations can be treated at home.\nAll colorectal cancers are cancers.\nA cold can be treated at home.\nArthritis either is a cold and has mutations or neither is a cold nor has mutations.",
        "premises-FOL": [
            "all x. (Cancer(x) -> Have(x, Mutation))\nall x. (Have(x, Mutation) -> -CanBeTreatedAtHome(x))\nall x. (ColorectalCancer(x) -> Cancer(x))\nall x. (Cold(x) -> CanBeTreatedAtHome(x))\n-(((Cold(Arthritis) & -Have(Arthritis, Mutation)) | (-Cold(Arthritis) & Have(Arthritis, Mutation))))"
        ],
        "conclusion": "Arthritis can be treated at home.",
        "conclusion-FOL": "CanBeTreatedAtHome(Arthritis)",
        "label": "ERROR"
    },
    {
        "premises": "All cancers have mutations.\nNo mutations can be treated at home.\nAll colorectal cancers are cancers.\nA cold can be treated at home.\nArthritis either is a cold and has mutations or neither is a cold nor has mutations.",
        "premises-FOL": [
            "all x. (Cancer(x) -> Have(x, Mutation))\nall x. (Have(x, Mutation) -> -CanBeTreatedAtHome(x))\nall x. (ColorectalCancer(x) -> Cancer(x))\nall x. (Cold(x) -> CanBeTreatedAtHome(x))\n-(((Cold(Arthritis) & -Have(Arthritis, Mutation)) | (-Cold(Arthritis) & Have(Arthritis, Mutation))))"
        ],
        "conclusion": "Arthritis is colorectal cancer.",
        "conclusion-FOL": "ColorectalCancer(Arthritis)",
        "label": "ERROR"
    },
    {
        "premises": "All cancers have mutations.\nNo mutations can be treated at home.\nAll colorectal cancers are cancers.\nA cold can be treated at home.\nArthritis either is a cold and has mutations or neither is a cold nor has mutations.",
        "premises-FOL": [
            "all x. (Cancer(x) -> Have(x, Mutation))\nall x. (Have(x, Mutation) -> -CanBeTreatedAtHome(x))\nall x. (ColorectalCancer(x) -> Cancer(x))\nall x. (Cold(x) -> CanBeTreatedAtHome(x))\n-(((Cold(Arthritis) & -Have(Arthritis, Mutation)) | (-Cold(Arthritis) & Have(Arthritis, Mutation))))"
        ],
        "conclusion": "Arthritis is not colorectal cancer.",
        "conclusion-FOL": "-ColorectalCancer(Arthritis)",
        "label": "ERROR"
    },
    {
        "premises": "All cancers have mutations.\nNo mutations can be treated at home.\nAll colorectal cancers are cancers.\nA cold can be treated at home.\nArthritis either is a cold and has mutations or neither is a cold nor has mutations.",
        "premises-FOL": [
            "all x. (Cancer(x) -> Have(x, Mutation))\nall x. (Have(x, Mutation) -> -CanBeTreatedAtHome(x))\nall x. (ColorectalCancer(x) -> Cancer(x))\nall x. (Cold(x) -> CanBeTreatedAtHome(x))\n-(((Cold(Arthritis) & -Have(Arthritis, Mutation)) | (-Cold(Arthritis) & Have(Arthritis, Mutation))))"
        ],
        "conclusion": "Arthritis is colorectal cancer or has mutations.",
        "conclusion-FOL": "ColorectalCancer(Arthritis) | Have(Arthritis, Mutation)",
        "label": "ERROR"
    },
    {
        "premises": "All cancers have mutations.\nNo mutations can be treated at home.\nAll colorectal cancers are cancers.\nA cold can be treated at home.\nArthritis either is a cold and has mutations or neither is a cold nor has mutations.",
        "premises-FOL": [
            "all x. (Cancer(x) -> Have(x, Mutation))\nall x. (Have(x, Mutation) -> -CanBeTreatedAtHome(x))\nall x. (ColorectalCancer(x) -> Cancer(x))\nall x. (Cold(x) -> CanBeTreatedAtHome(x))\n-(((Cold(Arthritis) & -Have(Arthritis, Mutation)) | (-Cold(Arthritis) & Have(Arthritis, Mutation))))"
        ],
        "conclusion": "Arthritis is colorectal cancer and a cancer.",
        "conclusion-FOL": "ColorectalCancer(Arthritisr) & Cancer(Arthritis)",
        "label": "ERROR"
    },
    {
        "premises": "All cancers have mutations.\nNo mutations can be treated at home.\nAll colorectal cancers are cancers.\nA cold can be treated at home.\nArthritis either is a cold and has mutations or neither is a cold nor has mutations.",
        "premises-FOL": [
            "all x. (Cancer(x) -> Have(x, Mutation))\nall x. (Have(x, Mutation) -> -CanBeTreatedAtHome(x))\nall x. (ColorectalCancer(x) -> Cancer(x))\nall x. (Cold(x) -> CanBeTreatedAtHome(x))\n-(((Cold(Arthritis) & -Have(Arthritis, Mutation)) | (-Cold(Arthritis) & Have(Arthritis, Mutation))))"
        ],
        "conclusion": "If arthritis is not colorectal cancer, then arthritis has mutations.",
        "conclusion-FOL": "-ColorectalCancer(Arthritis) -> Have(Arthritis, Mutation)",
        "label": "ERROR"
    },
    {
        "premises": "Jerry should not worry about things outside of his control.\nAll traffic is outside of my control.",
        "premises-FOL": [
            "all x. (OutsideOfControl(x) -> -ShouldWorry(Jerry, x))\nall x. (Traffic(x) -> OutsideControl(x))"
        ],
        "conclusion": "Jerry should not worry about traffic.",
        "conclusion-FOL": "-ShouldWorry(Jerry, Traffic)",
        "label": "ERROR"
    },
    {
        "premises": "Roversi is an Italian surname.\nAlba Roversi uses Roversi as a surname.\nPaolo Roversi uses Roversi as a surname.\nRoberto Roversi uses Roversi as a surname.\nPaolo Roversi is a photographer.\nA photographer is a professional or an amateur.",
        "premises-FOL": [
            "ItalianName(Roversi) & Surname(Roversi)\nUseAsSurname(AlbaRoversi, Roversi)\nUseAsSurname(PaoloRoversi, Roversi)\nUseAsSurname(RobertoRoversi, Roversi)\nPhotographer(PaoloRoversi)\nall x. (Photographer(x) -> ((Professional(x) & -Amateur(x)) | (-Professional(x) & Amateur(x))))"
        ],
        "conclusion": "Alba Roversi uses an Italian surname.",
        "conclusion-FOL": "exists x. (ItalianName(x) & Surname(x) & UseAsSurname(AlbaRoversi, x))",
        "label": "ERROR"
    },
    {
        "premises": "Roversi is an Italian surname.\nAlba Roversi uses Roversi as a surname.\nPaolo Roversi uses Roversi as a surname.\nRoberto Roversi uses Roversi as a surname.\nPaolo Roversi is a photographer.\nA photographer is a professional or an amateur.",
        "premises-FOL": [
            "ItalianName(Roversi) & Surname(Roversi)\nUseAsSurname(AlbaRoversi, Roversi)\nUseAsSurname(PaoloRoversi, Roversi)\nUseAsSurname(RobertoRoversi, Roversi)\nPhotographer(PaoloRoversi)\nall x. (Photographer(x) -> ((Professional(x) & -Amateur(x)) | (-Professional(x) & Amateur(x))))"
        ],
        "conclusion": "There are no photographers using an Italian surname.",
        "conclusion-FOL": "-(exists x. exists y. (Photographer(x) & ItalianName(y) & Surname(y) & UseAsSurname(x, y)))",
        "label": "ERROR"
    },
    {
        "premises": "Roversi is an Italian surname.\nAlba Roversi uses Roversi as a surname.\nPaolo Roversi uses Roversi as a surname.\nRoberto Roversi uses Roversi as a surname.\nPaolo Roversi is a photographer.\nA photographer is a professional or an amateur.",
        "premises-FOL": [
            "ItalianName(Roversi) & Surname(Roversi)\nUseAsSurname(AlbaRoversi, Roversi)\nUseAsSurname(PaoloRoversi, Roversi)\nUseAsSurname(RobertoRoversi, Roversi)\nPhotographer(PaoloRoversi)\nall x. (Photographer(x) -> ((Professional(x) & -Amateur(x)) | (-Professional(x) & Amateur(x))))"
        ],
        "conclusion": "Paolo is an amateur photographer.",
        "conclusion-FOL": "Amateur(PaoloRoversi) & Photographer(PaoloRoversi)",
        "label": "ERROR"
    },
    {
        "premises": "Zaha Hadid is a British-Iraqi architect, artist, and designer.\nZaha Hadid was born on 31 October 1950 in Baghdad, Iraq.\nZaha Hadid was a visiting professor of Architectural Design at the Yale School of Architecture.\nMax is an aspiring architecture student and plans to apply to the Yale School of Architecture. ",
        "premises-FOL": [
            "British-Iraqi(ZahaHadid) & Architect(ZahaHadid) & Artist(ZahaHadid) & Designer(ZahaHadid)\nBornOn(ZahaHadid, ThreeOneOctoberOneNineFiveZero) & BornIn(ZahaHadid, BaghdadIraq)\nVisitingProfessorOf(ZahaHadid, ArchitecturalDesign) & VisitingProfessorAt(ZahaHadid, YaleSchoolOfArchitecture)\nAspiringArchitectureStudent(Max) & PlansToApplyTo(Max, YaleSchoolofArchitecture)"
        ],
        "conclusion": "Zaha Hadid was a citizen of Britain and Iraq.",
        "conclusion-FOL": "British-Iraqi(ZahaHadid)",
        "label": "ERROR"
    },
    {
        "premises": "Zaha Hadid is a British-Iraqi architect, artist, and designer.\nZaha Hadid was born on 31 October 1950 in Baghdad, Iraq.\nZaha Hadid was a visiting professor of Architectural Design at the Yale School of Architecture.\nMax is an aspiring architecture student and plans to apply to the Yale School of Architecture. ",
        "premises-FOL": [
            "British-Iraqi(ZahaHadid) & Architect(ZahaHadid) & Artist(ZahaHadid) & Designer(ZahaHadid)\nBornOn(ZahaHadid, ThreeOneOctoberOneNineFiveZero) & BornIn(ZahaHadid, BaghdadIraq)\nVisitingProfessorOf(ZahaHadid, ArchitecturalDesign) & VisitingProfessorAt(ZahaHadid, YaleSchoolOfArchitecture)\nAspiringArchitectureStudent(Max) & PlansToApplyTo(Max, YaleSchoolofArchitecture)"
        ],
        "conclusion": "Zaha Hadid did some work in interior design.",
        "conclusion-FOL": "DidWorkIn(ZahaHadid, InteriorDesign)",
        "label": "ERROR"
    },
    {
        "premises": "Zaha Hadid is a British-Iraqi architect, artist, and designer.\nZaha Hadid was born on 31 October 1950 in Baghdad, Iraq.\nZaha Hadid was a visiting professor of Architectural Design at the Yale School of Architecture.\nMax is an aspiring architecture student and plans to apply to the Yale School of Architecture. ",
        "premises-FOL": [
            "British-Iraqi(ZahaHadid) & Architect(ZahaHadid) & Artist(ZahaHadid) & Designer(ZahaHadid)\nBornOn(ZahaHadid, ThreeOneOctoberOneNineFiveZero) & BornIn(ZahaHadid, BaghdadIraq)\nVisitingProfessorOf(ZahaHadid, ArchitecturalDesign) & VisitingProfessorAt(ZahaHadid, YaleSchoolOfArchitecture)\nAspiringArchitectureStudent(Max) & PlansToApplyTo(Max, YaleSchoolofArchitecture)"
        ],
        "conclusion": "Zaha Hadid was born on the 31st of October in 1982.",
        "conclusion-FOL": "BornOn(ZahaHadid, ThreeOneOctoberOneNineFiveZero)",
        "label": "ERROR"
    },
    {
        "premises": "Zaha Hadid is a British-Iraqi architect, artist, and designer.\nZaha Hadid was born on 31 October 1950 in Baghdad, Iraq.\nZaha Hadid was a visiting professor of Architectural Design at the Yale School of Architecture.\nMax is an aspiring architecture student and plans to apply to the Yale School of Architecture. ",
        "premises-FOL": [
            "British-Iraqi(ZahaHadid) & Architect(ZahaHadid) & Artist(ZahaHadid) & Designer(ZahaHadid)\nBornOn(ZahaHadid, ThreeOneOctoberOneNineFiveZero) & BornIn(ZahaHadid, BaghdadIraq)\nVisitingProfessorOf(ZahaHadid, ArchitecturalDesign) & VisitingProfessorAt(ZahaHadid, YaleSchoolOfArchitecture)\nAspiringArchitectureStudent(Max) & PlansToApplyTo(Max, YaleSchoolofArchitecture)"
        ],
        "conclusion": "Max admires Zaha Hadid.",
        "conclusion-FOL": "Admires(Max, ZahaHadid)",
        "label": "ERROR"
    },
    {
        "premises": "A neuroimaging technique is either an invasive neuroimaging technique or a noninvasive neuroimaging technique. \nAll noninvasive neuroimaging techniques provide a spatial resolution of brains.\nIf a technique provides a spatial resolution of brains, then it is a measurement of brain activity. \nAll measurements of brain activity are used by neuroscience researchers.\nFMRI is either a measurement of brain activity or a noninvasive neuroimaging technique.\nFMRI is a neuroimaging technique.",
        "premises-FOL": [
            "all x. (NeuroimagingTechnique(x) -> (((Invasive(x) & -Noninvasive(x)) | (-Invasive(x) & Noninvasive(x))))) \nall x. (Noninvasive(x) -> Provides(x, SpatialResolutionOfBrains))\nall x. (Provides(x, SpatialResolutionOfBrains) -> Measure(x, BrainActivity))\nall x. (Measure(x, BrainActivity) -> UsedBy(x, NeuroscienceResearchers))\n((Measure(fMRI, BrainActivity) & -Noninvasive(fMRI)) | (-Measure(fMRI, BrainActivity) & Noninvasive(fMRI)))\nNeuroimagingTechnique(fMRI)"
        ],
        "conclusion": "FMRI provides a spatial resolution of brains.",
        "conclusion-FOL": "Provides(fMRI, SpatialResolutionOfBrains)",
        "label": "ERROR"
    },
    {
        "premises": "A neuroimaging technique is either an invasive neuroimaging technique or a noninvasive neuroimaging technique. \nAll noninvasive neuroimaging techniques provide a spatial resolution of brains.\nIf a technique provides a spatial resolution of brains, then it is a measurement of brain activity. \nAll measurements of brain activity are used by neuroscience researchers.\nFMRI is either a measurement of brain activity or a noninvasive neuroimaging technique.\nFMRI is a neuroimaging technique.",
        "premises-FOL": [
            "all x. (NeuroimagingTechnique(x) -> (((Invasive(x) & -Noninvasive(x)) | (-Invasive(x) & Noninvasive(x))))) \nall x. (Noninvasive(x) -> Provides(x, SpatialResolutionOfBrains))\nall x. (Provides(x, SpatialResolutionOfBrains) -> Measure(x, BrainActivity))\nall x. (Measure(x, BrainActivity) -> UsedBy(x, NeuroscienceResearchers))\n((Measure(fMRI, BrainActivity) & -Noninvasive(fMRI)) | (-Measure(fMRI, BrainActivity) & Noninvasive(fMRI)))\nNeuroimagingTechnique(fMRI)"
        ],
        "conclusion": "FMRI is an invasive neuroimaging technique and is used by neuroscience researchers.",
        "conclusion-FOL": "Invasive(fMRI) & UsedBy(fMRI, NeuroscienceResearchers)",
        "label": "ERROR"
    },
    {
        "premises": "A neuroimaging technique is either an invasive neuroimaging technique or a noninvasive neuroimaging technique. \nAll noninvasive neuroimaging techniques provide a spatial resolution of brains.\nIf a technique provides a spatial resolution of brains, then it is a measurement of brain activity. \nAll measurements of brain activity are used by neuroscience researchers.\nFMRI is either a measurement of brain activity or a noninvasive neuroimaging technique.\nFMRI is a neuroimaging technique.",
        "premises-FOL": [
            "all x. (NeuroimagingTechnique(x) -> (((Invasive(x) & -Noninvasive(x)) | (-Invasive(x) & Noninvasive(x))))) \nall x. (Noninvasive(x) -> Provides(x, SpatialResolutionOfBrains))\nall x. (Provides(x, SpatialResolutionOfBrains) -> Measure(x, BrainActivity))\nall x. (Measure(x, BrainActivity) -> UsedBy(x, NeuroscienceResearchers))\n((Measure(fMRI, BrainActivity) & -Noninvasive(fMRI)) | (-Measure(fMRI, BrainActivity) & Noninvasive(fMRI)))\nNeuroimagingTechnique(fMRI)"
        ],
        "conclusion": "FMRI is either an invasive neuroimaging technique or is used by neuroscience researchers.",
        "conclusion-FOL": "((Invasive(fMRI) & -UsedBy(fMRI, NeuroscienceResearchers)) | (-Invasive(fMRI) & UsedBy(fMRI, NeuroscienceResearchers)))",
        "label": "ERROR"
    },
    {
        "premises": "A neuroimaging technique is either an invasive neuroimaging technique or a noninvasive neuroimaging technique. \nAll noninvasive neuroimaging techniques provide a spatial resolution of brains.\nIf a technique provides a spatial resolution of brains, then it is a measurement of brain activity. \nAll measurements of brain activity are used by neuroscience researchers.\nFMRI is either a measurement of brain activity or a noninvasive neuroimaging technique.\nFMRI is a neuroimaging technique.",
        "premises-FOL": [
            "all x. (NeuroimagingTechnique(x) -> (((Invasive(x) & -Noninvasive(x)) | (-Invasive(x) & Noninvasive(x))))) \nall x. (Noninvasive(x) -> Provides(x, SpatialResolutionOfBrains))\nall x. (Provides(x, SpatialResolutionOfBrains) -> Measure(x, BrainActivity))\nall x. (Measure(x, BrainActivity) -> UsedBy(x, NeuroscienceResearchers))\n((Measure(fMRI, BrainActivity) & -Noninvasive(fMRI)) | (-Measure(fMRI, BrainActivity) & Noninvasive(fMRI)))\nNeuroimagingTechnique(fMRI)"
        ],
        "conclusion": "If fMRI is not an invasive neuroimaging technique used by neuroscience researchers, then fMRI is neither a noninvasive neuroimaging technique nor provides a spatial resolution of brains.",
        "conclusion-FOL": "-(Invasive(fMRI) & UsedBy(fMRI, NeuroscienceResearchers)) -> -(Noninvasive(fMRI) | Provides(fMRI, SpatialResolutionOfBrains))",
        "label": "ERROR"
    },
    {
        "premises": "Researchers present their work at the conference or provide a tutorial session there.\nEveryone who presents their work at the conference will attend in person. \nEveryone providing a tutorial session at the conference will be invited to join the club. \nEveryone who attends the conference in person is provided with souvenirs. \nEveryone invited to join the club is provided with delicious meals. \nEveryone provided with delicious meals is happy to communicate with each other during the dinner. \nEveryone who is provided with delicious meals is invited to take a photo with the audience. \nIt is not true that James both attended the conference in person and was provided with souvenirs.",
        "premises-FOL": [
            "all x. (((PresentWorkAt(x, Conference) & -ProvideAt(x, TutorialSession, Conference)) | (-PresentWorkAt(x, Conference) & ProvideAt(x, TutorialSession, Conference))))\nall x. (PresentWorkAt(x, Conference) -> AttendInPerson(x, Conference))\nall x. (ProvideSessionAt(x, Tutorial, Conference) -> InvitedToJoin(x, Club))\nall x. (AttendInPerson(x, Conference) -> ProvidedWith(x, Souvenir))\nall x. (InvitedToJoin(x, Club) -> ProvidedWith(x, DeliciousMeal))\nall x. (ProvidedWith(x, DeliciousMeal) & ProvidedWith(y, DeliciousMeal)  -> exists y. exists z. (-(y=x) & -(z=x) & -(y=z) & HappyToCommunicateWithDuringTheDinner(x, y) & HappyToCommunicateWithDuringTheDinner(x, z)))\nall x. (ProvidedWith(x, DeliciousMeal) -> InvitedToTakePhotoWith(x, Audience))\n-(AttendInPerson(James, Conference) & ProvidedWith(x, Souvenir))"
        ],
        "conclusion": "James is provided with souvenirs.",
        "conclusion-FOL": "ProvidedWith(James, Souvenir)",
        "label": "ERROR"
    },
    {
        "premises": "Researchers present their work at the conference or provide a tutorial session there.\nEveryone who presents their work at the conference will attend in person. \nEveryone providing a tutorial session at the conference will be invited to join the club. \nEveryone who attends the conference in person is provided with souvenirs. \nEveryone invited to join the club is provided with delicious meals. \nEveryone provided with delicious meals is happy to communicate with each other during the dinner. \nEveryone who is provided with delicious meals is invited to take a photo with the audience. \nIt is not true that James both attended the conference in person and was provided with souvenirs.",
        "premises-FOL": [
            "all x. (((PresentWorkAt(x, Conference) & -ProvideAt(x, TutorialSession, Conference)) | (-PresentWorkAt(x, Conference) & ProvideAt(x, TutorialSession, Conference))))\nall x. (PresentWorkAt(x, Conference) -> AttendInPerson(x, Conference))\nall x. (ProvideSessionAt(x, Tutorial, Conference) -> InvitedToJoin(x, Club))\nall x. (AttendInPerson(x, Conference) -> ProvidedWith(x, Souvenir))\nall x. (InvitedToJoin(x, Club) -> ProvidedWith(x, DeliciousMeal))\nall x. (ProvidedWith(x, DeliciousMeal) & ProvidedWith(y, DeliciousMeal)  -> exists y. exists z. (-(y=x) & -(z=x) & -(y=z) & HappyToCommunicateWithDuringTheDinner(x, y) & HappyToCommunicateWithDuringTheDinner(x, z)))\nall x. (ProvidedWith(x, DeliciousMeal) -> InvitedToTakePhotoWith(x, Audience))\n-(AttendInPerson(James, Conference) & ProvidedWith(x, Souvenir))"
        ],
        "conclusion": "James is not provided with souvenirs.",
        "conclusion-FOL": "-ProvidedWith(x, Souvenir)",
        "label": "ERROR"
    },
    {
        "premises": "Researchers present their work at the conference or provide a tutorial session there.\nEveryone who presents their work at the conference will attend in person. \nEveryone providing a tutorial session at the conference will be invited to join the club. \nEveryone who attends the conference in person is provided with souvenirs. \nEveryone invited to join the club is provided with delicious meals. \nEveryone provided with delicious meals is happy to communicate with each other during the dinner. \nEveryone who is provided with delicious meals is invited to take a photo with the audience. \nIt is not true that James both attended the conference in person and was provided with souvenirs.",
        "premises-FOL": [
            "all x. (((PresentWorkAt(x, Conference) & -ProvideAt(x, TutorialSession, Conference)) | (-PresentWorkAt(x, Conference) & ProvideAt(x, TutorialSession, Conference))))\nall x. (PresentWorkAt(x, Conference) -> AttendInPerson(x, Conference))\nall x. (ProvideSessionAt(x, Tutorial, Conference) -> InvitedToJoin(x, Club))\nall x. (AttendInPerson(x, Conference) -> ProvidedWith(x, Souvenir))\nall x. (InvitedToJoin(x, Club) -> ProvidedWith(x, DeliciousMeal))\nall x. (ProvidedWith(x, DeliciousMeal) & ProvidedWith(y, DeliciousMeal)  -> exists y. exists z. (-(y=x) & -(z=x) & -(y=z) & HappyToCommunicateWithDuringTheDinner(x, y) & HappyToCommunicateWithDuringTheDinner(x, z)))\nall x. (ProvidedWith(x, DeliciousMeal) -> InvitedToTakePhotoWith(x, Audience))\n-(AttendInPerson(James, Conference) & ProvidedWith(x, Souvenir))"
        ],
        "conclusion": "James is invited to take a photo with the audience and is happy to communicate with other guests at the dinner.",
        "conclusion-FOL": "InvitedToTakePhotoWith(James, Audience) -> exists y. exists z. (-(y=James) & -(z=James) & -(y=z) & HappyToCommunicateWithDuringTheDinner(James, y) & HappyToCommunicateWithDuringDinner(James, z)))",
        "label": "ERROR"
    },
    {
        "premises": "Researchers present their work at the conference or provide a tutorial session there.\nEveryone who presents their work at the conference will attend in person. \nEveryone providing a tutorial session at the conference will be invited to join the club. \nEveryone who attends the conference in person is provided with souvenirs. \nEveryone invited to join the club is provided with delicious meals. \nEveryone provided with delicious meals is happy to communicate with each other during the dinner. \nEveryone who is provided with delicious meals is invited to take a photo with the audience. \nIt is not true that James both attended the conference in person and was provided with souvenirs.",
        "premises-FOL": [
            "all x. (((PresentWorkAt(x, Conference) & -ProvideAt(x, TutorialSession, Conference)) | (-PresentWorkAt(x, Conference) & ProvideAt(x, TutorialSession, Conference))))\nall x. (PresentWorkAt(x, Conference) -> AttendInPerson(x, Conference))\nall x. (ProvideSessionAt(x, Tutorial, Conference) -> InvitedToJoin(x, Club))\nall x. (AttendInPerson(x, Conference) -> ProvidedWith(x, Souvenir))\nall x. (InvitedToJoin(x, Club) -> ProvidedWith(x, DeliciousMeal))\nall x. (ProvidedWith(x, DeliciousMeal) & ProvidedWith(y, DeliciousMeal)  -> exists y. exists z. (-(y=x) & -(z=x) & -(y=z) & HappyToCommunicateWithDuringTheDinner(x, y) & HappyToCommunicateWithDuringTheDinner(x, z)))\nall x. (ProvidedWith(x, DeliciousMeal) -> InvitedToTakePhotoWith(x, Audience))\n-(AttendInPerson(James, Conference) & ProvidedWith(x, Souvenir))"
        ],
        "conclusion": "James is invited to take a photo with the audience or is happy to communicate with other guests(?) during the dinner.",
        "conclusion-FOL": "InvitedToTakePhotoWith(James, Audience) -> exists y. exists z. (-(y=James) & -(z=James) & -(y=z) & HappyToCommunicateWithDuringTheDinner(James, y) & HappyToCommunicateWithDuringDinner(James, z)))",
        "label": "ERROR"
    },
    {
        "premises": "Researchers present their work at the conference or provide a tutorial session there.\nEveryone who presents their work at the conference will attend in person. \nEveryone providing a tutorial session at the conference will be invited to join the club. \nEveryone who attends the conference in person is provided with souvenirs. \nEveryone invited to join the club is provided with delicious meals. \nEveryone provided with delicious meals is happy to communicate with each other during the dinner. \nEveryone who is provided with delicious meals is invited to take a photo with the audience. \nIt is not true that James both attended the conference in person and was provided with souvenirs.",
        "premises-FOL": [
            "all x. (((PresentWorkAt(x, Conference) & -ProvideAt(x, TutorialSession, Conference)) | (-PresentWorkAt(x, Conference) & ProvideAt(x, TutorialSession, Conference))))\nall x. (PresentWorkAt(x, Conference) -> AttendInPerson(x, Conference))\nall x. (ProvideSessionAt(x, Tutorial, Conference) -> InvitedToJoin(x, Club))\nall x. (AttendInPerson(x, Conference) -> ProvidedWith(x, Souvenir))\nall x. (InvitedToJoin(x, Club) -> ProvidedWith(x, DeliciousMeal))\nall x. (ProvidedWith(x, DeliciousMeal) & ProvidedWith(y, DeliciousMeal)  -> exists y. exists z. (-(y=x) & -(z=x) & -(y=z) & HappyToCommunicateWithDuringTheDinner(x, y) & HappyToCommunicateWithDuringTheDinner(x, z)))\nall x. (ProvidedWith(x, DeliciousMeal) -> InvitedToTakePhotoWith(x, Audience))\n-(AttendInPerson(James, Conference) & ProvidedWith(x, Souvenir))"
        ],
        "conclusion": "James is either invited to take a photo with the audience or happy to communicate with other guests(?) during the dinner.",
        "conclusion-FOL": "InvitedToTakePhotoWith(James, Audience) -> exists y. exists z. (-(y=James) & -(z=James) & -(y=z) & HappyToCommunicateWithDuringTheDinner(James, y) & HappyToCommunicateWithDuringDinner(James, z)))",
        "label": "ERROR"
    },
    {
        "premises": "The USS Salem is a heavy cruiser built for the United States Navy.\nThe last heavy cruiser to enter service was the USS Salem.\nThe USS Salem is a museum ship.\nMuseum ships are open to the public.\nThe USS Salem served in the Atlantic and Mediterranean.",
        "premises-FOL": [
            "HeavyCruiser(Usssalem) & BuiltFor(Usssalem, Unitedstatesnavy)\nLastHeavyCruiserToEnterService(Usssalem)\nMuseumShip(Usssalem)\nall x. (MuseumShip(x) -> OpenToPublic(x))\nServedIn(Usssalem, Atlantic) & ServedIn(Usssalem, Mediterranean)"
        ],
        "conclusion": "The USS Salem is open to the public.",
        "conclusion-FOL": "OpenToPublic(Usssalem)",
        "label": "ERROR"
    },
    {
        "premises": "The USS Salem is a heavy cruiser built for the United States Navy.\nThe last heavy cruiser to enter service was the USS Salem.\nThe USS Salem is a museum ship.\nMuseum ships are open to the public.\nThe USS Salem served in the Atlantic and Mediterranean.",
        "premises-FOL": [
            "HeavyCruiser(Usssalem) & BuiltFor(Usssalem, Unitedstatesnavy)\nLastHeavyCruiserToEnterService(Usssalem)\nMuseumShip(Usssalem)\nall x. (MuseumShip(x) -> OpenToPublic(x))\nServedIn(Usssalem, Atlantic) & ServedIn(Usssalem, Mediterranean)"
        ],
        "conclusion": "There is a museum ship open to the public that served in the Mediterranean.",
        "conclusion-FOL": "exists x. (MuseumShip(x) & OpenToPublic(x) & ServedIn(x, Mediterranean))",
        "label": "ERROR"
    },
    {
        "premises": "The USS Salem is a heavy cruiser built for the United States Navy.\nThe last heavy cruiser to enter service was the USS Salem.\nThe USS Salem is a museum ship.\nMuseum ships are open to the public.\nThe USS Salem served in the Atlantic and Mediterranean.",
        "premises-FOL": [
            "HeavyCruiser(Usssalem) & BuiltFor(Usssalem, Unitedstatesnavy)\nLastHeavyCruiserToEnterService(Usssalem)\nMuseumShip(Usssalem)\nall x. (MuseumShip(x) -> OpenToPublic(x))\nServedIn(Usssalem, Atlantic) & ServedIn(Usssalem, Mediterranean)"
        ],
        "conclusion": "The USS Salem was not the last heavy cruiser to enter service.",
        "conclusion-FOL": "-LastHeavyCruiserToEnterService(Usssalem)",
        "label": "ERROR"
    },
    {
        "premises": "TS Leda was a good passenger and cargo vessel.\nTS Leda was a Norwegian vessel that was built with stabilizers.\nStabilizers are mechanical devices found only on ships with powerful steam turbine engines.\nTo be a good passenger and cargo vessel, ships must be quiet and good at sea.\nSome ships that are quiet and good at sea have powerful steam turbine engines.\nVessels are ships.",
        "premises-FOL": [
            "all x. (TSLeda(x) -> ((Passenger(x) & Vessel(x)) & (Cargo(x) & Vessel(x)))\nall x. (TSLeda(x) -> (Norweigian(x) & Vessel(x) & Stabilizers(x)))\nall x. (Stabilizers(x) -> MechanicalDevice(x) & OnlyOnShips(x) & PowerfulSteamTurbine(x))\nall x. ((Passenger(x) & Vessel(x)) & (Cargo(x) & Vessel(x)) -> (Quiet(x) & GoodAt(x, Sea)))\nexists x. (Quiet(x) & GoodAt(x, Sea) & PowerfulSteamTurbine(x))\nall x. (Ship(x) -> Vessel(x))"
        ],
        "conclusion": "TS Leda was quiet and good at sea.",
        "conclusion-FOL": "all x. (TSLeda(x) -> Quiet(x) & GoodAt(x, Sea))",
        "label": "ERROR"
    },
    {
        "premises": "TS Leda was a good passenger and cargo vessel.\nTS Leda was a Norwegian vessel that was built with stabilizers.\nStabilizers are mechanical devices found only on ships with powerful steam turbine engines.\nTo be a good passenger and cargo vessel, ships must be quiet and good at sea.\nSome ships that are quiet and good at sea have powerful steam turbine engines.\nVessels are ships.",
        "premises-FOL": [
            "all x. (TSLeda(x) -> ((Passenger(x) & Vessel(x)) & (Cargo(x) & Vessel(x)))\nall x. (TSLeda(x) -> (Norweigian(x) & Vessel(x) & Stabilizers(x)))\nall x. (Stabilizers(x) -> MechanicalDevice(x) & OnlyOnShips(x) & PowerfulSteamTurbine(x))\nall x. ((Passenger(x) & Vessel(x)) & (Cargo(x) & Vessel(x)) -> (Quiet(x) & GoodAt(x, Sea)))\nexists x. (Quiet(x) & GoodAt(x, Sea) & PowerfulSteamTurbine(x))\nall x. (Ship(x) -> Vessel(x))"
        ],
        "conclusion": "TS Leda had powerful steam turbine engines.",
        "conclusion-FOL": "all x. (TSLeda(x) -> PowerfulSteamTurbine(x))",
        "label": "ERROR"
    },
    {
        "premises": "TS Leda was a good passenger and cargo vessel.\nTS Leda was a Norwegian vessel that was built with stabilizers.\nStabilizers are mechanical devices found only on ships with powerful steam turbine engines.\nTo be a good passenger and cargo vessel, ships must be quiet and good at sea.\nSome ships that are quiet and good at sea have powerful steam turbine engines.\nVessels are ships.",
        "premises-FOL": [
            "all x. (TSLeda(x) -> ((Passenger(x) & Vessel(x)) & (Cargo(x) & Vessel(x)))\nall x. (TSLeda(x) -> (Norweigian(x) & Vessel(x) & Stabilizers(x)))\nall x. (Stabilizers(x) -> MechanicalDevice(x) & OnlyOnShips(x) & PowerfulSteamTurbine(x))\nall x. ((Passenger(x) & Vessel(x)) & (Cargo(x) & Vessel(x)) -> (Quiet(x) & GoodAt(x, Sea)))\nexists x. (Quiet(x) & GoodAt(x, Sea) & PowerfulSteamTurbine(x))\nall x. (Ship(x) -> Vessel(x))"
        ],
        "conclusion": "TS Leda was not a Norwegian vessel.",
        "conclusion-FOL": "all x. (TSLeda(x) -> -(Norweigian(x) & Vessel(x)))",
        "label": "ERROR"
    },
    {
        "premises": "Rosa was born in Santiago. \nSantiago is the capital and largest city of Chile.\nRosa is the daughter of a Catalan building contractor, Jose.\nJose has a Chilean wife, Carmen.\nCarmen and Jose are Rosa's parents.\nPeople from Catalan are not from Chile.\nA building contractor is responsible for the day-to-day oversight of a construction site. ",
        "premises-FOL": [
            "BornIn(Rosa, Santiago)\nCapitalOf(Santiago, Chile) & LargestCityOf(Santiago, Chile)\nDaughterOf(Rosa, Jose) & BuildingContractor(Jose) & Catalan(Jose)\nWifeOf(Jose, Carmen) & Chilean(Carmen)\nParentOf(Jose, Rosa) & ParentOf(Carmen, Rosa)\nall x. (Catalan(x) -> -Chilean(x))\nall x. exists y. (BuildingContractor(x) -> ConstructionSite(y) & Oversee(x, y))"
        ],
        "conclusion": "Rosa was born in the largest city of Chile.",
        "conclusion-FOL": "exists x. (BornIn(Rosa, x) & LargestCityOf(x, Chile))",
        "label": "ERROR"
    },
    {
        "premises": "Rosa was born in Santiago. \nSantiago is the capital and largest city of Chile.\nRosa is the daughter of a Catalan building contractor, Jose.\nJose has a Chilean wife, Carmen.\nCarmen and Jose are Rosa's parents.\nPeople from Catalan are not from Chile.\nA building contractor is responsible for the day-to-day oversight of a construction site. ",
        "premises-FOL": [
            "BornIn(Rosa, Santiago)\nCapitalOf(Santiago, Chile) & LargestCityOf(Santiago, Chile)\nDaughterOf(Rosa, Jose) & BuildingContractor(Jose) & Catalan(Jose)\nWifeOf(Jose, Carmen) & Chilean(Carmen)\nParentOf(Jose, Rosa) & ParentOf(Carmen, Rosa)\nall x. (Catalan(x) -> -Chilean(x))\nall x. exists y. (BuildingContractor(x) -> ConstructionSite(y) & Oversee(x, y))"
        ],
        "conclusion": "Neither of Rosa's parents is Chilean.",
        "conclusion-FOL": "-Chilean(Jose) & -Chilean(Carmen)",
        "label": "ERROR"
    },
    {
        "premises": "Rosa was born in Santiago. \nSantiago is the capital and largest city of Chile.\nRosa is the daughter of a Catalan building contractor, Jose.\nJose has a Chilean wife, Carmen.\nCarmen and Jose are Rosa's parents.\nPeople from Catalan are not from Chile.\nA building contractor is responsible for the day-to-day oversight of a construction site. ",
        "premises-FOL": [
            "BornIn(Rosa, Santiago)\nCapitalOf(Santiago, Chile) & LargestCityOf(Santiago, Chile)\nDaughterOf(Rosa, Jose) & BuildingContractor(Jose) & Catalan(Jose)\nWifeOf(Jose, Carmen) & Chilean(Carmen)\nParentOf(Jose, Rosa) & ParentOf(Carmen, Rosa)\nall x. (Catalan(x) -> -Chilean(x))\nall x. exists y. (BuildingContractor(x) -> ConstructionSite(y) & Oversee(x, y))"
        ],
        "conclusion": "Rosa is the daughter of someone who is responsible for the oversight of traffic.",
        "conclusion-FOL": "exists x. (DaughterOf(Rosa, x) & Oversee(x, Traffic))",
        "label": "ERROR"
    },
    {
        "premises": "Tyga is a rapper.\nRappers release rap albums.\nTyga released the Well Done 3 album.\nRappers are not opera singers.",
        "premises-FOL": [
            "IsRapper(Tyga)\nall x. all y. ((IsRapper(x) & ReleasedAlbum(x, y)) -> IsRapAlbum(y))\nReleasedAlbum(Tyga, WellDoneThree)\nall x. (IsRapper(x) -> -IsOperaSinger(x))"
        ],
        "conclusion": "Well Done 3 is a rap album.",
        "conclusion-FOL": "IsRapAlbum(WellDoneThree)",
        "label": "ERROR"
    },
    {
        "premises": "Tyga is a rapper.\nRappers release rap albums.\nTyga released the Well Done 3 album.\nRappers are not opera singers.",
        "premises-FOL": [
            "IsRapper(Tyga)\nall x. all y. ((IsRapper(x) & ReleasedAlbum(x, y)) -> IsRapAlbum(y))\nReleasedAlbum(Tyga, WellDoneThree)\nall x. (IsRapper(x) -> -IsOperaSinger(x))"
        ],
        "conclusion": "Tyga is an opera singer.",
        "conclusion-FOL": "IsOperaSinger(Tyga)",
        "label": "ERROR"
    },
    {
        "premises": "Tyga is a rapper.\nRappers release rap albums.\nTyga released the Well Done 3 album.\nRappers are not opera singers.",
        "premises-FOL": [
            "IsRapper(Tyga)\nall x. all y. ((IsRapper(x) & ReleasedAlbum(x, y)) -> IsRapAlbum(y))\nReleasedAlbum(Tyga, WellDoneThree)\nall x. (IsRapper(x) -> -IsOperaSinger(x))"
        ],
        "conclusion": "Well Done 3 is worth listening to.",
        "conclusion-FOL": "IsWorthListening(WellDoneThree)",
        "label": "ERROR"
    },
    {
        "premises": "Deborah Wallace is a Scottish-born actress, playwright, and producer.\nPsyche is a play based on the life of James Miranda Barry.\nHomesick, Psyche and The Void are plays by Deborah Wallace.\nDeborah Wallace co-produced Gasland.",
        "premises-FOL": [
            "BornIn(DeborahWallace, Scotland) & Actress(DeborahWallace) & Playwright(DeborahWallace) & Producer(DeborahWallace)\nPlay(Psyche) & BasedOn(Psyche, LifeOfJamesMirandaBarry)\nPlay(Homesick) & WrittenBy(Homesick, DeborahWallace) & Play(Psyche) & WrittenBy(Psyche, DeborahWallace) & Play(TheVoid) & WrittenBy(TheVoid, DeborahWallace)\nCoProduce(DeborahWallace, Gasland)"
        ],
        "conclusion": "Gasland was coproduced by the same person Homesick was from.",
        "conclusion-FOL": "exists x. (CoProduces(x, Gasland) & WrittenBy(Homesick, x))",
        "label": "ERROR"
    },
    {
        "premises": "Deborah Wallace is a Scottish-born actress, playwright, and producer.\nPsyche is a play based on the life of James Miranda Barry.\nHomesick, Psyche and The Void are plays by Deborah Wallace.\nDeborah Wallace co-produced Gasland.",
        "premises-FOL": [
            "BornIn(DeborahWallace, Scotland) & Actress(DeborahWallace) & Playwright(DeborahWallace) & Producer(DeborahWallace)\nPlay(Psyche) & BasedOn(Psyche, LifeOfJamesMirandaBarry)\nPlay(Homesick) & WrittenBy(Homesick, DeborahWallace) & Play(Psyche) & WrittenBy(Psyche, DeborahWallace) & Play(TheVoid) & WrittenBy(TheVoid, DeborahWallace)\nCoProduce(DeborahWallace, Gasland)"
        ],
        "conclusion": "No plays by Deborah Wallace are based on the life of James Miranda Barry.",
        "conclusion-FOL": "all x. (Play(x) & WrittenBy(x, Deborahwallace) -> -BasedOn(x, Lifeofjamesmirandabarry))",
        "label": "ERROR"
    },
    {
        "premises": "Deborah Wallace is a Scottish-born actress, playwright, and producer.\nPsyche is a play based on the life of James Miranda Barry.\nHomesick, Psyche and The Void are plays by Deborah Wallace.\nDeborah Wallace co-produced Gasland.",
        "premises-FOL": [
            "BornIn(DeborahWallace, Scotland) & Actress(DeborahWallace) & Playwright(DeborahWallace) & Producer(DeborahWallace)\nPlay(Psyche) & BasedOn(Psyche, LifeOfJamesMirandaBarry)\nPlay(Homesick) & WrittenBy(Homesick, DeborahWallace) & Play(Psyche) & WrittenBy(Psyche, DeborahWallace) & Play(TheVoid) & WrittenBy(TheVoid, DeborahWallace)\nCoProduce(DeborahWallace, Gasland)"
        ],
        "conclusion": "Gasland is a play.",
        "conclusion-FOL": "Play(Gasland)",
        "label": "ERROR"
    },
    {
        "premises": "Animals who need large territory travel far.\nEvery animal that eats a lot needs a large territory.\nIf something is a big animal, then it will eat a lot.\nBears are big animals.\nLarry is a big animal.",
        "premises-FOL": [
            "all x. (Animal(x) & Need(x, LargeTerritory) -> TravelFar(x))\nall x. (EatALot(x) -> Need(x, LargeTerritory))\nall x. (Big(x) & Animal(x) -> EatALot(x))\nall x. (Bear(x) -> Big(x) & Animal(x))\nBig(Larry) & Animal(Larry)"
        ],
        "conclusion": "Larry is a bear.",
        "conclusion-FOL": "Bear(Larry)",
        "label": "ERROR"
    },
    {
        "premises": "Animals who need large territory travel far.\nEvery animal that eats a lot needs a large territory.\nIf something is a big animal, then it will eat a lot.\nBears are big animals.\nLarry is a big animal.",
        "premises-FOL": [
            "all x. (Animal(x) & Need(x, LargeTerritory) -> TravelFar(x))\nall x. (EatALot(x) -> Need(x, LargeTerritory))\nall x. (Big(x) & Animal(x) -> EatALot(x))\nall x. (Bear(x) -> Big(x) & Animal(x))\nBig(Larry) & Animal(Larry)"
        ],
        "conclusion": "Larry is not a bear and does not travel far.",
        "conclusion-FOL": "-Bear(Larry) & -TravelFar(Larry)",
        "label": "ERROR"
    },
    {
        "premises": "Animals who need large territory travel far.\nEvery animal that eats a lot needs a large territory.\nIf something is a big animal, then it will eat a lot.\nBears are big animals.\nLarry is a big animal.",
        "premises-FOL": [
            "all x. (Animal(x) & Need(x, LargeTerritory) -> TravelFar(x))\nall x. (EatALot(x) -> Need(x, LargeTerritory))\nall x. (Big(x) & Animal(x) -> EatALot(x))\nall x. (Bear(x) -> Big(x) & Animal(x))\nBig(Larry) & Animal(Larry)"
        ],
        "conclusion": "If Larry either travels far or needs a large territory, then Larry is a bear.",
        "conclusion-FOL": "((TravelFar(Larry) & -Need(Larry, LargeTerritory)) | (-TravelFar(Larry) & Need(Larry, LargeTerritory))) -> Bear(Larry)",
        "label": "ERROR"
    },
    {
        "premises": "Any convicted criminal that is innocent is not truly guilty.\nAll convicted criminals who did not commit a crime are truly innocent.\nAll convicted criminals are truly guilty or found guilty.\nIf a convicted criminal is found guilty, then they are sentenced to a punishment.\nIf a convicted criminal is found guilty, then they can argue against their punishment.\nGarry is a convicted criminal who not found guilty or is sentenced to punishment.",
        "premises-FOL": [
            "all x. (ConvictedCriminal(x) & Innocent(x) -> -TrulyGuilty(x))\nall x. (ConvictedCriminal(x) & -CommitCrime(x) -> Innocent(x))\nall x. (ConvictedCriminal(x) & (TrulyGuilty(x) | FoundGuilty(x)))\nall x. (ConvictedCriminal(x) & FoundGuilty(x) -> SentencedToPunishment(x))\nall x. (ConvictedCriminal(x) & FoundGuilty(x) -> CanArgueAgainst(x, Punishment))\nConvictedCriminal(Garry) & (-(FoundGuilty(Garry) | SentencedToPunishment(Garry)))"
        ],
        "conclusion": "Garry is sentenced to a punishment.",
        "conclusion-FOL": "SentencedToPunishment(Garry)",
        "label": "ERROR"
    },
    {
        "premises": "Any convicted criminal that is innocent is not truly guilty.\nAll convicted criminals who did not commit a crime are truly innocent.\nAll convicted criminals are truly guilty or found guilty.\nIf a convicted criminal is found guilty, then they are sentenced to a punishment.\nIf a convicted criminal is found guilty, then they can argue against their punishment.\nGarry is a convicted criminal who not found guilty or is sentenced to punishment.",
        "premises-FOL": [
            "all x. (ConvictedCriminal(x) & Innocent(x) -> -TrulyGuilty(x))\nall x. (ConvictedCriminal(x) & -CommitCrime(x) -> Innocent(x))\nall x. (ConvictedCriminal(x) & (TrulyGuilty(x) | FoundGuilty(x)))\nall x. (ConvictedCriminal(x) & FoundGuilty(x) -> SentencedToPunishment(x))\nall x. (ConvictedCriminal(x) & FoundGuilty(x) -> CanArgueAgainst(x, Punishment))\nConvictedCriminal(Garry) & (-(FoundGuilty(Garry) | SentencedToPunishment(Garry)))"
        ],
        "conclusion": "Garry did not commit a crime and can argue against his punishment.",
        "conclusion-FOL": "-CommitCrime(Garry) & CanArgueAgainst(Garry, Punishment)",
        "label": "ERROR"
    },
    {
        "premises": "Any convicted criminal that is innocent is not truly guilty.\nAll convicted criminals who did not commit a crime are truly innocent.\nAll convicted criminals are truly guilty or found guilty.\nIf a convicted criminal is found guilty, then they are sentenced to a punishment.\nIf a convicted criminal is found guilty, then they can argue against their punishment.\nGarry is a convicted criminal who not found guilty or is sentenced to punishment.",
        "premises-FOL": [
            "all x. (ConvictedCriminal(x) & Innocent(x) -> -TrulyGuilty(x))\nall x. (ConvictedCriminal(x) & -CommitCrime(x) -> Innocent(x))\nall x. (ConvictedCriminal(x) & (TrulyGuilty(x) | FoundGuilty(x)))\nall x. (ConvictedCriminal(x) & FoundGuilty(x) -> SentencedToPunishment(x))\nall x. (ConvictedCriminal(x) & FoundGuilty(x) -> CanArgueAgainst(x, Punishment))\nConvictedCriminal(Garry) & (-(FoundGuilty(Garry) | SentencedToPunishment(Garry)))"
        ],
        "conclusion": "Garry is not both innocent and someone who did not commit a crime.",
        "conclusion-FOL": "-(Innocent(Garry) & -CommitCrime(Garry))",
        "label": "ERROR"
    },
    {
        "premises": "Phoneix's music is classified under the indie pop genre.\nPhoenix is a band from France.\nFrench bands write songs in French or in English.\nAside from indie pop, pop rock and synth-pop are two other genres of music.\nPhoenix has no songs in French.",
        "premises-FOL": [
            "IndiePop(Phoenix)\nBand(Phoenix) & From(Phoenix, France)\nall x. exists y. (Band(x) & From(x, France) & Write(x, y) & Song(y) -> ((InFrench(y) & -InEnglish(y)) | (-InFrench(y) & InEnglish(y))))\nall x. (IndiePop(x) -> -PopRock(x) & -SynthPop(x))\nall x. (Song(x) & By(Phoenix, x) -> -InFrench(x))"
        ],
        "conclusion": "Phoneix's music is classified under the pop rock genre.",
        "conclusion-FOL": "PopRock(Phoenix)",
        "label": "ERROR"
    },
    {
        "premises": "Phoneix's music is classified under the indie pop genre.\nPhoenix is a band from France.\nFrench bands write songs in French or in English.\nAside from indie pop, pop rock and synth-pop are two other genres of music.\nPhoenix has no songs in French.",
        "premises-FOL": [
            "IndiePop(Phoenix)\nBand(Phoenix) & From(Phoenix, France)\nall x. exists y. (Band(x) & From(x, France) & Write(x, y) & Song(y) -> ((InFrench(y) & -InEnglish(y)) | (-InFrench(y) & InEnglish(y))))\nall x. (IndiePop(x) -> -PopRock(x) & -SynthPop(x))\nall x. (Song(x) & By(Phoenix, x) -> -InFrench(x))"
        ],
        "conclusion": "Phoenix writes songs in French.",
        "conclusion-FOL": "exists x. (Write(Phoenix, y) & Song(x) -> InFrench(x))",
        "label": "ERROR"
    }
]